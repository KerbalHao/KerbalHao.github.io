<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>浏览器是如何渲染网页的？——DOM,CSSOM以及渲染 - kerbalHao</title><meta description="翻译自 Uday Hiwarale 的 How the browser renders a web page? — DOM, CSSOM, and Rendering  前言当你开发一个网站的时候，有些东西对于良好的用户体验来说是非常必要的。网站可能遇到的一些常见问题可能是资源加载缓慢，在初始渲染时等待不必要的文件下载，样式未应用的内容闪烁(flash of unstyled content ("><meta property="og:type" content="article"><meta property="og:title" content="浏览器是如何渲染网页的？——DOM,CSSOM以及渲染"><meta property="og:url" content="https://kerbalhao.github.io/posts/65f9e7b2/"><meta property="og:site_name" content="KerbalHao"><meta property="og:description" content="翻译自 Uday Hiwarale 的 How the browser renders a web page? — DOM, CSSOM, and Rendering  前言当你开发一个网站的时候，有些东西对于良好的用户体验来说是非常必要的。网站可能遇到的一些常见问题可能是资源加载缓慢，在初始渲染时等待不必要的文件下载，样式未应用的内容闪烁(flash of unstyled content ("><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/kerbalhao/blog_images/avatar.jpg"><meta property="article:published_time" content="2021-04-17T02:35:10.000Z"><meta property="article:modified_time" content="2022-04-06T10:48:44.284Z"><meta property="article:author" content="KerbalHao"><meta property="article:tag" content="categories-browser"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/kerbalhao/blog_images/avatar.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kerbalhao.github.io/posts/65f9e7b2/"},"headline":"浏览器是如何渲染网页的？——DOM,CSSOM以及渲染","image":["https://cdn.jsdelivr.net/gh/kerbalhao/blog_images/avatar.jpg"],"datePublished":"2021-04-17T02:35:10.000Z","dateModified":"2022-04-06T10:48:44.284Z","author":{"@type":"Person","name":"KerbalHao"},"description":"翻译自 Uday Hiwarale 的 How the browser renders a web page? — DOM, CSSOM, and Rendering  前言当你开发一个网站的时候，有些东西对于良好的用户体验来说是非常必要的。网站可能遇到的一些常见问题可能是资源加载缓慢，在初始渲染时等待不必要的文件下载，样式未应用的内容闪烁(flash of unstyled content ("}</script><link rel="alternative" href="/atom.xml" title="kerbalHao" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@latest/img/wico.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.12/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/css/style.min.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/js/globalUtils.min.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/kerbalhao/blog_images/log.jpg" alt="kerbalHao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/kerbalhao"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/js/theme-setting.min.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2021-04-17T02:35:10.000Z">2021-04-17</time><a class="commentCountImg" href="/posts/65f9e7b2/#comment-container"><span class="display-none-class">9c656cf9ea3f8ab550bb39995180b147</span><img class="not-gallery-item" src="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/img/chat.svg"> <span class="commentCount" id="9c656cf9ea3f8ab550bb39995180b147"> 99+</span>    </a><span class="level-item">1 小时 读完 (大约 10159 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">浏览器是如何渲染网页的？——DOM,CSSOM以及渲染</h1><div class="content"><blockquote>
<p>翻译自 Uday Hiwarale 的 <a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969">How the browser renders a web page? — DOM, CSSOM, and Rendering</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当你开发一个网站的时候，有些东西对于良好的用户体验来说是非常必要的。网站可能遇到的一些常见问题可能是资源加载缓慢，在初始渲染时等待不必要的文件下载，样式未应用的内容闪烁<code>(flash of unstyled content (FOUC))</code>等。为了避免类似问题，我们需要了解浏览器渲染典型网页的生命周期。</p>
<p>首先，我们需要了解什么是 <code>DOM</code>。当浏览器相服务器发送请求，获取一个 <code>HTML</code> 文档的时候，服务器会返回一个二进制流格式的 <code>HTML</code> 页面，它基本就是一个文本文件，其响应头的 <code>Content-Type</code> 设置为 <code>text/html;charset-UTF-8</code>。这里的 <code>text/html</code> ·是一个 <a href="https://en.wikipedia.org/wiki/Media_type">MIME 类型</a>，它告诉浏览器这是一个 <code>HTML</code> 文档，<code>charset=UTF-8</code> 告诉浏览器它是以 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> 字符<a href="https://medium.com/jspoint/introduction-to-character-encoding-3b9735f265a6">编码</a>的。利用这些信息，浏览器剋将二进制格式转换为可读的文本文件。如下图所示。<br><img src="https://i.loli.net/2021/04/17/c1MpWG2FosgNrhl.png" alt="1_Tm-HPhmGA0BL7HIj38H8Qw.png"></p>
<p>如果该 <code>header</code> 缺失，浏览器将无法理解如何处理该文件，它将以纯文本格式呈现。但如果一切正常，经过这次转换后，浏览器就可以开始阅读 <code>HTML</code> 文档了。一个典型的 <code>HTML</code> 文档大致如下:</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Rendering Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- stylesheet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./style.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a sample paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- script --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的文档中，我们的网页依赖 <code>style.css</code> 给 <code>HTML</code> 元素提供样式，<code>main.js</code> 来执行一些 <code>JavaScript</code> 操作。通过一些 <code>CSS</code> 样式，我们上面的网页就会变成这样：<br><img src="https://i.loli.net/2021/04/17/c1MpWG2FosgNrhl.png" alt="1_Tm-HPhmGA0BL7HIj38H8Qw.png"></p>
<p>但问题还是在于，浏览器是如何从一个简单的，只包含文本的 <code>HTML</code> 文件渲染出这个好看的网页呢？为此，我们需要了解什么是 <code>DOM</code>、<code>CSSOM</code> 和 <code>Render Tree</code></p>
<h3 id="Document-Object-Model-DOM"><a href="#Document-Object-Model-DOM" class="headerlink" title="Document Object Model (DOM)"></a>Document Object Model (DOM)</h3><p>当浏览器读取 <code>HTML</code> 代码时，只要遇到 <code>body、div</code> 等 <code>HTML</code> 元素，就会创建一个名为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node">Node</a> 的 <code>JavaScript</code> 对象。</p>
<p>由于每个 HTML 元素都有不同的属性，所以 Node 对象将从不同的类(构造函数)中创建。例如，div 元素的 Node 对象是由继承自 Node 类的 HTMLDivElement 创建的。对于我们前面的 HTML 文档，我们可以用一个简单的测试来可视化这些节点，如下图：<br><img src="https://i.loli.net/2021/04/18/FhZEbDYPlCBifR2.png" alt="1618739869298.png"></p>
<p>浏览器自带了 <code>HTMLDivElement、HTMLScriptElement、Node</code> 等内置类。</p>
<p>浏览器从 HTML 文档中创建了 <code>Node</code> 之后，就要把这些节点对象创建成树状结构。由于我们在 <code>HTML</code> 文件中的 <code>HTML</code> 元素是互相嵌套的，所以浏览器需要使用之前创建的 <code>Node</code> 对象复制它们。这将帮助浏览器在网页的整个生命周期中高效地渲染和管理网页。</p>
<p><img src="https://i.loli.net/2021/04/18/FhZEbDYPlCBifR2.png" alt="1618739869298.png"></p>
<p>我们之前的 <code>HTML</code> 文档的 <code>DOM</code> 树就像上面一样。一棵 <code>DOM</code> 树从最上面的 <code>html</code> 元素开始，根据 <code>HTML</code> 元素在文档中的出现和嵌套情况进行分支。每当发现一个 <code>HTML</code> 元素时，它就会从其各自的类中创建一个 <code>DOM</code> 节点（Node）对象（构造函数）。</p>
<blockquote>
<p>一个 <code>DOM</code> 节点并不总是必须是一个 <code>HTML</code> 元素。当浏览器创建 <code>DOM</code> 树时，它也会将注释、属性、文本等内容作为树中的单独节点保存。但为了简单起见，我们只考虑 <code>HTML</code> 元素的 <code>DOM</code> 节点，也就是 <code>DOM</code> 元素。<a href="https://www.w3schools.com/jsref/prop_node_nodetype.asp">这里</a>是所有 <code>DOM</code> 节点类型的列表。</p>
</blockquote>
<p>你可以在 <code>Google Chrome DevTools Console</code> 中看到 <code>DOM</code> 树，如下所示。这将显示 <code>DOM</code> 元素的层次结构（DOM 树的高级视图）以及每个 <code>DOM</code> 元素的属性。<br><img src="https://i.loli.net/2021/04/18/je8gfiSnCUZ9bY4.png" alt="1618742342888.png"></p>
<p><code>JavaScript</code> 不明白 <code>DOM</code> 是什么，它不是 <code>JavaScript</code> 规范的一部分。DOM 是浏览器提供的一种高级 <a href="https://developer.mozilla.org/en-US/docs/Web/API">Web API</a>，用于高效地渲染网页，供开发者动态操作 DOM 元素以达到各种目的。</p>
<blockquote>
<p>使用 DOM API，开发者可以添加或删除 HTML 元素，改变其外观或绑定事件监听器。使用 DOM API，可以在内存中创建或克隆 HTML 元素，并在不影响 DOM 树的情况下进行修改。这使得开发者有能力构建高度动态的网页，并提供丰富的用户体验。</p>
</blockquote>
<h3 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h3><p>当我们设计一个网站时，我们的目的是让它尽可能的好看。而我们通过为 <code>HTML</code> 元素提供一些样式来实现。在 <code>HTML</code> 页面中，我们使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS">CSS</a>(Cascading Style Sheets，即层叠样式表) 为 <code>HTML</code> 元素提供样式。使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS 选择器</a>，我们可以针对 <code>DOM</code> 元素，为样式属性设置一个值，比如颜色或字体大小。</p>
<p>将样式应用到 <code>HTML</code> 元素上有不同的方法，比如使用外部 <code>CSS</code> 文件、使用 <code>&lt;style&gt;</code> 标签嵌入 <code>CSS</code>、使用 <code>HTML</code> 元素上的 <code>style</code> 属性的内联方法或使用 <code>JavaScript</code>。但最终，浏览器还是要担起将 <code>CSS</code> 样式应用到 <code>DOM</code> 元素上的重任。</p>
<p>比方说，对于我们前面的例子，我们将使用下面的 <code>CSS</code> 样式（这不是截图中显示的卡片所使用的 <code>CSS</code>）。为了简单起见，我们不打算理会如何在 <code>HTML</code> 页面中导入 <code>CSS</code> 样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构建了 <code>DOM</code> 之后，浏览器从所有的源头（外部的、嵌入式的、内嵌的、用户代理的等）读取 <code>CSS</code> ，并构建一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSSOM</a>。<code>CSSOM</code> 是 <code>CSS</code> 对象模型的缩写，它和 <code>DOM</code> 一样是一个树状结构。</p>
<p>这个树中的每个节点都包含 <code>CSS</code> 样式信息，这些信息将被应用到它所针对的 <code>DOM</code> 元素上（由选择器指定）。然而，<code>CSSOM</code> 并不包含那些不能在屏幕上打印的 <code>DOM</code> 元素，如<code>&lt;meta&gt;、&lt;script&gt;、&lt;title&gt;</code>等。</p>
<p>我们知道，大多数浏览器都自带样式表，这个样式表被称为<a href="https://stackoverflow.com/questions/12582624/what-is-a-user-agent-stylesheet">用户代理样式表</a>，浏览器首先用开发者属性提供的 <code>CSS</code> 覆盖用户代理样式（使用特定性的规则），计算出 <code>DOM</code> 元素的最终 <code>CSS</code> 属性，然后构造一个节点。</p>
<p>即使某个 <code>HTML</code> 元素的 <code>CSS</code> 属性（如 <code>display</code> ）没有被开发者或浏览器定义，其值也会被设置为 <a href="https://www.w3.org/Style/CSS/">W3C CSS</a> 标准规定的该属性的默认值。在选择 <code>CSS</code> 属性的默认值时，如果某个属性符合 <a href="https://www.w3.org/TR/CSS1/#inheritance">W3C 文档</a>中提到的继承规则，则会使用一些继承规则。</p>
<p>例如，如果一个 <code>HTML</code> 元素缺少颜色和字体大小等属性，那么这些属性就会继承父元素的值。所以你可以想象一下，在一个 <code>HTML</code> 元素上有这些属性，它的所有子元素都会继承它。这就是所谓的样式层叠，这也是为什么 <code>CSS</code> 是层叠样式表的缩写。这也正是浏览器构建一个树状结构的<code>CSSOM</code> 的原因，用于根据 <code>CSS</code> 层叠规则计算样式。</p>
<blockquote>
<p>您可以在 Element 面板中使用 Chrome DevTools 控制台查看 HTML 元素的计算样式。从左侧面板中选择任意一个 HTML 元素，然后点击右侧面板中的计算选项卡。</p>
</blockquote>
<p>我们可以用下图来使前面例子的 <code>CSSOM</code> 树可视化。为了简单起见，我们将忽略用户代理样式，而专注于前面提到的 <code>CSS</code> 样式。</p>
<p><img src="https://i.loli.net/2021/04/18/gvaLepK5cSJRzqG.png" alt="1618747003004.png"></p>
<p>从上图中可以看出，我们的 <code>CSSOM</code> 树中不包含<code>&lt;link&gt;、&lt;title&gt;、&lt;script&gt;</code>等不会被打印到屏幕上的元素。红色的 <code>CSS</code> 属性值是从顶部层叠下来的，而灰色的属性值则是覆盖了继承的值。</p>
<h3 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h3><p><code>Render-Tree</code> 也是一个将 <code>DOM</code> 树和 <code>CSSOM</code> 树组合在一起构建的树状结构。浏览器要计算每个可见元素的布局，并把它们画在屏幕上，为此浏览器使用了这个 <code>Render-Tree</code>。因此，如果没有构建 <code>Render-Tree</code>，那么任何东西都不会被打印在屏幕上，这就是为什么我们同时需要 DOM 和 CSSOM 树。</p>
<p>由于 <code>Render-Tree</code> 是对最终将被打印在屏幕上的内容的低级表示，它不会包含在像素矩阵(页面)中不包含任何区域(一定情况下可认为是：不占空间)的节点。例如，<code>display:none</code>;元素的尺寸为<code>0px X 0px</code>，因此它们不会出现在 <code>Render-Tree</code> 中。</p>
<p><img src="https://i.loli.net/2021/04/18/zRgLKcTsIUxMAie.png" alt="1618747752887.png"></p>
<p>从上图可以看出，<code>Render-Tree</code> 结合了 <code>DOM</code> 和 <code>CSSOM</code>，生成了一个树状结构，其中只包含了要打印在屏幕上的元素。</p>
<p>因为在 <code>CSSOM</code> 中，位于 <code>div</code> 内的 <code>p</code> 元素被设置了 <code>display:none;</code> 样式，所以它和它的子元素不会出现在 <code>Render-Tree</code> 中，因为它在屏幕上不占空间。但是，如果你有 <code>visibility:hidden</code> 或 <code>opacity:0</code> 的元素，它们将占据屏幕空间，因此它们将出现在 <code>Render-Tree</code> 中。</p>
<p>与 <code>DOM API</code> 不同的是<code>，DOM API</code> 可以访问浏览器构建的 <code>DOM</code> 树中的 <code>DOM</code> 元素，而 <code>CSSOM</code> 则是对用户隐藏的。但由于浏览器将 <code>DOM</code> 和 <code>CSSOM</code> 结合在一起形成了 <code>Render Tree</code>，所以浏览器通过在 <code>DOM</code> 元素本身提供高级 <code>API</code> 来暴露 <code>DOM</code> 元素的 <code>CSSOM</code> 节点。这样开发者就可以访问或改变 <code>CSSOM</code> 节点的 <code>CSS</code> 属性。</p>
<blockquote>
<p>由于使用 <code>JavaScript</code> 操作元素的样式超出了本文的范围，所以这里有一个 <a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/">CSS Tricks 文章的链接</a>，它涵盖了 <code>CSSOM API</code> 的广泛范围。我们还有新的 <code>JavaScript</code> 中的 <a href="https://developers.google.com/web/updates/2018/03/cssom">CSS Typed Object API</a>，它可以更准确地操纵元素的样式。</p>
</blockquote>
<h2 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h2><p>现在我们已经很好地理解了什么是 <code>DOM、CSSOM</code>和 <code>Render-Tree</code>，让我们了解一下浏览如何使用它们来渲染一个典型的网页。对这个过程有一个最起码的了解对任何 Web 开发人员来说都是至关重要的，因为它将帮助我们设计我们的网站以获得最大的用户体验（UX）和性能。</p>
<p>当一个网页被加载时，浏览器首先读取 <code>HTML</code> 文本并从中构建 <code>DOM</code> 树。然后它处理 <code>CSS</code>，无论是内嵌的、嵌入式的、还是外部的 <code>CSS</code>，并从中构建 <code>CSSOM</code> 树。</p>
<p>构建完这些树后，它再从中构建 <code>Render-Tree</code>。一旦构建了 <code>Render-Tree</code>，浏览器就会开始在屏幕上打印各个元素。</p>
<h3 id="布局操作"><a href="#布局操作" class="headerlink" title="布局操作"></a>布局操作</h3><p>首先浏览器创建每个单独的 <code>Render-Tree</code> 节点的布局。布局包括每个节点的大小（以像素为单位）和它将被打印在屏幕上的位置。这个过程被称为布局，因为浏览器正在计算每个节点的布局信息。</p>
<p>这个过程也被称为回流或浏览器回流(reflow)，当你滚动、调整窗口大小或操作 DOM 元素时，也会发生这个过程。<a href="https://stackoverflow.com/a/27637245/2790983">这里</a>是可以触发元素布局/回流的事件列表。</p>
<blockquote>
<p>我们应该避免网页因为微不足道的原因进行多次布局操作，因为这是一种昂贵的操作。<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">这里</a>是 <a href="https://twitter.com/aerotwist">Paul Lewis</a> 的一篇文章，他讲述了我们如何避免复杂而昂贵的布局操作以及<a href="https://kellegous.com/j/2013/01/26/layout-performance/">布局打乱</a>。</p>
</blockquote>
<h3 id="绘制操作"><a href="#绘制操作" class="headerlink" title="绘制操作"></a>绘制操作</h3><p>直到现在，我们还有一个需要打印在屏幕上的几何体列表。由于 <code>Render-Tree</code> 中的元素（或子树）可以相互重叠，而且它们可以具有 <code>CSS</code> 属性，使它们经常改变外观、位置或几何显示（如动画），因此浏览器会为它创建一个图层。</p>
<p>创建图层可以帮助浏览器在网页的整个生命周期中高效地执行绘制操作，比如在滚动或调整浏览器窗口大小的时候。拥有图层还可以帮助浏览器按照开发者的意图，正确地按照堆叠顺序（沿 z 轴）绘制元素。</p>
<p>现在我们有了图层，我们可以将它们组合起来，并在屏幕上绘制。但是浏览器并不是一次性绘制所有的图层。每个图层都是先单独绘制的。</p>
<p>在每个图层里面，浏览器会对元素的任何可见属性，如边框、背景色、阴影、文字等进行单独的像素填充。这个过程也被称为栅格化。为了提高性能，浏览器可以使用不同的线程来执行栅格化。</p>
<p>Photoshop 中图层的类比也可以应用到浏览器渲染网页的方式。您可以从 Chrome DevTools 中看到网页上的不同图层。打开 DevTools，从更多工具选项中选择 “Layers”。您还可以从 “Rendering” 面板中看到图层边框。</p>
<blockquote>
<p>栅格化通常是在 CPU 中完成的，这使得它的速度很慢，而且成本很高，但是我们现在有了新的技术，可以在 GPU 中进行性能提升。这篇 <a href="https://software.intel.com/en-us/articles/software-vs-gpu-rasterization-in-chromium">intel 文章</a> 详细介绍了绘画主题，这是一篇必读的文章。要想详细了解图层的概念，<a href="https://www.html5rocks.com/en/tutorials/speed/layers/">这是</a>一篇必读的文章。</p>
</blockquote>
<h3 id="合成操作"><a href="#合成操作" class="headerlink" title="合成操作"></a>合成操作</h3><p>到目前为止，我们还没有在屏幕上绘制一个像素。我们拥有的是不同的图层（位图图像），它们应该按照特定的顺序绘制在屏幕上。在合成操作中，这些图层会被发送到 GPU 上，最终将其绘制在屏幕上。</p>
<p>每次回流（布局）或重绘时都要将整个图层送去绘制，这显然是很低效的。因此，一个图层被分解成不同的块，然后将其绘制在屏幕上。你也可以在 Chrome 的 DevTool Rendering 面板中看到这些块。</p>
<p>从上面的信息中，我们可以从简单的 HTML 和 CSS 文本内容中，构建出一整个 浏览器从一个网页到在屏幕上渲染出事物所经历的事件顺序。<br><img src="https://i.loli.net/2021/04/19/3QBv7VMJEYdSgef.png" alt="1618750000712.png"></p>
<p>这个事件顺序也被称为 <strong><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path">关键渲染路径</a></strong></p>
<blockquote>
<p><a href="https://twitter.com/kosamari">Mariko Kosaka</a> 为这个流程写了一篇<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">漂亮的文章</a>，有酷炫的插图和对每个概念的更广泛的解释。强烈推荐。</p>
</blockquote>
<h3 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h3><p>创建 <code>DOM</code> 树、<code>CSSOM</code> 树和处理渲染逻辑的工作是由一个叫做浏览器引擎（也称为渲染引擎或布局引擎）的浏览器进程来完成的，它位于浏览器内部。这个浏览器引擎包含了，将一个网页从 HTML 代码，渲染到屏幕上的实际像素的，所有必要的元素和逻辑。</p>
<p>如果你听到人们谈论 WebKit，他们说的是一个浏览器引擎。WebKit 被苹果的 Safari 浏览器使用，也是谷歌 Chrome 浏览器的默认渲染引擎。截至目前， Chromium 项目使用 Blink 作为默认渲染引擎。<a href="https://stackoverflow.com/a/3468311/2790983">这里</a>是一些顶级网络浏览器使用的不同浏览器引擎的列表。</p>
<h2 id="浏览器的渲染流程"><a href="#浏览器的渲染流程" class="headerlink" title="浏览器的渲染流程"></a>浏览器的渲染流程</h2><p>我们都知道 <code>JavaScript</code> 语言是通过 <code>ECMAScript</code> 标准来实现标准化的，其实由于 <code>JavaScript</code> 被注册为商标，所以我们现在只叫它 <code>ECMAScript</code>。因此，每一个 <code>JavaScript</code> 引擎提供商，如 V8、Chakra、Spider Monkey 等都要遵守这个标准的规则。</p>
<p>有了标准，我们就可以在所有 JavaScript 运行时，如浏览器、Node、Deno 等，获得一致的 JavaScript 体验。这对于多平台的 JavaScript（和 Web）应用的一致和完美的开发是非常好的。</p>
<p>然而，浏览器的渲染方式却并非如此。HTML、CSS 或 JavaScript，这些语言都是由某个实体或某个组织标准化的。然而，浏览器如何将它们管理在一起，在屏幕上呈现东西，却不是标准化的。谷歌 Chrome 的浏览器引擎可能会与 Safari 的浏览器引擎做不同的事情。</p>
<p>因此，很难预测特定浏览器的渲染顺序及其背后的机制。然而，HTML5 规范已经做出了一些努力，在理论上标准化渲染应该如何工作，但浏览器如何遵守这一标准完全取决于它们。</p>
<p>尽管存在这些不一致的地方，但所有浏览器之间通常都有一些共同的原则。让我们来了解一下浏览器在屏幕上渲染事物的常见方法，以及这个过程的生命周期事件。</p>
<h3 id="解析和外部资源"><a href="#解析和外部资源" class="headerlink" title="解析和外部资源"></a>解析和外部资源</h3><p>解析是指读取 HTML 内容并从中构建 DOM 树的过程。因此，这个过程也被称为 DOM 解析，完成这个过程的程序被称为 DOM 解析器。</p>
<p>大多数浏览器都提供了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMParser">DOMParser</a> Web API 来从 HTML 代码中构建 DOM 树。 <code>DOMParser</code> 类的一个实例代表了一个 DOM 解析器，使用 <code>parseFromString</code> 原型方法，我们可以将原始的 HTML 文本（代码）解析成一棵 DOM 树（如下图所示）。<br><img src="https://ftp.bmp.ovh/imgs/2021/04/b22c5a336e8ce5c5.png" alt=""></p>
<p>当浏览器请求一个网页，服务器响应一些 HTML 文本（Content-Type 头设置为 text/html）时，浏览器可能会在整个文档的几个字符或几行字可用时就开始解析 HTML。因此，浏览器可以逐步建立 DOM 树，一次一个节点。浏览器从上到下解析 HTML，而不是中间的任何地方，因为 HTML 代表了一个嵌套的树状结构。</p>
<p><img src="https://ftp.bmp.ovh/imgs/2021/04/6536b577a670503c.gif" alt=""></p>
<p>在上面的例子中，我们从 Node 服务器访问了 <code>incremental.html</code> 文件，并将网络速度设置为只有 <strong>10kbps</strong>（从网络面板）。由于浏览器加载（下载）这个文件需要很长的时间（因为它包含 1000 个 h1 元素），所以浏览器从最初的几个字节构建了一个 DOM 树，并将它们打印在屏幕上（因为它在后台下载 HTML 文件的剩余内容）。</p>
<p><img src="https://ftp.bmp.ovh/imgs/2021/04/ff674951ed4cf697.png" alt=""></p>
<p>如果你看一下上面请求的性能图，你就能在 Timing 行看到一些事件。这些事件通常被称为 <strong>性能指标</strong>。当这些事件放在尽可能近的地方，并且尽可能早的发生，用户体验会更好。</p>
<p><code>FP</code> 是 <code>First Paint</code> 的缩写，意思是浏览器开始在屏幕上打印东西的时间（可以简单到正文背景色的第一个像素）。</p>
<p><code>FCP</code> 是 <code>First Contentful Paint</code> 的缩写，意思是浏览器渲染出文字或图片等内容的第一个像素的时间。<code>LCP</code> 是 <code>Largest Contentful Paint</code> 的缩写，是指浏览器渲染大块文字或图片的时间。</p>
<p><code>L</code> 代表 <code>onload</code> 事件，它是由浏览器在 <code>window</code> 对象上发出的。同样，<code>DCL</code> 代表 <code>DOMContentLoaded</code> 事件，它是在 <code>document</code> 对象上发出的，但会冒泡到 <code>window</code> 上，因此你也可以在 <code>window</code> 上监听它。这些事件理解起来有点复杂，所以我们稍后会讨论它们。</p>
<p>每当浏览器遇到一个外部资源，如通过 <code>&lt;script src=&quot;url&quot;&gt;&lt;/script&gt;</code> 元素的脚本文件（JavaScript）、通过 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;url&quot;/&gt;</code> 标签的样式表文件（CSS）、通过 <code>&lt;img src=&quot;url&quot; /&gt;</code> 元素的图像文件或任何其他外部资源，浏览器将在后台（JavaScript 执行的主线程之外）开始下载该文件。</p>
<p>最重要的一点是，DOM 解析通常发生在主线程上。因此，如果主 JavaScript 执行线程很忙，DOM 解析将无法进行，直到该线程空闲下来。你可能会问为什么这么重要？因为脚本元素是会阻塞解析器的。除了脚本(.js)文件请求外，每一个外部文件请求，如图片、样式表、pdf、视频等都不会阻塞 DOM 的构建(解析)。</p>
<h3 id="解析器阻塞型脚本-Parser-Blocking-Scripts"><a href="#解析器阻塞型脚本-Parser-Blocking-Scripts" class="headerlink" title="解析器阻塞型脚本(Parser-Blocking Scripts)"></a>解析器阻塞型脚本(Parser-Blocking Scripts)</h3><p>解析器阻塞型脚本是一个 <code>script</code>（JavaScript）文件/代码，它可以停止对 HTML 的解析。当浏览器遇到一个 <code>script</code> 元素时，如果它是一个嵌入式 <code>script</code>，那么它将首先执行该 <code>script</code>，然后继续解析 HTML，构建 DOM 树。所以所有的嵌入式 <code>script</code>都是解析器阻塞型的，讨论结束。</p>
<p>如果 <code>script</code> 元素是外部 <code>script</code> 文件，浏览器会在主线程之外开始下载外部 <code>script</code> 文件，但在该文件下载完毕之前，会停止主线程的执行。这意味着在 <code>script</code> 文件下载之前，不会再进行 DOM 解析。</p>
<p>一旦 <code>script</code> 文件下载完毕，浏览器将首先在主线程上执行下载好的 <code>script</code> 文件，然后继续进行 DOM 解析。如果浏览器再次发现 HTML 中的其他 <code>script</code> 元素，就会执行同样的操作。那么为什么浏览器要停止 DOM 解析，直到 JavaScript 被下载并执行？</p>
<p>浏览器将 DOM API 暴露给 JavaScript 运行时，这意味着我们可以从 JavaScript 中访问和操作 DOM 元素。这就是 React 和 Angular 等动态 Web 框架的工作方式。但如果浏览器希望并行运行 DOM 解析和 <code>script</code> 执行，那么 DOM 解析线程和主线程之间可能会出现<a href="https://stackoverflow.com/questions/34510/what-is-a-race-condition"><strong>竞赛条件</strong></a>，这就是为什么 DOM 解析必须在主线程上进行。</p>
<p>然而，在后台下载 <code>script</code> 文件时停止 DOM 解析，在大多数情况下是完全没有必要的。因此，HTML5 为我们提供了 <code>script</code> 标签的 <code>async</code> 属性。当 <code>DOM</code> 解析器遇到一个带有 <code>async</code> 属性的外部 <code>script</code> 元素时，它不会在后台下载 <code>script</code> 文件时停止解析过程。但是一旦文件下载完毕，解析过程就会停止，<code>script</code>（代码）就会被执行。</p>
<p>我们还为 <code>script</code> 元素设置了一个神奇的 <code>defer</code> 属性，它的工作原理与 <code>async</code> 属性类似，但与 <code>async</code> 属性不同的是，即使文件完全下载完毕，<code>script</code> 也不会执行。一旦解析器解析了所有的 HTML，也就是说 DOM 树已经完全构建完成，所有的 <code>defer</code> <code>script</code>就会被执行。与异步 <code>script</code> 不同的是，所有的延迟 <code>script</code> 是按照它们在 HTML 文档（或 DOM 树）中出现的顺序来执行的。</p>
<p>所有普通的 <code>script</code>（嵌入式或外部）都是解析器阻塞型的，因为它们停止了 DOM 的构建。所有异步 <code>script</code> 在下载之前不会阻塞解析器。一旦一个异步 <code>script</code> 被下载，它就变成了阻断解析器的 <code>script</code>。然而，所有的 <code>defer</code> 脚本都是非阻断解析器型的脚本，因为它们不阻断解析器，并且在 DOM 树完全构建完成后执行。<br><img src="https://ae01.alicdn.com/kf/U798f6fa385254155a4e7105fbc84894a9.jpg" alt=""></p>
<p>在上面的例子中，parser-blocking.html 文件在 30 个元素后包含了一个阻塞解析的脚本，这就是为什么浏览器一开始显示 30 个元素，停止 DOM 解析，并开始加载脚本文件的原因。第二个脚本文件由于有 defer 属性，所以不会阻止解析，所以一旦 DOM 树完全构建完成，它就会执行。<br><img src="https://ae01.alicdn.com/kf/Uc714a2f94cfa4ff49431509a91bcab5aY.jpg" alt=""></p>
<p>如果我们看一下 <strong>Performance</strong> 面板，<code>FP</code> 和 <code>FCP</code> 会尽快发生（隐藏在 <strong>Timings</strong> 标签后面），因为浏览器一有 HTML 内容就开始建立 DOM 树，因此可以在屏幕上渲染一些像素。</p>
<p><code>LCP</code> 发生在 5 秒后，因为阻塞解析器的脚本已经阻断了 5 秒的 DOM 解析（它的下载时间），当 DOM 解析器被阻断时，屏幕上只呈现了 30 个文本元素，这不足以被称为最大的内容绘制（根据 Google Chrome 标准）。但是一旦下载并执行该脚本，DOM 解析就恢复了，并且在屏幕上呈现了大量的内容，这导致了 LCP 事件的触发。</p>
<blockquote>
<p>Parser-blocking 也被称为 render-blocking，因为除非 DOM 树被构造出来，否则渲染是不会发生的，但这两者是完全不同的事情，我们稍后会看到</p>
</blockquote>
<p>一些浏览器可能会包含一个<a href="https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing">推测性解析</a>策略，即 HTML 解析（但不包括 DOM 树的构建）被挂载到一个单独的线程中，这样浏览器就可以读取链接（CSS）、script、img 等元素，并更早地下载这些资源。</p>
<p>这对于以下这种情况来说是很有用的，比如你有三个紧贴的 <code>script</code> 元素，但由于 DOM 解析器无法读取第二个 <code>script</code> 元素，所以在第一个 <code>script</code> 下载完毕之前，浏览器无法开始下载第二个 <code>script</code>。我们可以通过使用 <code>async</code> 标签轻松解决这个问题，但是异步脚本不能保证按顺序执行。</p>
<p>之所以叫推测性解析，是因为浏览器在做一个推测，预计未来会加载某个资源，所以最好现在就在后台加载。但是，如果某些 JavaScript 操作 DOM，或用外部资源删除/隐藏元素，那么推测就失败了，这些文件就白白加载了。</p>
<blockquote>
<p>每个浏览器都有自己的规范，所以不能保证何时或是否会发生推测性解析。不过，你可以使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 元素要求浏览器提前加载一些资源。</p>
</blockquote>
<h3 id="渲染阻塞型-CSS"><a href="#渲染阻塞型-CSS" class="headerlink" title="渲染阻塞型 CSS"></a>渲染阻塞型 CSS</h3><p>正如我们所了解到的，除了阻塞解析器的 <code>script</code> 文件外，任何外部资源请求都不会阻塞 DOM 解析过程。因此，CSS（包括嵌入式）不会直接阻塞 DOM 解析器。等等，是的，CSS 可以阻止 DOM 解析，但在此之前，我们需要了解渲染过程。</p>
<p>浏览器内部的浏览器引擎使用从服务器接收到的 HTML 内容作为文本文档来构建 DOM 树。同样，它也会根据外部 CSS 文件或 HTML 中嵌入（以及内联）的 CSS 样式表内容来构建 CSSOM 树。</p>
<p>DOM 和 CSSOM 树的构建都发生在主线程上，而且这些树的构建是<strong>同时</strong>进行的。它们共同构成了用于在屏幕上打印东西的 Render Tree，而 Render Tree 也随着 DOM 树的构建而逐步构建。</p>
<p>我们已经了解到，DOM 树的生成是增量的，这意味着当浏览器读取 HTML 时，它会将 DOM 元素添加到 DOM 树中。但 CSSOM 树却不是这样。与 DOM 树不同，CSSOM 树的构建不是递增的，必须以特定的方式进行。</p>
<p>当浏览器找到 <code>&lt;style&gt;</code> 块时，它会解析所有嵌入的 CSS，并以新的 CSS （样式）规则更新 CSSOM 树。之后，它将继续以正常方式解析 HTML。内联样式也是如此。</p>
<p>然而，当浏览器遇到一个外部样式表文件时，事情就会发生巨大的变化。与外部 <code>script</code> 文件不同的是，外部样式表文件不是解析器阻塞型的资源，因此浏览器可以在后台静默地下载它，DOM 解析也会继续进行。</p>
<p>但与 HTML 文件（用于 DOM 构建）不同，浏览器不会一个字节一个字节地处理样式表文件内容。这是因为浏览器在读取 CSS 内容时，不能增量地构建 CSSOM 树。原因是，文件最后的 CSS 规则可能会覆盖写在文件顶部的 CSS 规则。</p>
<p>因此，如果浏览器在解析样式表内容时开始递增地构建 CSSOM，就会导致渲染树的多次渲染，因为样式覆盖规则会使同样的 CSSOM 节点，因后面新出现的样式表文件而导致更新。当 CSS 被解析时，可以在屏幕上看到元素样式的改变，这将是一种不愉快的用户体验。由于 CSS 样式是层叠的，一个规则的改变可能会影响许多元素。</p>
<p>因此，浏览器不会逐步处理外部 CSS 文件，CSSOM 树更新是在样式表中所有 CSS 规则处理完毕后一次性完成的。CSSOM 树更新完成后，再更新渲染树，然后渲染到屏幕上。</p>
<p>CSS 是一种渲染阻塞型资源。一旦浏览器提出获取外部样式表的请求，Render Tree 的构建就会停止。因此，<strong>关键渲染路径</strong>（CRP）也被卡住了，没有任何东西被渲染到屏幕上，如下图所示。然而，在后台下载样式表时，DOM 树的构建仍在进行中。</p>
<p><img src="https://ae01.alicdn.com/kf/Uf2fb7434f9144281885b7b7b71cf9fe2P.jpg" alt=""></p>
<p>浏览器可以使用 CSSOM 树的旧状态来生成 Render Tree，因为 HTML 正在被解析，以递增的方式在屏幕上呈现事物。但这有一个巨大的缺点。在这种情况下，一旦样式表被下载和解析，CSSOM 被更新，Render Tree 就会被更新并呈现在屏幕上。现在，用旧 CSSOM 生成的 Render Tree 节点将重绘新的样式，这也可能导致 Flash of Unstyled Content (FOUC)，这对用户体验非常不利。</p>
<p>因此，浏览器会等到样式表被加载和解析。一旦样式表被解析，CSSOM 被更新，Render Tree 就会被更新，CRP 就会继续进行，从而使 Render Tree 绘制在屏幕上。由于这个原因，建议尽早加载所有外部样式表。</p>
<p>让我们想象一下这样一个场景：浏览器已经开始解析 HTML，并且遇到了一个外部样式表文件。它将在后台开始下载文件，阻塞 CRP，并继续进行 DOM 解析。但是它又遇到了一个 <code>script</code> 标签，于是它就会在后台开始下载外部脚本文件，并阻止 DOM 解析。现在浏览器是坐等样式表和脚本文件完全下载完毕。</p>
<p>但这次外部脚本文件已经完全下载完毕，而样式表还在后台下载。浏览器要不要执行这个脚本文件？这样做有什么危害吗？</p>
<p>我们知道，CSSOM 提供了一个高级的 JavaScript API 来与 DOM 元素的样式进行交互。例如，你可以使用 <code>elem.style.backgroundColor</code> 属性来读取或更新一个 DOM 元素的背景颜色。与 <code>elem</code> 元素相关联的样式对象暴露了 CSSOM 的 API，还有很多其他的 API 可以做同样的事情（请阅读这篇 <a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/">css-tricks</a> 文章）。</p>
<p>当一个样式表被后台下载时，JavaScript 仍然可以执行，因为主线程没有被加载的样式表所阻挡。如果我们的 JavaScript 程序访问 DOM 元素的 CSS 属性（通过 CSSOM API），我们会得到一个合适的值（根据 CSSOM 的当前状态）。</p>
<p>但是一旦样式表被下载和解析，导致 CSSOM 更新，我们的 JavaScript 现在有一个过时的元素的 CSS 值，因为新的 CSSOM 更新可能已经改变了该 DOM 元素的 CSS 属性。由于这个原因，在下载样式表的时候执行 JavaScript 是不安全的。</p>
<p>根据 <a href="https://html.spec.whatwg.org/multipage/semantics.html#interactions-of-styling-and-scripting">HTML5 规范</a>，浏览器可以下载一个脚本文件，但不会执行它，除非之前所有的样式表都被解析了。当一个样式表阻止脚本的执行时，它被称为脚本阻塞型样式表(script-blocking stylesheet)或脚本阻塞型 CSS(script-blocking CSS)。</p>
<p><img src="https://ae01.alicdn.com/kf/U327ac1fe038246be86df228eb65080e5r.jpg" alt=""></p>
<p>在上面的例子中，script-blocking.html 包含了一个<code>link</code> 标签（用于外部的样式表），后面是一个 <code>script</code> 标签（用于外部 JavaScript）。这里的 <code>script</code> 下载速度非常快，没有任何延迟，但样式表需要 6 秒才能下载完。因此，尽管我们可以从网络面板上看到，脚本已经完全下载，但浏览器并没有立即执行。只有在样式表加载后，我们看到脚本打印的 <code>Hello World</code> 消息。</p>
<blockquote>
<p>就像 <code>async</code> 或 <code>defer</code> 属性使 <code>script</code> 元素<strong>不阻塞解析</strong>一样，外部的样式表也可以通过 <code>media</code> 属性使其<strong>不阻塞渲染</strong>。使用 <code>media</code> 属性值，浏览器可以智能地决定何时去加载样式表</p>
</blockquote>
<h3 id="文档的-DOMContentLoader-事件"><a href="#文档的-DOMContentLoader-事件" class="headerlink" title="文档的 DOMContentLoader 事件"></a>文档的 DOMContentLoader 事件</h3><p><code>DOMContentLoaded</code>(DCL)事件标志着，浏览器从所有可用的 HTML 中，构建出了一个完整的DOM树的时间点。但 DCL 事件被触发时，有很多涉及到的因素会发生变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"DOM is fully parsed!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>如果我们的 HTML 中不包含任何脚本，DOM 解析就不会被阻塞，DCL 就会随着浏览器解析完整个 HTML 而触发。如果我们有解析器阻塞型脚本，那么 DCL 必须等待所有解析器阻塞型脚本被下载并执行。</p>
<p>当样式表被扔进页面时，事情就变得有点复杂了。即使你没有外部脚本，DCL 也会等到所有样式表被加载。因 DCL 标志着整个 DOM 树已经准备好的时间点，但是在 CSSOM 也被完全构建之前，访问 DOM 都是不太安全的（对于样式信息）。因此，大多数浏览器都会等到所有外部样式表被加载和解析。</p>
<p>脚本阻塞型样式表显然会延迟 DCL。在这种情况下，由于脚本在等待样式表的加载，DOM 树没有被构造出来。</p>
<p>DCL 是网站性能指标之一。我们应该优化 DCL，使其尽可能的小（发生的时间）。其中一个最好的做法是尽可能地使用 <code>defer</code> 和 <code>async</code> 标签来处理 <code>script</code> 元素，这样当脚本在后台下载时，浏览器可以执行其他事情。其次，我们应该优化脚本阻塞型和渲染阻塞型的样式表。</p>
<h3 id="窗口的-load-事件"><a href="#窗口的-load-事件" class="headerlink" title="窗口的 load 事件"></a>窗口的 <code>load</code> 事件</h3><p>我们知道 JavaScript 可以阻止 DOM 树的生成，但是对于外部的样式表和文件，如图片、视频等就不是这样了。</p>
<p><code>DOMContentLoaded</code> 事件标志着 DOM 树已经完全构造完成，可以安全访问，<code>window.onload</code> 事件标志着外部样式表和文件下载完毕，我们的Web应用已经完成下载的时间点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener( <span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'Page is fully loaded!'</span> );</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/19/Jw4bepLi73yxYqP.png" alt="1618839528167.png"></p>
<p>在上面的例子中，rendering.html 文件的头部有一个外部样式表，下载时间大约为5秒。由于它在头部部分，<code>FP</code> 和 <code>FCP</code> 发生在5秒之后，因为样式表会阻止它下面的任何内容的渲染（也就是它阻止了CRP）。</p>
<p>在这之后，我们有一个 <code>img</code> 元素，加载一个需要10秒左右下载的图片。所以浏览器会在后台一直下载这个文件，然后继续进行 DOM 的解析和渲染（因为外部图片资源既不阻挡解析器，也不阻挡渲染）。</p>
<p>接下来，我们有三个外部 JavaScript 文件，它们的下载时间分别为 3s、6s 和 9s，最重要的是，它们不是异步的。这意味着总的加载时间应该接近 18秒，因为在前一个脚本执行之前，后续的脚本不会开始下载。然而，从 DCL 事件来看，我们的浏览器似乎采用了推测性策略，预先下载脚本文件，所以总加载时间接近 9秒。</p>
<p>由于能够影响 DCL 的最后一个下载的文件是最后一个脚本文件，加载时间为9秒（因为样式表已经在 5 秒内下载完毕），所以DCL事件发生在 9.1 秒左右。</p>
<p>我们还有一个外部资源是图片文件，它一直在后台加载。当它完全下载完毕后（需要 10 秒），窗口的 <code>load</code> 事件在10.2秒后被启动，这标志着网页（应用程序）已经完全加载完毕。</p>
</div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://kerbalhao.github.io/posts/65f9e7b2/">浏览器是如何渲染网页的？——DOM,CSSOM以及渲染</a></li><li><strong>本文作者：</strong><a href="https://kerbalhao.github.io">KerbalHao</a></li><li><strong>本文链接：</strong><a href="https://kerbalhao.github.io/posts/65f9e7b2/">https://kerbalhao.github.io/posts/65f9e7b2/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/posts/66c0dcbe/" target="_blank">JS 12个重要概念以及reduce方法详解</a><br></span><span>  2.<a class="is-size-6" href="/posts/70af37a7/" target="_blank">React 思维导图</a><br></span><span>  3.<a class="is-size-6" href="/posts/f79b72d/" target="_blank">Lua学习</a><br></span><span>  4.<a class="is-size-6" href="/posts/f4f838c8/" target="_blank">个人 dota2 项目</a><br></span><span>  5.<a class="is-size-6" href="/posts/b8c7ab12/" target="_blank">基于HTTP网络层的前端性能优化</a><br></span><span>  6.<a class="is-size-6" href="/posts/3424aad5/" target="_blank">手写 promise</a><br></span></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/b6a5ef32/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JS类型检测</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/b8c7ab12/"><span class="level-item">基于HTTP网络层的前端性能优化</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css"><script> $.getScript('https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            id: '9c656cf9ea3f8ab550bb39995180b147',
            repo: 'blog_comment',
            owner: 'kerbalhao',
            clientID: 'a71d38c4a8dafab99dc9',
            clientSecret: '2ac14858f30545b5beea2e920b90d25dcbf1c78b',
            admin: ["kerbalhao"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-前言" href="#前言"><span>前言</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-Document-Object-Model-DOM" href="#Document-Object-Model-DOM"><span>Document Object Model (DOM)</span></a></li><li><a class="is-flex toc-item" id="toc-item-CSS-Object-Model-CSSOM" href="#CSS-Object-Model-CSSOM"><span>CSS Object Model (CSSOM)</span></a></li><li><a class="is-flex toc-item" id="toc-item-Render-Tree" href="#Render-Tree"><span>Render Tree</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-渲染顺序" href="#渲染顺序"><span>渲染顺序</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-布局操作" href="#布局操作"><span>布局操作</span></a></li><li><a class="is-flex toc-item" id="toc-item-绘制操作" href="#绘制操作"><span>绘制操作</span></a></li><li><a class="is-flex toc-item" id="toc-item-合成操作" href="#合成操作"><span>合成操作</span></a></li><li><a class="is-flex toc-item" id="toc-item-浏览器引擎" href="#浏览器引擎"><span>浏览器引擎</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-浏览器的渲染流程" href="#浏览器的渲染流程"><span>浏览器的渲染流程</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-解析和外部资源" href="#解析和外部资源"><span>解析和外部资源</span></a></li><li><a class="is-flex toc-item" id="toc-item-解析器阻塞型脚本-Parser-Blocking-Scripts" href="#解析器阻塞型脚本-Parser-Blocking-Scripts"><span>解析器阻塞型脚本(Parser-Blocking Scripts)</span></a></li><li><a class="is-flex toc-item" id="toc-item-渲染阻塞型-CSS" href="#渲染阻塞型-CSS"><span>渲染阻塞型 CSS</span></a></li><li><a class="is-flex toc-item" id="toc-item-文档的-DOMContentLoader-事件" href="#文档的-DOMContentLoader-事件"><span>文档的 DOMContentLoader 事件</span></a></li><li><a class="is-flex toc-item" id="toc-item-窗口的-load-事件" href="#窗口的-load-事件"><span>窗口的 load 事件</span></a></li></ul></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://cdn.jsdelivr.net/gh/kerbalhao/blog_images/avatar.jpg" alt="KerbalHao"></figure><p class="title is-size-4 is-block line-height-inherit">KerbalHao</p><p class="is-size-6 is-block">不咕了，从今天开始种树</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>广州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">58</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">44</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/kerbalhao"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:kerbalhao@foxmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/ES6/"><span class="level-start"><span class="level-item">ES6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ES6-JS/"><span class="level-start"><span class="level-item">ES6 JS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ES6-JS-Morden-JavaScript-Tutorial/"><span class="level-start"><span class="level-item">ES6, JS, Morden JavaScript Tutorial</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/HTTP/"><span class="level-start"><span class="level-item">HTTP</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JS%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9/"><span class="level-start"><span class="level-item">JS语言精粹</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">JS高级程序设计</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/MDN/"><span class="level-start"><span class="level-item">MDN</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Morden-JavaScript-Tutorial/"><span class="level-start"><span class="level-item">Morden JavaScript Tutorial</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/React/"><span class="level-start"><span class="level-item">React</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/browser/"><span class="level-start"><span class="level-item">browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML5/"><span class="tag">HTML5</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"><span class="tag">JS 引用类型</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bootstrap/"><span class="tag">Bootstrap</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS-HTML5/"><span class="tag">CSS HTML5</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS-MDN/"><span class="tag">CSS MDN</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS-flex-grid/"><span class="tag">CSS flex grid</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES6-JS-%E5%9D%97%E7%BA%A7/"><span class="tag">ES6 JS 块级</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES6-Set-Map-JS/"><span class="tag">ES6 Set Map JS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES6-Symbol-JS/"><span class="tag">ES6 Symbol JS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES6-%E5%87%BD%E6%95%B0-JS/"><span class="tag">ES6 函数 JS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES6-%E5%AF%B9%E8%B1%A1-JS/"><span class="tag">ES6 对象 JS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES6-%E8%A7%A3%E6%9E%84-JS/"><span class="tag">ES6 解构 JS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8-JS/"><span class="tag">ES6 迭代器与生成器 JS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8-JS-MJT/"><span class="tag">ES6 迭代器与生成器 JS MJT</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML-MDN/"><span class="tag">HTML MDN</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTTP/"><span class="tag">HTTP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Head-First-CSS-HTML/"><span class="tag">Head-First CSS HTML</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JQ-js/"><span class="tag">JQ js</span><span class="tag is-grey-lightest">1</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/kerbalhao/blog_images/log.jpg" alt="kerbalHao" height="28"></a><p class="size-small"><span>&copy; 2022 KerbalHao</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br>    方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br></span><div class="size-small"><span id="busuanzi_container_site_uv">❤️感谢<strong> <span id="busuanzi_value_site_uv">99+</span> </strong></span>小伙伴的<strong> <span id="busuanzi_value_site_pv">99+</span> </strong>次光临！❤️</div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/kerbalhao"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://kerbalhao.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/js/animation.min.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/js/back-to-top.min.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.12/dist/js/lightgallery-all.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/js/toc.min.js" defer></script><script src="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/js/main.min.js" defer></script><script src="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/js/comment-issue-data.min.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/css/insight.min.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: 'https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="https://cdn.jsdelivr.net/gh/kerbalhao/kerbalhao.github.io/js/insight.min.js" defer></script></body></html>