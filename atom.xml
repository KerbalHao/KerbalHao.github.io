<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kerbalHao</title>
  
  <subtitle>Fresh Vegetable</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kerbalhao.github.io/"/>
  <updated>2022-07-05T02:17:14.322Z</updated>
  <id>https://kerbalhao.github.io/</id>
  
  <author>
    <name>KerbalHao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类型检查</title>
    <link href="https://kerbalhao.github.io/2022/04/06/JS%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"/>
    <id>https://kerbalhao.github.io/2022/04/06/JS%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/</id>
    <published>2022-04-06T09:50:08.135Z</published>
    <updated>2022-07-05T02:17:14.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h1><p>JS 中有多个可以检测数据类型的方法，比如：</p><ul><li>typeof</li><li>instanceof</li><li>constructor</li><li>Object.prototype.toString.call(instance)</li></ul><p>但是它们基本都有一些不足，接下来就让我来一一说明一下</p><span id="more"></span><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>我们经常使用 typeof 判断数据的类型，其性能很高，但是它有两个致命的缺陷：</p><ol><li><code>typeof null === &#39;object&#39; // =&gt; true</code><ol><li>对 <code>null</code> 使用 <code>typeof</code> 会返回 <code>object</code></li><li>这是因为 <code>typeof</code> 是浏览器底层基于二进制对值进行判断，对象类型是用 000 开头的二进制储存的，而 <code>null</code> 的二进制值是全为 0，因此它会被 <code>typeof</code> 判断为 <code>object</code></li></ol></li><li>对除了 <code>Function</code> 以外的原生对象类型使用 <code>typeof</code>，其都只返回一个 <code>object</code></li></ol><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>a instanceof b</code> 可以被认为判断在 a 的原型链上是否存在 b 的原型对象，可以简单的认为判断 a 是否为 b 的实例对象。<br>话虽如此，但是因为在 JS 中，我们可以随意改变原型的指向，因此此方法并不一定准确，比如</p><pre><code class="javascript">let fn = function () &#123;&#125;;fn.prototype = Array.prototype;let f = new fn();console.log(f instanceof Array); // =&gt; true</code></pre><p>此外， instanceof 无法判断基本类型在上述代码中，fn 是一个函数，但是我们通过将其的原型对象指定为 Array 的原型对象，导致 Array 的原型对象出现在 fn 的实例的原型链上，因此返回了 true。</p><p>在我们知道了 instanceof 的原理之后，我们可以自己实现一个 instanceof</p><pre><code class="javascript">function myInstanceof(instance, classFunc) &#123;  let classFuncProto = classFunc.prototype; // 获取父类的原型  let proto = Object.getPrototype(proto); // 获取实例的原型  // 递归获取实例原型链上的原型  while (true) &#123;    // 当实例原型链原型走到了 Object.prototype 即 null 时，    // 表示整个原型链都不存在父类原型    if (proto === null) return false;    if (proto === classFuncProto) return true;    proto = Object.getPrototype(proto);  &#125;&#125;</code></pre><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>正如我们所知，一个实例的 constructor 等于其构造函数的 constructor，因此我们可以根据这个原理来判断对象的数据类型。constructor</p><p>但是，它也和 instanceof 一样，JavaScript 自身并不能确保正确的 <code>constructor</code> 函数值。它只存在于函数的默认 <code>prototype</code> 中，可以被随时改变</p><pre><code class="javascript">let fn = function () &#123;&#125;;let f = new fn();f.constructor === fn; // =&gt; true// 修改 fn 的构造函数指向fn.prototype.constructor = Array;f.constructor === fn; // =&gt; falsef.constructor === Array; // =&gt; true</code></pre><h2 id="Object-prototype-toString-call-instance"><a href="#Object-prototype-toString-call-instance" class="headerlink" title="Object.prototype.toString.call(instance)"></a>Object.prototype.toString.call(instance)</h2><p>其返回的值可能是: [object Number/String/Boolean/Null/Undefined/Symbol/Object/Array/RegExp/Date/Function]<br>这个方法可以说是究极方法了，这个方法用的是原型链最顶端的 toString 方法，通过调用 call 将 this 绑定到要检测的对象身上，会返回一个字符串”[object Type ]”，Type 是判断出来的类型。</p><p>该方法的缺点在于代码太长，如果判断基本类型的话，我们也可以直接使用 typeof 来检测，因此我们可以考虑优化一下：</p><pre><code class="javascript">var class2type = &#123;&#125;ve toString = class2type.toString// 设置映射表[&#39;Boolean&#39;,&#39;Number&#39;,&#39;String&#39;,&#39;Function&#39;,&#39;Array&#39;,&#39;Date&#39;,&#39;RegExp&#39;,&#39;Object&#39;,&#39;Error&#39;,&#39;Symbol&#39;].forEach(name =&gt; &#123;  class2type[`[object $&#123;name&#125;]`] =name.toLowerCase()&#125;)function toType(obj) &#123;  if (obj == null) &#123;    return obj + &#39;&#39;  &#125;  return (typeof obj === &#39;object&#39; || typeof obj === &#39;function&#39;) ? class2type[toString.call(obj)] : typeof obj&#125;</code></pre><table><thead><tr><th></th><th></th></tr></thead></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类型检测&quot;&gt;&lt;a href=&quot;#类型检测&quot; class=&quot;headerlink&quot; title=&quot;类型检测&quot;&gt;&lt;/a&gt;类型检测&lt;/h1&gt;&lt;p&gt;JS 中有多个可以检测数据类型的方法，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;typeof&lt;/li&gt;
&lt;li&gt;instanceof&lt;/li&gt;
&lt;li&gt;constructor&lt;/li&gt;
&lt;li&gt;Object.prototype.toString.call(instance)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是它们基本都有一些不足，接下来就让我来一一说明一下&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Koa-Compose 源码解析</title>
    <link href="https://kerbalhao.github.io/2022/03/21/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-koa-compose%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://kerbalhao.github.io/2022/03/21/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-koa-compose%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-03-21T10:36:09.000Z</published>
    <updated>2022-07-05T02:12:53.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Koa-compose-源码解析"><a href="#Koa-compose-源码解析" class="headerlink" title="Koa-compose 源码解析"></a>Koa-compose 源码解析</h1><p><strong>Koa-compose 是将中间件串联起来执行的核心内容</strong></p><pre><code class="javascript">// 本函数接受一个函数数组，可以使该数组内的函数串联执行function compose(middlewares) &#123;  // 参数校验：参数必须为函数数组  if (!Array.isArray(middleware))    throw new Error(&#39;Middleware stack must be an array!&#39;);  for (const fn of middleware) &#123;    if (typeof fn !== &#39;function&#39;)      throw new Error(&#39;Middleware must be composed of functions!&#39;);  &#125;  // 返回一个返回 Promise 的函数  // 一开始执行设置一个 锚点 index 用来判断同一个中间件是否被调用多次  // 执行 dispatch(0)，0 表示中间件数组的第一个元素  return function (context, lastFn) &#123;    let index = -1;    return dispatch(0);    function dispatch(i) &#123;      if (i &lt;= index)        return Promise.reject(new Error(&#39;无法多次调用同一个中间件的 next()&#39;));      // 改变锚点      index = i;      // 将当前要执行的中间件赋值给 fn      let fn = middlewares[i];      // 当当前要执行的中间件是最后一个时，将 lastFn 赋值 fn，表示可以执行其他指定的函数      if (middlewares.length === i) fn = lastFn;      // 若无 lastFn，则直接 resolve 一个空值      if (!lastFn) return Promise.resolve();      try &#123;        // 将获取的 context 和 下一个 dispatch 的函数传递给中间件，执行中间件        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));      &#125; catch (err) &#123;        return Promise.reject(err);      &#125;    &#125;  &#125;;&#125;</code></pre><h2 id="让我们以测试用例来说明"><a href="#让我们以测试用例来说明" class="headerlink" title="让我们以测试用例来说明"></a>让我们以测试用例来说明</h2><p>当 <code>stack</code> 传入三个函数后，执行 compose(<code>stack</code>) 返回的函数</p><ul><li>按顺序执行，执行到 <code>2</code> 时，形参 <code>next</code> 实际就是 <code>dispatch.bind(null, 1)</code>，当执行 <code>next()</code> 时，就会执行第二个 middleware 因此跳转到 <code>3</code>处</li><li>到 <code>4</code> 时，形参 <code>next</code> 是 <code>dispatch.bind(null, 2)</code>，执行 <code>next()</code>，执行第三个 middleware ，跳转到 <code>5</code>处</li><li><code>5</code> 之后的 <code>next()</code> 表示的是 <code>dispatch.bind(null, 3)()</code>，根据 <code>dispatch</code>函数，我们知道此处会直接 <code>resolve</code>一个空值出来，从而可以继续执行 <code>6</code></li><li><strong>因为之后没有在调用 <code>next()</code>，所以之后的内容都可以按顺序执行完成</strong></li></ul><pre><code class="javascript">it(&#39;should work&#39;, async () =&gt; &#123;    const arr = []    const stack = []    stack.push(async (context, next) =&gt; &#123;      arr.push(1) // *1      await wait(1)      await next() // *2      await wait(1) // *8      arr.push(6)    &#125;)    stack.push(async (context, next) =&gt; &#123;      arr.push(2) //*3      await wait(1)      await next() // *4      await wait(1) // *7      arr.push(5)    &#125;)    stack.push(async (context, next) =&gt; &#123;      arr.push(3) // *5      await wait(1)      await next()      await wait(1) // *6      arr.push(4)    &#125;)    await compose(stack)(&#123;&#125;)    expect(arr).toEqual(expect.arrayContaining([1, 2, 3, 4, 5, 6]))&#125;)</code></pre><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><strong>这就是洋葱模型，我们可以先执行一个函数的一部分内容，而后执行另一个函数的一部分内容，再执行另一个函数的一部分内容，当没有其他函数的内容需要执行的时候，我们可以再从后往前把剩余的函数内容执行完。</strong><br>就像一把刀切洋葱的时候，洋葱一边的表皮最先破开，慢慢深入到内核，而后再从内往外破开</p><p><strong>compose 的难点和迷惑点在于：</strong></p><ul><li><strong>锚点与边界条件的判断</strong></li><li><strong>对中间件的调用</strong></li><li><strong>对于 dispatch 的递归调用</strong></li><li><strong>边界条件的处理</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Koa-compose-源码解析&quot;&gt;&lt;a href=&quot;#Koa-compose-源码解析&quot; class=&quot;headerlink&quot; title=&quot;Koa-compose 源码解析&quot;&gt;&lt;/a&gt;Koa-compose 源码解析&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Koa-co
      
    
    </summary>
    
    
    
      <category term="js源码解析" scheme="https://kerbalhao.github.io/tags/js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Devtool 中 Open-in-Editor 源码阅读</title>
    <link href="https://kerbalhao.github.io/2022/02/16/vue-devtool%20%E4%B8%AD%20open-in-editor%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://kerbalhao.github.io/2022/02/16/vue-devtool%20%E4%B8%AD%20open-in-editor%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2022-02-16T10:36:09.000Z</published>
    <updated>2022-07-05T02:25:54.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-devtool-中-open-in-editor-源码阅读"><a href="#vue-devtool-中-open-in-editor-源码阅读" class="headerlink" title="vue-devtool 中 open-in-editor 源码阅读"></a>vue-devtool 中 open-in-editor 源码阅读</h1><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>首先要先感谢川哥，感谢他创办的这个活动。<br>其实我一早就有读源码的想法，但是每每一看到源码那么多就打了退堂鼓（国家一级退堂鼓表演艺术家 XD），多谢川哥拆分了 vue-devtool 这个工具的 open-in-editor 部分，让我能够坚持把源码读下去，才发现原来读源码也不那么难。</p><h2 id="开始读源码"><a href="#开始读源码" class="headerlink" title="开始读源码"></a>开始读源码</h2><h3 id="app-use"><a href="#app-use" class="headerlink" title="app.use"></a>app.use</h3><p>我在一开始的 <code>app.use</code> 的时候就打了一个断点，当我们开始调试的时候，就会发现当 devServer 初始化的时候，我们就在其 <code>before</code> 钩子函数内调用了 <code>app.use()</code> 来添加对 <code>&#39;/__open-in-editor&#39;</code> 的监听，当监听到请求带有该字段的时候，就会调用我们的 <code>launchEditorMiddleware</code> 来打开对应的 vue 文件</p><pre><code class="js">app.use(&#39;/__open-in-editor&#39;, launchEditorMiddleware(() =&gt; console.log(  `To specify an editor, specify the EDITOR env variable or ` +  `add &quot;editor&quot; field to your Vue project config.\n`)))</code></pre><p>本人对 webpack 了解不多，也顺便学习了一下 <code>app.use</code> 的源码，主要是学到了对于参数的判断处理，声明的时候只接收一个参数 <code>fn</code>，但是基于对参数类型的判断，筛选出真正需要的函数参数。</p><p>个人认为，这样做的好处是，在只需要传递一个函数参数的时候，不需要像 <code>app.use(undefined,fn)</code> 这样传递参数。</p><pre><code class="js">// 它函数声明的时候只接收一个参数 fnapp.use = function use(fn) &#123;  var offset = 0; // 记录真正的函数的偏移量  var path = &#39;/&#39;;  // default path to &#39;/&#39;  // disambiguate app.use([fn])  // 当 `typeof fn !== &#39;function&#39;` 时，会将其赋值给临时变量 arg，判断 arg  if (typeof fn !== &#39;function&#39;) &#123;    var arg = fn;    // 当传入的第一个参数时 数组，且不为空时，将数组第一项赋值给 arg，直到其不为数组或为空    while (Array.isArray(arg) &amp;&amp; arg.length !== 0) &#123;      arg = arg[0];    &#125;    // first arg is the path    // 当 arg 也不是函数时，将其赋值给 path 作为路径    if (typeof arg !== &#39;function&#39;) &#123;      offset = 1;      path = fn;    &#125;  &#125;  // 从传递的 arguments 中，根据偏移量解析出可能的所有函数  // flatten 用于数组拍平  var fns = flatten(slice.call(arguments, offset));  if (fns.length === 0) &#123;    throw new TypeError(&#39;app.use() requires a middleware function&#39;)  &#125;  // setup router  // 路由懒加载  this.lazyrouter();  var router = this._router;  // 遍历解析出来的函数  fns.forEach(function (fn) &#123;    // 对于     if (!fn || !fn.handle || !fn.set) &#123;      // 在路由插入中间件, 鉴于能力不够，暂时未深入了解      return router.use(path, fn);    &#125;    // 下面是对于 express 框架相关的处理，此处暂时不理    // ...  &#125;, this);  return this;&#125;;</code></pre><p>回到正题，<code>app.use</code> 的第二个参数时 <code>launchEditorMiddleware</code> 调用的结构，我们来看看 <code>launchEditorMiddleware</code></p><h3 id="launchEditorMiddleware"><a href="#launchEditorMiddleware" class="headerlink" title="launchEditorMiddleware"></a>launchEditorMiddleware</h3><p>// 就像我们之前看的 <code>app.use</code> 一样，这里的参数也是做了处理，若接收到的参数为函数，则赋值给 <code>onErrorCallback</code>，并将原来的变量赋值为 <code>undefined</code></p><pre><code class="js">// 好处？可以直接传入一个函数参数，而不需要对其他参数传 undefined ？module.exports = (specifiedEditor, srcRoot, onErrorCallback) =&gt; &#123;  if (typeof specifiedEditor === &#39;function&#39;) &#123;    onErrorCallback = specifiedEditor    specifiedEditor = undefined  &#125;  if (typeof srcRoot === &#39;function&#39;) &#123;    onErrorCallback = srcRoot    srcRoot = undefined  &#125;  // 获取文件所在的根路径  srcRoot = srcRoot || process.cwd()  // 返回一个函数，真正的打开文件的核心操作就在这里了  return function launchEditorMiddleware (req, res, next) &#123;    // 这里先暂时按下不表  &#125;&#125;</code></pre><p>到现在为止，我们在启动服务的时候 <code>open-in-editor</code> 的相关代码已经走了一遍了，接下来，我们来看看事件触发时的代码是如何执行的</p><h3 id="launchEditorMiddleware-1"><a href="#launchEditorMiddleware-1" class="headerlink" title="launchEditorMiddleware"></a>launchEditorMiddleware</h3><pre><code class="js">// 接上文，当我们点击打开文件的时候，就会执行这一段代码// 为什么呢？因为 app.use 传递了一个 &#39;/__open-in-editor&#39;， 当我们点击的时候，也就发送了一个带有这一路径的请求，监听到之后，就会触发中间件的执行function launchEditorMiddleware (req, res, next) &#123;    // 获取我们要打开的文件路径    const &#123; file &#125; = url.parse(req.url, true).query || &#123;&#125;    if (!file) &#123;      res.statusCode = 500      res.end(`launch-editor-middleware: required query param &quot;file&quot; is missing.`)    &#125; else &#123;      // 执行打开文件操作(需要完整的文件路径，指定的要使用的编辑器，错误处理函数)      launch(path.resolve(srcRoot, file), specifiedEditor, onErrorCallback)      // 中间件执行结束      res.end()    &#125;  &#125;</code></pre><h3 id="launchEditor"><a href="#launchEditor" class="headerlink" title="launchEditor"></a>launchEditor</h3><p>接下来让我们看看核心代码 <code>launchEditor</code></p><pre><code class="js">let _childProcess = null // 为 _childProcess 设置一个初始值function launchEditor (file, specifiedEditor, onErrorCallback) &#123;  // 获取文件信息（文件名、行号和列号）  const parsed = parseFile(file)  let &#123; fileName &#125; = parsed  const &#123; lineNumber, columnNumber &#125; = parsed  // 判断是否存在该文件  if (!fs.existsSync(fileName)) &#123;    return  &#125;  // 还是对于参数的判断  if (typeof specifiedEditor === &#39;function&#39;) &#123;    onErrorCallback = specifiedEditor    specifiedEditor = undefined  &#125;  // 对于错误处理函数的二次包装，可以在内部进行其他处理，我们可以稍后学习一下 wrapErrorCallback 的处理  onErrorCallback = wrapErrorCallback(onErrorCallback)  // 获取到要使用的编辑器路径和其他选项，这个函数主要是通过 node 方法获取到当前使用的编辑器来处理，这一步我们也稍后再来学习  const [editor, ...args] = guessEditor(specifiedEditor)  if (!editor) &#123;    onErrorCallback(fileName, null)    return  &#125;  // 因本人只有 windows 系统，其他系统暂不考虑  /* if (  //   process.platform === &#39;linux&#39; &amp;&amp;  //   fileName.startsWith(&#39;/mnt/&#39;) &amp;&amp;  //   /Microsoft/i.test(os.release())  // ) &#123;    // Assume WSL / &quot;Bash on Ubuntu on Windows&quot; is being used, and    // that the file exists on the Windows file system.    // `os.release()` is &quot;4.4.0-43-Microsoft&quot; in the current release    // build of WSL, see: https://github.com/Microsoft/BashOnWindows/issues/423#issuecomment-221627364    // When a Windows editor is specified, interop functionality can    // handle the path translation, but only if a relative path is used.    // fileName = path.relative(&#39;&#39;, fileName)   &#125;*/  // 若存在行号，则去获取其他的位置信息，并将其添加在 guessEditor 返回的 args 中  // 不存在则直接将文件名添加到 args 中  if (lineNumber) &#123;    const extraArgs = getArgumentsForPosition(editor, fileName, lineNumber, columnNumber)    args.push.apply(args, extraArgs)  &#125; else &#123;    args.push(fileName)  &#125;  // 若 _childProcess 已存在且编辑器是一个终端编辑器(vim等)  // 则直接杀掉进程，防止存在多个终端编辑器导致迷惑  if (_childProcess &amp;&amp; isTerminalEditor(editor)) &#123;    // There&#39;s an existing editor process already and it&#39;s attached    // to the terminal, so go kill it. Otherwise two separate editor    // instances attach to the stdin/stdout which gets confusing.    _childProcess.kill(&#39;SIGKILL&#39;)  &#125;  // 当当前平台是 windows 平台，调用 childProcess.spawn 唤起编辑器打开代码文件  if (process.platform === &#39;win32&#39;) &#123;    // On Windows, launch the editor in a shell because spawn can only    // launch .exe files.    _childProcess = childProcess.spawn(      &#39;cmd.exe&#39;,      [&#39;/C&#39;, editor].concat(args),      &#123; stdio: &#39;inherit&#39; &#125;    )  &#125; else &#123;    // 暂不考虑非 windows 平台    // _childProcess = childProcess.spawn(editor, args, &#123; stdio: &#39;inherit&#39; &#125;)  &#125;  // 监听关闭和错误  _childProcess.on(&#39;exit&#39;, function (errorCode) &#123;    _childProcess = null    if (errorCode) &#123;      onErrorCallback(fileName, &#39;(code &#39; + errorCode + &#39;)&#39;)    &#125;  &#125;)  _childProcess.on(&#39;error&#39;, function (error) &#123;    onErrorCallback(fileName, error.message)  &#125;)&#125;</code></pre><h4 id="wrapErrorCallback"><a href="#wrapErrorCallback" class="headerlink" title="wrapErrorCallback"></a>wrapErrorCallback</h4><p>来看一下刚才说到的错误回调函数的装饰器</p><pre><code class="js">// 错误回调函数的装饰器function wrapErrorCallback (cb) &#123;  return (fileName, errorMessage) =&gt; &#123;    console.log(      chalk.red(&#39;Could not open &#39; + path.basename(fileName) + &#39; in the editor.&#39;)    )    if (errorMessage) &#123;      if (errorMessage[errorMessage.length - 1] !== &#39;.&#39;) &#123;        errorMessage += &#39;.&#39;      &#125;      console.log(        chalk.red(&#39;The editor process exited with an error: &#39; + errorMessage)      )    &#125;    console.log()    // 我们可以在添加了一部分代码后，再调用回调    if (cb) cb(fileName, errorMessage)  &#125;&#125;</code></pre><h4 id="guessEditor"><a href="#guessEditor" class="headerlink" title="guessEditor"></a>guessEditor</h4><p>下面的代码则是对将要打开的编辑器的一个猜测，如果直接传了一个字符串表示指定的编辑器，则可以直接打开该编辑器，否则，我们可以通过 node 的 childProcess 获取所有正在运行中的进程，与我们保存的常量：编辑器名称表进行匹配，找到匹配的就返回出去，给到外层函数去调用打开文件的方法</p><pre><code class="js">function guessEditor (specifiedEditor) &#123;  if (specifiedEditor) &#123;    return shellQuote.parse(specifiedEditor)  &#125;  // We can find out which editor is currently running by:  // `ps x` on macOS and Linux  // `Get-Process` on Windows  try &#123;    //  mac 端，暂不深入    if (process.platform === &#39;darwin&#39;) &#123;    //...    &#125; else if (process.platform === &#39;win32&#39;) &#123;      // 使用 Get-Process 获取所有子线程的名称      const output = childProcess        .execSync(&#39;powershell -Command &quot;Get-Process | Select-Object Path&quot;&#39;, &#123;          stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;ignore&#39;]        &#125;)        .toString()      const runningProcesses = output.split(&#39;\r\n&#39;)      for (let i = 0; i &lt; runningProcesses.length; i++) &#123;        // `Get-Process` sometimes returns empty lines        if (!runningProcesses[i]) &#123;          continue        &#125;        const fullProcessPath = runningProcesses[i].trim()        const shortProcessName = path.basename(fullProcessPath)        if (COMMON_EDITORS_WIN.indexOf(shortProcessName) !== -1) &#123;          // 找到匹配的进程名则返回          return [fullProcessPath]        &#125;      &#125;    &#125; else if (process.platform === &#39;linux&#39;) &#123;      // linux 跳过    &#125;  &#125; catch (error) &#123;    // Ignore...  &#125;  // Last resort, use old skool env vars  // 我们也可以在环境变量中配置要打开的编辑器  if (process.env.VISUAL) &#123;    return [process.env.VISUAL]  &#125; else if (process.env.EDITOR) &#123;    return [process.env.EDITOR]  &#125;  return [null]&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一个源码读下来，收获很多，也发现了自己的很多不足：</p><ol><li>对于上文说到的 <code>app.use</code> 和 <code>launchEditorMiddleware</code> 中的参数处理，基于对参数类型的判断，减少传参时的无用变量的传递，是挺妙的。不过对于用惯了静态类型语言的人以及要经常协作的团队来说，这一块或许是有点恶心？毕竟是基于 <code>javaScript</code> 动态类型语言的特性，参数类型可以随意改变，是否会容易出现不可预料的 bug 呢？</li><li>变量名和函数名都具有语义化的特点，可以很直观的看出功能和作用</li><li>对函数进行二次包装，可以在调用之前添加一些相关的代码，不过对于装饰器的定义需要有足够的普适性</li><li>这段代码的简易流程可以理解为：初始化 devServer -&gt; before钩子挂载中间件，监听请求带有对应的字段时触发中间件 -&gt;点击打开发送请求 -&gt; 解析请求的 url -&gt; 获取对应的文件信息 -&gt; 用 childProcess 使用生命的编辑器或获取所有线程名称找到可以使用的编辑器 -&gt; 调用 spawn 方法使用编辑器打开对应的文件 -&gt; 在 childProcess 监听 exit 和 error 事件处理对应情况</li><li>对于我个人来说，主要是个人知识面不足，对于 node 相关知识还是需要再去了解一下。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue-devtool-中-open-in-editor-源码阅读&quot;&gt;&lt;a href=&quot;#vue-devtool-中-open-in-editor-源码阅读&quot; class=&quot;headerlink&quot; title=&quot;vue-devtool 中 open-in-edit
      
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js源码解析" scheme="https://kerbalhao.github.io/tags/js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>用 ES6 重写 Tiny-Emitter</title>
    <link href="https://kerbalhao.github.io/2022/01/21/%E7%94%A8%20ES6%20%E9%87%8D%E5%86%99%20tiny-emitter/"/>
    <id>https://kerbalhao.github.io/2022/01/21/%E7%94%A8%20ES6%20%E9%87%8D%E5%86%99%20tiny-emitter/</id>
    <published>2022-01-21T10:36:09.000Z</published>
    <updated>2022-07-05T02:12:48.931Z</updated>
    
    <content type="html"><![CDATA[<p>基于 tiny-emitter 源码重新用 es6 语法写了一下 tiny-emitter</p><pre><code class="javascript">class Emitter &#123;  constructor() &#123;    // 构造函数初始化一个空对象来存放不同的事件队列    this.e = &#123;&#125;;  &#125;  // 订阅事件  on(name, cb, ctx) &#123;    !this.e[name] &amp;&amp; (this.e[name] = [])    this.e[name].push(&#123;      fn: cb,      ctx    &#125;)    return this  &#125;  // 订阅只执行一次的事件  once(name, cb, ctx) &#123;    const self = this    // 装饰器，对事件进行一次包装，在执行装饰器的时候，会先从队列中卸载掉真实事件，而后执行真实事件    function listener(...args) &#123;      self.off(name, cb)      cb.apply(ctx, args)    &#125;    // 在装饰器中用私有属性来存储真实的事件函数，方便卸载时使用    listener._ = cb    this.on(name, listener, ctx)  &#125;  off(name, cb) &#123;    const events = this.e[name]    let liveEvents = []    // 若存在 cb, 则只卸载指定的事件；若不存在，则 liveEvents 为空，整个事件队列被清空    if (events &amp;&amp; cb) &#123;      liveEvents = events.filter(event =&gt; event.fn !== cb &amp;&amp; event.fn._ !== cb)    &#125;    // 根据事件队列存活的事件的数量，确定本类型的事件队列的数量    liveEvents.length ? this.e[name] = liveEvents : delete this.e[name]    return this  &#125;  emit(name, ...args) &#123;    const events = this.e[name] || []    events.forEach(event =&gt; &#123;      event.fn.apply(event.ctx, args)    &#125;)    return this  &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于 tiny-emitter 源码重新用 es6 语法写了一下 tiny-emitter&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;class Emitter &amp;#123;
  constructor() &amp;#123;
    // 构造函数初始
      
    
    </summary>
    
    
    
      <category term="js源码解析" scheme="https://kerbalhao.github.io/tags/js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 repease.js 学习</title>
    <link href="https://kerbalhao.github.io/2022/01/10/Vue3%20repease.js%20%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kerbalhao.github.io/2022/01/10/Vue3%20repease.js%20%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-01-10T10:36:09.000Z</published>
    <updated>2022-07-05T02:24:22.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="辅助库"><a href="#辅助库" class="headerlink" title="辅助库"></a>辅助库</h2><p>Vue3 的发布用到了以下几个库，大部分也是我第一次接触</p><ul><li>minimist，用于解析命令行参数</li><li>fs，node 内置的文件模块</li><li>path，node 内置的路径处理模块</li><li>chalk，用于命令行显示多色彩输出</li><li>semver，版本号语义化，也可用于版本号校验</li><li>enquirer，命令行交互</li><li>execa，执行终端命令</li></ul><pre><code class="javascript">const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const chalk = require(&quot;chalk&quot;);const semver = require(&quot;semver&quot;);const &#123; prompt &#125; = require(&quot;enquirer&quot;);const execa = require(&quot;execa&quot;);</code></pre><h2 id="辅助函数和变量解析"><a href="#辅助函数和变量解析" class="headerlink" title="辅助函数和变量解析"></a>辅助函数和变量解析</h2><pre><code class="javascript">// 获取终端命令参数const args = require(&quot;minimist&quot;)(process.argv.slice(2));const preId =  args.preid ||  (semver.prerelease(currentVersion) &amp;&amp; semver.prerelease(currentVersion)[0]);const isDryRun = args.dry;const skipTests = args.skipTests;const skipBuild = args.skipBuild;// 获取包的列表const packages = fs  .readdirSync(path.resolve(__dirname, &quot;../packages&quot;))  .filter((p) =&gt; !p.endsWith(&quot;.ts&quot;) &amp;&amp; !p.startsWith(&quot;.&quot;));const skippedPackages = [];const versionIncrements = [  &quot;patch&quot;,  &quot;minor&quot;,  &quot;major&quot;,  ...(preId ? [&quot;prepatch&quot;, &quot;preminor&quot;, &quot;premajor&quot;, &quot;prerelease&quot;] : []),];// 版本递增const inc = (i) =&gt; semver.inc(currentVersion, i, preId);// 获取对应文件的的执行文件路径const bin = (name) =&gt; path.resolve(__dirname, &quot;../node_modules/.bin/&quot; + name);// 终端命令不带 -dry 参数的，直接执行对应程序const run = (bin, args, opts = &#123;&#125;) =&gt;  execa(bin, args, &#123; stdio: &quot;inherit&quot;, ...opts &#125;);// 终端命令带有 -dry 参数的，只在控制台输出进m度情况const dryRun = (bin, args, opts = &#123;&#125;) =&gt;  console.log(chalk.blue(`[dryrun] $&#123;bin&#125; $&#123;args.join(&quot; &quot;)&#125;`), opts);const runIfNotDry = isDryRun ? dryRun : run;// 获取单个包的根目录const getPkgRoot = (pkg) =&gt; path.resolve(__dirname, &quot;../packages/&quot; + pkg);// 控制台输出进度情况const step = (msg) =&gt; console.log(chalk.cyan(msg));</code></pre><h2 id="main-函数解析"><a href="#main-函数解析" class="headerlink" title="main 函数解析"></a>main 函数解析</h2><p>接下来让我们从 main 函数开始看起</p><h3 id="第一步-确认要发布的版本"><a href="#第一步-确认要发布的版本" class="headerlink" title="第一步 确认要发布的版本"></a>第一步 确认要发布的版本</h3><pre><code class="javascript">let targetVersion = args._[0];if (!targetVersion) &#123;  // 无明确目标版本号则根据提示选择/输入版本号  const &#123; release &#125; = await prompt(&#123;    type: &quot;select&quot;,    name: &quot;release&quot;,    message: &quot;Select release type&quot;,    choices: versionIncrements      .map((i) =&gt; `$&#123;i&#125; ($&#123;inc(i)&#125;)`)      .concat([&quot;custom&quot;]),  &#125;);  if (release === &quot;custom&quot;) &#123;    targetVersion = (      await prompt(&#123;        type: &quot;input&quot;,        name: &quot;version&quot;,        message: &quot;Input custom version&quot;,        initial: currentVersion,      &#125;)    ).version;  &#125; else &#123;    targetVersion = release.match(/\((.*)\)/)[1];  &#125;&#125;// 判断是否为有效版本号if (!semver.valid(targetVersion)) &#123;  throw new Error(`invalid target version: $&#123;targetVersion&#125;`);&#125;// 二次确认发布const &#123; yes &#125; = await prompt(&#123;  type: &quot;confirm&quot;,  name: &quot;yes&quot;,  message: `Releasing v$&#123;targetVersion&#125;. Confirm?`,&#125;);if (!yes) &#123;  return;&#125;</code></pre><h3 id="第二步-执行测试用例"><a href="#第二步-执行测试用例" class="headerlink" title="第二步 执行测试用例"></a>第二步 执行测试用例</h3><pre><code class="javascript">// 发布前执行测试step(&quot;\nRunning tests...&quot;);if (!skipTests &amp;&amp; !isDryRun) &#123;  await run(bin(&quot;jest&quot;), [&quot;--clearCache&quot;]);  await run(&quot;yarn&quot;, [&quot;test&quot;, &quot;--bail&quot;]);&#125; else &#123;  console.log(`(skipped)`);&#125;</code></pre><h3 id="第三步-更新所有相关的包的版本号"><a href="#第三步-更新所有相关的包的版本号" class="headerlink" title="第三步 更新所有相关的包的版本号"></a>第三步 更新所有相关的包的版本号</h3><pre><code class="javascript">// update all package versions and inter-dependenciesstep(&quot;\nUpdating cross dependencies...&quot;);// 更新 monorepo 内的所有包和内部的依赖的版本号updateVersions(targetVersion);</code></pre><p>下面是这个 updateVersions 函数的相关内容</p><pre><code class="javascript">function updateVersions(version) &#123;  // 1. 更新根目录下的 package.json 的版本号  updatePackage(path.resolve(__dirname, &quot;..&quot;), version);  // 2. 更新所有包的 package.json 的版本号  packages.forEach((p) =&gt; updatePackage(getPkgRoot(p), version));&#125;function updatePackage(pkgRoot, version) &#123;  const pkgPath = path.resolve(pkgRoot, &quot;package.json&quot;);  // 获取对应的 package.json 内的 JSON 对象  const pkg = JSON.parse(fs.readFileSync(pkgPath, &quot;utf-8&quot;));  pkg.version = version;  // 更新依赖的版本  updateDeps(pkg, &quot;dependencies&quot;, version);  updateDeps(pkg, &quot;peerDependencies&quot;, version);  // 更新对应的的 package.json 的版本号  fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + &quot;\n&quot;);&#125;function updateDeps(pkg, depType, version) &#123;  // 根据依赖类型决定更新那些依赖的版本号  const deps = pkg[depType];  if (!deps) return;  Object.keys(deps).forEach((dep) =&gt; &#123;    if (      dep === &quot;vue&quot; ||      (dep.startsWith(&quot;@vue&quot;) &amp;&amp; packages.includes(dep.replace(/^@vue\//, &quot;&quot;)))    ) &#123;      console.log(        chalk.yellow(`$&#123;pkg.name&#125; -&gt; $&#123;depType&#125; -&gt; $&#123;dep&#125;@$&#123;version&#125;`)      );      deps[dep] = version;    &#125;  &#125;);&#125;</code></pre><h3 id="第四步-执行打包操作，生成更新日志，并提交-commit"><a href="#第四步-执行打包操作，生成更新日志，并提交-commit" class="headerlink" title="第四步 执行打包操作，生成更新日志，并提交 commit"></a>第四步 执行打包操作，生成更新日志，并提交 commit</h3><pre><code class="javascript">// 构建所有的包step(&quot;\nBuilding all packages...&quot;);if (!skipBuild &amp;&amp; !isDryRun) &#123;  await run(&quot;yarn&quot;, [&quot;build&quot;, &quot;--release&quot;]);  // test generated dts files  step(&quot;\nVerifying type declarations...&quot;);  await run(&quot;yarn&quot;, [&quot;test-dts-only&quot;]);&#125; else &#123;  console.log(`(skipped)`);&#125;// 生成 Changelog，包含上一次版本更新后的所有 commitawait run(`yarn`, [&quot;changelog&quot;]);// 获取 git diff 后的结果const &#123; stdout &#125; = await run(&quot;git&quot;, [&quot;diff&quot;], &#123; stdio: &quot;pipe&quot; &#125;);// 当 git diff 确认有结果，则说明文件有改变，执行 git 提交操作if (stdout) &#123;  step(&quot;\nCommitting changes...&quot;);  await runIfNotDry(&quot;git&quot;, [&quot;add&quot;, &quot;-A&quot;]);  await runIfNotDry(&quot;git&quot;, [&quot;commit&quot;, &quot;-m&quot;, `release: v$&#123;targetVersion&#125;`]);&#125; else &#123;  console.log(&quot;No changes to commit.&quot;);&#125;</code></pre><h3 id="第五步-遍历发布-publish-所有包到包管理服务器"><a href="#第五步-遍历发布-publish-所有包到包管理服务器" class="headerlink" title="第五步 遍历发布(publish)所有包到包管理服务器"></a>第五步 遍历发布(publish)所有包到包管理服务器</h3><pre><code class="javascript">step(&quot;\nPublishing packages...&quot;);// 遍历包，逐一执行打包发布操作for (const pkg of packages) &#123;  await publishPackage(pkg, targetVersion, runIfNotDry);&#125;async function publishPackage(pkgName, version, runIfNotDry) &#123;  // 判断当前的包是否需要跳过  if (skippedPackages.includes(pkgName)) &#123;    return;  &#125;  // 获取 package 信息  const pkgRoot = getPkgRoot(pkgName);  const pkgPath = path.resolve(pkgRoot, &quot;package.json&quot;);  const pkg = JSON.parse(fs.readFileSync(pkgPath, &quot;utf-8&quot;));  if (pkg.private) &#123;    return;  &#125;  // 确定发布的版本类型  let releaseTag = null;  if (args.tag) &#123;    releaseTag = args.tag;  &#125; else if (version.includes(&quot;alpha&quot;)) &#123;    releaseTag = &quot;alpha&quot;;  &#125; else if (version.includes(&quot;beta&quot;)) &#123;    releaseTag = &quot;beta&quot;;  &#125; else if (version.includes(&quot;rc&quot;)) &#123;    releaseTag = &quot;rc&quot;;  &#125; else if (pkgName === &quot;vue&quot;) &#123;    // TODO remove when 3.x becomes default    releaseTag = &quot;next&quot;;  &#125;  step(`Publishing $&#123;pkgName&#125;...`);  try &#123;    // 用 execa 在当前包的路径下调用 yarn 执行 publish 命令    await runIfNotDry(      &quot;yarn&quot;,      [        &quot;publish&quot;,        &quot;--new-version&quot;,        version,        ...(releaseTag ? [&quot;--tag&quot;, releaseTag] : []),        &quot;--access&quot;,        &quot;public&quot;,      ],      &#123;        cwd: pkgRoot,        stdio: &quot;pipe&quot;,      &#125;    );    console.log(chalk.green(`Successfully published $&#123;pkgName&#125;@$&#123;version&#125;`));  &#125; catch (e) &#123;    if (e.stderr.match(/previously published/)) &#123;      console.log(chalk.red(`Skipping already published: $&#123;pkgName&#125;`));    &#125; else &#123;      throw e;    &#125;  &#125;&#125;</code></pre><h3 id="第六步-推送代码和-tag-到远端-git-仓库"><a href="#第六步-推送代码和-tag-到远端-git-仓库" class="headerlink" title="第六步 推送代码和 tag 到远端 git 仓库"></a>第六步 推送代码和 tag 到远端 git 仓库</h3><pre><code class="javascript">// push to GitHub// 代码打 tag 并推送到远端step(&quot;\nPushing to GitHub...&quot;);await runIfNotDry(&quot;git&quot;, [&quot;tag&quot;, `v$&#123;targetVersion&#125;`]);await runIfNotDry(&quot;git&quot;, [&quot;push&quot;, &quot;origin&quot;, `refs/tags/v$&#123;targetVersion&#125;`]);await runIfNotDry(&quot;git&quot;, [&quot;push&quot;]);if (isDryRun) &#123;  console.log(`\nDry run finished - run git diff to see package changes.`);&#125;if (skippedPackages.length) &#123;  console.log(    chalk.yellow(      `The following packages are skipped and NOT published:\n- $&#123;skippedPackages.join(        &quot;\n- &quot;      )&#125;`    )  );&#125;console.log();</code></pre><h2 id="流程简析"><a href="#流程简析" class="headerlink" title="流程简析"></a>流程简析</h2><ol><li>确认要发布的版本</li><li>执行测试用例</li><li>更新所有相关的包的版本号</li><li>执行打包操作，生成更新日志，提交代码到本地 git 仓库</li><li>遍历发布所有包到 yarn</li><li>推送代码和 tag 到远端 git 仓库</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;辅助库&quot;&gt;&lt;a href=&quot;#辅助库&quot; class=&quot;headerlink&quot; title=&quot;辅助库&quot;&gt;&lt;/a&gt;辅助库&lt;/h2&gt;&lt;p&gt;Vue3 的发布用到了以下几个库，大部分也是我第一次接触&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;minimist，用于解析命令行参数&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS源码解析" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/JS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JS" scheme="https://kerbalhao.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Next 的 Shared 模块源码阅读</title>
    <link href="https://kerbalhao.github.io/2021/12/16/vue-next%20%E7%9A%84%20shared%20%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://kerbalhao.github.io/2021/12/16/vue-next%20%E7%9A%84%20shared%20%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2021-12-16T10:36:09.000Z</published>
    <updated>2022-07-05T02:25:49.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-next-的-shared-模块源码阅读"><a href="#vue-next-的-shared-模块源码阅读" class="headerlink" title="vue-next 的 shared 模块源码阅读"></a>vue-next 的 shared 模块源码阅读</h1><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h2 id="创建映射表"><a href="#创建映射表" class="headerlink" title="创建映射表"></a>创建映射表</h2><p><strong>根据提供的字符串创建一个闭包保存映射表，返回一个函数，该函数判断接受的参数是否在映射表内</strong></p><pre><code class="javascript">// 根据提供的字符串创建一个 映射表，返回一个函数，判断返回的函数接受的参数是否在 映射表内function makeMap(str, expectsLowerCase) &#123;    // 创建一个完全的空对象，该对象不存在原型，节约内存    const map = Object.create(null);    const list = str.split(&#39;,&#39;);    for (let i = 0; i &lt; list.length; i++) &#123;        // 创建映射表        map[list[i]] = true;    &#125;    // 利用闭包，返回一个箭头函数，判断参数是否存在 映射表内    return expectsLowerCase ? val =&gt; !!map[val.toLowerCase()] : val =&gt; !!map[val];&#125;</code></pre><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="两变量的松散比较"><a href="#两变量的松散比较" class="headerlink" title="两变量的松散比较"></a>两变量的松散比较</h3><p>先比较两者的类型是否一致：</p><ul><li><p>若同为日期对象，则比较两者的时间戳</p></li><li><p>若同为数组，则调用数组的松散比较比较</p></li><li><p>若同为对象，则先比较两者的 keys 数量是否一致，</p><ul><li>而后遍历任一方的 keys 数组，判断当前 key 是否同为该对象的自有属性而非原型属性</li><li>往下则调用自身方法判断两者的属性值是否一致</li></ul></li></ul><pre><code class="javascript">function looseEqual(a, b) &#123;    if (a === b)        return true;    // 判断时间相等    let aValidType = isDate(a);    let bValidType = isDate(b);    if (aValidType || bValidType) &#123;        return aValidType &amp;&amp; bValidType ? a.getTime() === b.getTime() : false;    &#125;    // 判断数组相等    aValidType = isArray(a);    bValidType = isArray(b);    if (aValidType || bValidType) &#123;        return aValidType &amp;&amp; bValidType ?          /* 若接受的参数 a b 都是一个数组，则调用数组的弱比较方法*/           looseCompareArrays(a, b)          : false;    &#125;    // 判断对象相等    aValidType = isObject(a);    bValidType = isObject(b);    if (aValidType || bValidType) &#123;        /* istanbul ignore if: this if will probably never be called */        if (!aValidType || !bValidType) &#123;            return false;        &#125;        const aKeysCount = Object.keys(a).length;        const bKeysCount = Object.keys(b).length;        if (aKeysCount !== bKeysCount) &#123;            return false;        &#125;        for (const key in a) &#123;            const aHasKey = a.hasOwnProperty(key);            const bHasKey = b.hasOwnProperty(key);            if ((aHasKey &amp;&amp; !bHasKey) ||                (!aHasKey &amp;&amp; bHasKey) ||                !looseEqual(a[key], b[key])) &#123;                return false;            &#125;        &#125;    &#125;    return String(a) === String(b);&#125;</code></pre><h3 id="数组松散比较"><a href="#数组松散比较" class="headerlink" title="数组松散比较"></a>数组松散比较</h3><pre><code class="javascript">function looseCompareArrays(a, b) &#123;    if (a.length !== b.length)        return false;    let equal = true;    for (let i = 0; equal &amp;&amp; i &lt; a.length; i++) &#123;        equal = looseEqual(a[i], b[i]);        // 优化，当有一个不相等时，直接中断并返回        if (!equal)          return equal;    &#125;    return equal;&#125;</code></pre><h3 id="获取松散索引"><a href="#获取松散索引" class="headerlink" title="获取松散索引"></a>获取松散索引</h3><pre><code class="javascript">function looseIndexOf(arr, val) &#123;    return arr.findIndex(item =&gt;       /* 可以比较元素是对象或数组，判断两者是否值相等，而非指向的内存空间的相等 */      looseEqual(item, val)     );&#125;</code></pre><h2 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h2><pre><code class="javascript">// 用 freeze 可以防止对冻结对象的增删改操作const EMPTY_OBJ = Object.freeze(&#123;&#125;);const EMPTY_ARR = Object.freeze([]) ;const NOOP = () =&gt; &#123; &#125;;/** * Always return false. */const NO = () =&gt; false;</code></pre><h3 id="函数返回值的缓存"><a href="#函数返回值的缓存" class="headerlink" title="函数返回值的缓存"></a>函数返回值的缓存</h3><p>字符串缓存，创建一个空对象，使用闭包实现返回一个函数，调用该函数返回的值都将以参数为键进行缓存</p><pre><code class="javascript">const cacheStringFunction = (fn) =&gt; &#123;  const cache = Object.create(null);  return ((str) =&gt; &#123;    const hit = cache[str];    return hit || (cache[str] = fn(str));  &#125;);&#125;;</code></pre><h3 id="template-属性处理"><a href="#template-属性处理" class="headerlink" title="template 属性处理"></a>template 属性处理</h3><p><strong>大写转连字符</strong></p><pre><code class="javascript">// \B 表示单词边界const hyphenateRE = /\B([A-Z])/g;/** * template 中的大写字符处理 */const hyphenate = cacheStringFunction((str) =&gt;str.replace(hyphenateRE, &#39;-$1&#39;) // 驼峰转连字符.toLowerCase()); // 全部转小写const camelizeRE = /-(\w)/g;/** * 连字符转大写 */const camelize = cacheStringFunction((str) =&gt; &#123;  return str.replace(camelizeRE, (_, c) =&gt; (c ? c.toUpperCase() : &#39;&#39;));&#125;); // 首字母转大写const capitalize = cacheStringFunction((str) =&gt; str.charAt(0).toUpperCase() + str.slice(1));</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>判断值是否有变化</strong></p><pre><code class="javascript">const hasChanged = (value, oldValue) =&gt; !Object.is(value, oldValue);</code></pre><p><strong>顺序调用函数数组</strong></p><pre><code class="javascript">const invokeArrayFns = (fns, arg) =&gt; &#123;  for (let i = 0; i &lt; fns.length; i++) &#123;      fns[i](arg);  &#125;&#125;;</code></pre><p><strong>封装对象属性定义方法，并阻止枚举</strong></p><pre><code class="javascript">const def = (obj, key, value) =&gt; &#123;  Object.defineProperty(obj, key, &#123;      configurable: true,      enumerable: false,      value  &#125;);&#125;;</code></pre><p><strong>转化为数字</strong></p><pre><code class="javascript">const toNumber = (val) =&gt; &#123;    const n = parseFloat(val);    return isNaN(n) ? val : n;&#125;;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里主要是对 vue-next 中的 shared 模块进行源码的学习，对个人认为可以学习的代码做了一下笔记，如有错误，欢迎指出。</p><p>对于比较：</p><ol><li>对于两个对象的比较：</li></ol><ul><li>则先比较两者的 keys 数量是否一致，<ul><li>而后遍历任一方的 keys 数组，判断当前 key 是否同为该对象的自有属性而非原型属性</li><li>往下则调用自身方法判断两者的属性值是否一致</li></ul></li></ul><ol start="2"><li>对于两个数组的比较：</li></ol><ul><li>先比较数组长度</li><li>再根据索引遍历逐一比较</li></ul><ol start="3"><li>对于两个日期对象的比较</li></ol><ul><li>转化成时间戳进行比较</li></ul><p>对于函数返回值的缓存：</p><ul><li>创建一个纯空对象，函数调用时，以参数为属性名，以返回值为属性值进行缓存使用闭包维护该对象</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue-next-的-shared-模块源码阅读&quot;&gt;&lt;a href=&quot;#vue-next-的-shared-模块源码阅读&quot; class=&quot;headerlink&quot; title=&quot;vue-next 的 shared 模块源码阅读&quot;&gt;&lt;/a&gt;vue-next 的 sha
      
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS源码解析" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/JS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JS" scheme="https://kerbalhao.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Promissify 实现</title>
    <link href="https://kerbalhao.github.io/2021/12/05/promissify%20%E5%AE%9E%E7%8E%B0/"/>
    <id>https://kerbalhao.github.io/2021/12/05/promissify%20%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-12-05T10:36:09.000Z</published>
    <updated>2022-07-05T02:27:16.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="promissify-实现"><a href="#promissify-实现" class="headerlink" title="promissify 实现"></a>promissify 实现</h1><p>promissify 用于将需要传递回调函数的异步函数转换成 promise 函数<br>注意，这种方式的 promissfy 可以转换的函数，其接收的回调函数接收的参数只能是 错误优先的那种</p><pre><code class="javascript">// 高阶函数，将需要传入回调函数的异步函数转换为返回 Promise 的异步函数function promissify(fn) &#123;  // 返回一个函数，在该函数内会将原函数内的回调函数接收的参数(err || values)原样传递到 Promise 外面供 then 使用  return function (...args) &#123;    const self = this // 保存 this 引用    return new Promise((resolve, reject) =&gt; &#123;      // 在原函数需要的参数列表中添加回调函数      args.push((err, ...values) =&gt; &#123;        if (err) &#123;          reject(err);        &#125;        resolve(values);      &#125;);      // 参数列表准备完成后，执行原函数      fn.apply(self, args);    &#125;);  &#125;;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;promissify-实现&quot;&gt;&lt;a href=&quot;#promissify-实现&quot; class=&quot;headerlink&quot; title=&quot;promissify 实现&quot;&gt;&lt;/a&gt;promissify 实现&lt;/h1&gt;&lt;p&gt;promissify 用于将需要传递回调函数的异步函
      
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js源码解析" scheme="https://kerbalhao.github.io/tags/js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 基础配置</title>
    <link href="https://kerbalhao.github.io/2021/11/10/webpack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kerbalhao.github.io/2021/11/10/webpack%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-10T10:36:09.000Z</published>
    <updated>2022-07-05T02:26:20.739Z</updated>
    
    <content type="html"><![CDATA[<p><code>Webpack</code> 是一个打包工具，可以在主目录创建 <code>webpack.config.js</code> 配置文件对其进行配置。</p><span id="more"></span><p>配置内容如下：</p><pre><code class="js">//webpack.config.js 配置const path = require(&#39;path&#39;)const HtmlWebpackPlugin = require(&#39;html-weback-plugin&#39;)const MiniExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);// css 文件提取插件，无此插件，css 与 js 被编译到同一个文件const &#123; CleanWebpackPlugin &#125; = require(&#39;clean-webpack-plugin&#39;); //打包前清理输出目录// 没有以下插件的情况下，在 webpack 提取出的 js 和 css 文件中，只会压缩 js 文件，不会压缩 css 文件，因此，需要手动配置插件压缩 css 文件，但是手动压缩 css 文件后， js 文件也需要手动压缩const TerserJSPlugin = require(&#39;terser-webpack-plugin&#39;); //压缩jsconst OptimizeCSSAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;); // 压缩 cssmodule.exports = &#123;  entry: entrfile.js // 配置总的入口文件  output ：&#123;    filename: output.js,// 配置创建的出口文件名    path: path.resolve(__dirname, &#39;output.js&#39;) // 输出文件的路径， path.resolve 是 node.js 的 path 库自带的api, 用于拼接绝对路径，__dirname 表示当前目录  &#125;,  //以下是可选项  devServer: &#123;// 配置 webpack 的开发服务器，使用该服务器需要在 package.json 中设置命令调用 &quot;webpack-dev-server&quot;    port: 8080,//端口号    open: true, //布尔值，是否自动打开页面    compress: true, //布尔值。是否启动gzip压缩    contentBase: &#39;aa&#39; //放置静态资源文件文件夹的路径，可在服务器上直接访问  &#125;,  optimization: &#123; // 优化方法      // 注册压缩器      minimizer: [new TerserJSPlugin(&#123;&#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;)],     &#125;,  plugins: [ // 注册并配置 webpack 相关插件    new HtmlWebpackPlugin(&#123; //插件，用于自动将模板文件内的 js 路径编译为打包后的 js 文件路径，该插件需要使用 require(&#39;html-webpack-plugin&#39;) 引用      template: &#39;index.js&#39;, //模板文件绝对路径，      filename: &#39;bundle.js&#39; //输出替换换后的文件名    &#125;),    new CleanWebpackPlugin(),    new MiniExtractPlugin(&#123;        filename:&quot;css/main.css&quot; // 设置提取出来的 css 名称    &#125;),  ],  module: &#123; // 确定哪些文件需要转换，需要使用什么 loader 去进行转化    rules: [ // 需要注意 loader 配置的顺序，按数组反向加载，即从后往前      &#123;        test: /\.css$/使用正则表达式匹配需要转换的文件，        use:  [          &#123; // 使用 css 提取插件以后，css 不再使用 style 标签引用，而是使用 link 标签引用，因此需要使用以下 loader            loader:MiniExtractPlugin.loader          &#125;,          &#123; // 此处是为了解析 在 css 文件内引用了 less 文件的嵌套的情况            loader: &#39;css-loader&#39;,            options: &#123;              importLoaders: 1 // 表示用后面的 1 个 loader 去解析            &#125;          &#125;,          &quot;postcss-loader&quot;, //使用 postcss loader          &#39;less-loader&#39;]      &#125;,      &#123;        test: /\.less$/, //使用正则表达式 匹配需要转换的文件        use:  [&#39;style-loader&#39;,&quot;css-loader&quot;, &#39;less-loader&#39;] // 配置对应的loader,需要注意 loader 配置的顺序，      &#125;    ]  &#125;&#125;</code></pre><p><code>postcss-loader</code> 样式处理工具，可以借助自定义的插件重新定义 <code>css</code></p><p>比如加私有前缀的插件 <code>autoprefixer</code></p><pre><code class="js">//postcss.config.jsmodule.exports = &#123;  //配置插件  plugins: [require(&quot;autoprefixer&quot;)],&#125;;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Webpack&lt;/code&gt; 是一个打包工具，可以在主目录创建 &lt;code&gt;webpack.config.js&lt;/code&gt; 配置文件对其进行配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>基于后台项目拆分</title>
    <link href="https://kerbalhao.github.io/2021/10/21/%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86/"/>
    <id>https://kerbalhao.github.io/2021/10/21/%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86/</id>
    <published>2021-10-21T10:36:09.000Z</published>
    <updated>2022-07-05T02:12:44.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于后台项目拆分"><a href="#基于后台项目拆分" class="headerlink" title="基于后台项目拆分"></a>基于后台项目拆分</h2><ol><li>从远程仓库克隆代码<ol><li>本地仓库解除与远程仓库的绑定</li><li>使用 git subtree split 命令从本地仓库总项目中拆分出需要的子项目，并保存为一个新的分支</li></ol></li></ol><pre><code class="javascript">/** 1 克隆代码 */git clone &lt;root_project_repo&gt;/** 2 解除绑定*/git remote rm origin/** 3 拆分子项目并基于此创建新分支*/// -P：prefix，表示要拆分的子目录// -b: 根据拆分的子项目建立一个新的分支git subtree split -P=src/project/&lt;projectName&gt; -b feature/cf_project_&lt;projectName&gt;</code></pre><ol start="2"><li>回到总项目的父目录，新建一个仓库存放拆分后的文件<ol><li>直接拉取总项目中拆分出来的分支</li></ol></li></ol><pre><code class="javascript">/** 1 回到父目录并创建进入子项目要保存的仓库*/cd .. mkdir project_&lt;projectName&gt; &amp;&amp; cd project_&lt;projectName&gt;/** 2 初始化仓库*/git init/** 3 从总项目拉取子项目分支的代码*/git pull ./../root_project_repo feature/cf_project_&lt;projectName&gt;</code></pre><ol start="3"><li>回到总项目的父目录，克隆公用的配置文件仓库（环境变量，package.json, vue.config.js 等文件）<ol><li>切换到对应的分支</li></ol></li></ol><pre><code class="javascript">/** 1 */git clone &lt;base_config_repo&gt;/** 2 */cd &lt;base_config_repo&gt; &amp;&amp; git checkout &lt;target_branch&gt;</code></pre><ol start="4"><li>回到父目录，新建一个仓库，该仓库作为拆分后项目的最终路径<ol><li>进入项目内，关联配置文件仓库，并拉取代码</li><li>移除关联</li><li>关联上面存放的拆分后文件的仓库</li><li>拉取文件并合并提交记录</li><li>移除关联</li></ol></li></ol><pre><code class="javascript">/** 1 新建一个仓库，该仓库作为拆分后项目的最终路径 */cd ..mkdir backend_&lt;projectName&gt; &amp;&amp; cd backend_&lt;projectName&gt;/** 2 关联配置文件仓库，并拉取代码 */git init// -f: fetch 获取对应仓库的信息, 并命名关联仓库git remote add -f base_config ./../&lt;base_config_repo&gt;// 拉取仓库的对应分支代码git pull base_config &lt;target_branch&gt;// 移除关联git remote rm base_config/** 3 关联上面存放的拆分后文件的仓库*/git remote add -f &lt;projectName&gt; ./../project_&lt;projectName&gt;/** 4 拉取代码并合并提交记录 */// --squash: 压缩提交，只保留一条提交记录// --prefix: subtree add 的 --prefix 表示要添加到的目录路径git subtree add --prefix=src  ./../project_sso feature/cf_sso &lt;--squash&gt;// 允许两个没有联系的仓库合并时保存提交记录git merge -s subtree &lt;projectName&gt;/&lt;targetBranch&gt; --allow-unrelated-histories/** 上述第4点或可使用此命令，合并并保留子项目的提交记录 */git subtree add --prefix=src  ./../project_sso feature/cf_sso</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于后台项目拆分&quot;&gt;&lt;a href=&quot;#基于后台项目拆分&quot; class=&quot;headerlink&quot; title=&quot;基于后台项目拆分&quot;&gt;&lt;/a&gt;基于后台项目拆分&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从远程仓库克隆代码&lt;ol&gt;
&lt;li&gt;本地仓库解除与远程仓库的绑定&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
    
      <category term="工作" scheme="https://kerbalhao.github.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>规范团队包管理工具</title>
    <link href="https://kerbalhao.github.io/2021/10/05/%E8%A7%84%E8%8C%83%E5%9B%A2%E9%98%9F%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://kerbalhao.github.io/2021/10/05/%E8%A7%84%E8%8C%83%E5%9B%A2%E9%98%9F%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2021-10-05T10:36:09.000Z</published>
    <updated>2022-07-05T02:11:31.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前前端主流的包管理工具有 <code>npm</code>, <code>yarn</code> 和 <code>pnpm</code> 三种，在团队开发中，这三种工具可能都有人在使用。<br>出于统一以及避免可能出现的 bug 问题的目的，我们都应该在项目中只使用其中的一种工具。但是我公司所在的团队目前只是使用文档来进行约束，这当然不如使用代码进行强行约束来的靠谱。<br>正好川哥提供了这次对于 only-allow 的源码解读活动，让我有了学习的目标，感谢川哥。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="preinstall"><a href="#preinstall" class="headerlink" title="preinstall"></a>preinstall</h3><p>让我们先来看一下 package.json 是如何设置的</p><pre><code class="json">  &quot;scripts&quot;: &#123;    &quot;preinstall&quot;: &quot;node bin.js pnpm&quot;  &#125;,</code></pre><p>我们在 prinstall 中，将 pnpm 作为命令行参数传递</p><h4 id="scripts-中的-pre-和-post-钩子"><a href="#scripts-中的-pre-和-post-钩子" class="headerlink" title="scripts 中的 pre 和 post 钩子"></a>scripts 中的 pre 和 post 钩子</h4><p>对于在 scripts 中定义的命令名，我们可以在名字（比如 command）之前，添加 pre 实现在调用该（command）命令前先执行 precommand 的内容；可以添加 post 实现在调用该（command）命令后执行 postcommand 的内容<br>具体可看 <a href="https://docs.npmjs.com/cli/v6/using-npm/scripts">npm Docs 对于 scripts 的说明</a></p><h3 id="only-allow-源码"><a href="#only-allow-源码" class="headerlink" title="only-allow 源码"></a>only-allow 源码</h3><pre><code class="javascript">// 获取当前使用的包管理工具const whichPMRuns = require(&quot;which-pm-runs&quot;);// 终端log 样式const boxen = require(&quot;boxen&quot;);// process.argv 用于获取启动 Node.js 进程时传入的命令行参数(包管理器名)，在 package.json 的 script 中设置// process.argv 第一个元素将是 process.execPath。第二个元素将是正在执行的 JavaScript 文件的路径。 其余元素将是任何其他命令行参数。const argv = process.argv.slice(2);// 未指定包管理器直接返回if (argv.length === 0) &#123;  console.log(    &quot;Please specify the wanted package manager: only-allow &lt;npm|pnpm|yarn&gt;&quot;  );  process.exit(1);&#125;// 当输入的命令的第一位元素不是 npm pnpm yarn 则退出// 仅支持这三种包管理器const wantedPM = argv[0];if (wantedPM !== &quot;npm&quot; &amp;&amp; wantedPM !== &quot;pnpm&quot; &amp;&amp; wantedPM !== &quot;yarn&quot;) &#123;  console.log(    `&quot;$&#123;wantedPM&#125;&quot; is not a valid package manager. Available package managers are: npm, pnpm, or yarn.`  );  process.exit(1);&#125;// 获取当前输入的命令行使用的包管理工具// which-pm-runs 使用 process.env.npm_config_user_agent 变量获取到当前运行脚本的包管理器和版本号// process.env.npm_config_user_agent 值类似 &quot;yarn/1.22.10 npm/? node/v14.16.0 linuxconst usedPM = whichPMRuns();// 对使用的包管理工具不合适时的处理if (usedPM &amp;&amp; usedPM.name !== wantedPM) &#123;  const boxenOpts = &#123; borderColor: &quot;red&quot;, borderStyle: &quot;double&quot;, padding: 1 &#125;;  switch (wantedPM) &#123;    case &quot;npm&quot;:      console.log(        boxen(&#39;Use &quot;npm install&quot; for installation in this project&#39;, boxenOpts)      );      break;    case &quot;pnpm&quot;:      console.log(        boxen(          `Use &quot;pnpm install&quot; for installation in this project.If you don&#39;t have pnpm, install it via &quot;npm i -g pnpm&quot;.For more details, go to https://pnpm.js.org/`,          boxenOpts        )      );      break;    case &quot;yarn&quot;:      console.log(        boxen(          `Use &quot;yarn&quot; for installation in this project.If you don&#39;t have Yarn, install it via &quot;npm i -g yarn&quot;.For more details, go to https://yarnpkg.com/`,          boxenOpts        )      );      break;  &#125;  process.exit(1);&#125;</code></pre><h3 id="which-pm-runs"><a href="#which-pm-runs" class="headerlink" title="which-pm-runs"></a>which-pm-runs</h3><p>我们也可以来看一下 which-pm-runs 的源码实现</p><pre><code class="javascript">/* which-pm-runs */module.exports = function () &#123;  if (!process.env.npm_config_user_agent) &#123;    return undefined;  &#125;  return pmFromUserAgent(process.env.npm_config_user_agent);&#125;;// 在此处将 npm_config_user_agent 的值进行拆分和重组，获取到命令行输入的包名function pmFromUserAgent(userAgent) &#123;  const pmSpec = userAgent.split(&quot; &quot;)[0];  const separatorPos = pmSpec.lastIndexOf(&quot;/&quot;);  return &#123;    name: pmSpec.substr(0, separatorPos),    version: pmSpec.substr(separatorPos + 1),  &#125;;&#125;</code></pre><h2 id="延申"><a href="#延申" class="headerlink" title="延申"></a>延申</h2><p>我发现 vue-next 也限制只能使用 yarn 进行依赖的安装，但是它是直接获取到命令行输入的包管理器的路径（<code>process.env.npm_execpath</code>）来判断具体调用的是哪个包管理器</p><pre><code class="javascript">// vue-next/script/checkYarn.jsif (!/yarn\.js$/.test(process.env.npm_execpath || &quot;&quot;)) &#123;  console.warn(    &quot;\u001b[33mThis repository requires Yarn 1.x for scripts to work properly.\u001b[39m\n&quot;  );  process.exit(1);&#125;</code></pre><p>学习 only-allow 后，我修改了一下，使其能检测其他包管理工具，不知道你们对我的这段代码是怎么看的，是否和 only-allow 实现的功能一致，可以互相取代呢？</p><pre><code class="javascript">const argvs = process.argv.slice(2);let wantedPm = new RegExp(&quot;yarn\\.c?js$&quot;);if (argvs.length !== 0) &#123;  wantedPm = new RegExp(argvs[0] + &quot;\\.c?js$&quot;);&#125;if (!wantedPm.test(process.env.npm_execpath || &quot;&quot;)) &#123;  console.warn(    `\u001b[33mThis repository requires $&#123;argvs[0]&#125; for scripts to work properly.\u001b[39m\n`  );  process.exit(1);&#125;</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我还有一些问题，希望看到的你们能帮忙解答我一下，谢谢：</p><ol><li><code>process.env.npm_config_user_agent</code> 值是什么时候、被什么设置的？</li><li><code>process.env.npm_execpath</code> 值是什么时候、被什么设置的？</li><li>对于 vue-next 和 only-allow 中的两种包管理工具的检测方法是否有很大区别？两者是否可以互换？</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>process.argv</code> 获取的是启动 Node.js 进程时传入的命令行参数</li><li>which-pm-runs 使用 <code>process.env.npm_config_user_agent</code> 变量获取到当前运行脚本的包管理器和版本号，比如我们使用 yarn isntall 时，<code>process.env.npm_config_user_agent</code> 的值为 <code>&quot;yarn/1.22.10 npm/? node/v14.16.0 linux x64&quot;</code></li><li>通过比对预设的包管理器与实际调用的包管理器进行限制</li><li>package.json 的 script 可以添加 pre 和 post 钩子</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前前端主流的包管理工具有 &lt;code&gt;npm&lt;/code&gt;, &lt;code&gt;yarn&lt;/code&gt; 和 &lt;code&gt;pnpm&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器是如何渲染网页的</title>
    <link href="https://kerbalhao.github.io/2021/04/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5%E7%9A%84%EF%BC%9F%E2%80%94%E2%80%94DOM,CSSOM%E4%BB%A5%E5%8F%8A%E6%B8%B2%E6%9F%93/"/>
    <id>https://kerbalhao.github.io/2021/04/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5%E7%9A%84%EF%BC%9F%E2%80%94%E2%80%94DOM,CSSOM%E4%BB%A5%E5%8F%8A%E6%B8%B2%E6%9F%93/</id>
    <published>2021-04-17T02:35:10.000Z</published>
    <updated>2022-07-05T02:11:56.002Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自 Uday Hiwarale 的 <a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969">How the browser renders a web page? — DOM, CSSOM, and Rendering</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当你开发一个网站的时候，有些东西对于良好的用户体验来说是非常必要的。网站可能遇到的一些常见问题可能是资源加载缓慢，在初始渲染时等待不必要的文件下载，样式未应用的内容闪烁 <code>(flash of unstyled content (FOUC))</code>等。为了避免类似问题，我们需要了解浏览器渲染典型网页的生命周期。</p><p>首先，我们需要了解什么是 <code>DOM</code>。当浏览器相服务器发送请求，获取一个 <code>HTML</code> 文档的时候，服务器会返回一个二进制流格式的 <code>HTML</code> 页面，它基本就是一个文本文件，其响应头的 <code>Content-Type</code> 设置为 <code>text/html;charset-UTF-8</code>。这里的 <code>text/html</code> ·是一个 <a href="https://en.wikipedia.org/wiki/Media_type">MIME 类型</a>，它告诉浏览器这是一个 <code>HTML</code> 文档，<code>charset=UTF-8</code> 告诉浏览器它是以 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> 字符<a href="https://medium.com/jspoint/introduction-to-character-encoding-3b9735f265a6">编码</a>的。利用这些信息，浏览器剋将二进制格式转换为可读的文本文件。如下图所示。<br><img src="https://i.loli.net/2021/04/17/c1MpWG2FosgNrhl.png" alt="1_Tm-HPhmGA0BL7HIj38H8Qw.png"></p><p>如果该 <code>header</code> 缺失，浏览器将无法理解如何处理该文件，它将以纯文本格式呈现。但如果一切正常，经过这次转换后，浏览器就可以开始阅读 <code>HTML</code> 文档了。一个典型的 <code>HTML</code> 文档大致如下:</p><span id="more"></span><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Rendering Test&lt;/title&gt;    &lt;!-- stylesheet --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot; /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;h1&gt;Hello World!&lt;/h1&gt;      &lt;p&gt;This is a sample paragraph.&lt;/p&gt;    &lt;/div&gt;    &lt;!-- script --&gt;    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>在上面的文档中，我们的网页依赖 <code>style.css</code> 给 <code>HTML</code> 元素提供样式，<code>main.js</code> 来执行一些 <code>JavaScript</code> 操作。通过一些 <code>CSS</code> 样式，我们上面的网页就会变成这样：<br><img src="https://i.loli.net/2021/04/17/c1MpWG2FosgNrhl.png" alt="1_Tm-HPhmGA0BL7HIj38H8Qw.png"></p><p>但问题还是在于，浏览器是如何从一个简单的，只包含文本的 <code>HTML</code> 文件渲染出这个好看的网页呢？为此，我们需要了解什么是 <code>DOM</code>、<code>CSSOM</code> 和 <code>Render Tree</code></p><h3 id="Document-Object-Model-DOM"><a href="#Document-Object-Model-DOM" class="headerlink" title="Document Object Model (DOM)"></a>Document Object Model (DOM)</h3><p>当浏览器读取 <code>HTML</code> 代码时，只要遇到 <code>body、div</code> 等 <code>HTML</code> 元素，就会创建一个名为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node">Node</a> 的 <code>JavaScript</code> 对象。</p><p>由于每个 HTML 元素都有不同的属性，所以 Node 对象将从不同的类(构造函数)中创建。例如，div 元素的 Node 对象是由继承自 Node 类的 HTMLDivElement 创建的。对于我们前面的 HTML 文档，我们可以用一个简单的测试来可视化这些节点，如下图：<br><img src="https://i.loli.net/2021/04/18/FhZEbDYPlCBifR2.png" alt="1618739869298.png"></p><p>浏览器自带了 <code>HTMLDivElement、HTMLScriptElement、Node</code> 等内置类。</p><p>浏览器从 HTML 文档中创建了 <code>Node</code> 之后，就要把这些节点对象创建成树状结构。由于我们在 <code>HTML</code> 文件中的 <code>HTML</code> 元素是互相嵌套的，所以浏览器需要使用之前创建的 <code>Node</code> 对象复制它们。这将帮助浏览器在网页的整个生命周期中高效地渲染和管理网页。</p><p><img src="https://i.loli.net/2021/04/18/FhZEbDYPlCBifR2.png" alt="1618739869298.png"></p><p>我们之前的 <code>HTML</code> 文档的 <code>DOM</code> 树就像上面一样。一棵 <code>DOM</code> 树从最上面的 <code>html</code> 元素开始，根据 <code>HTML</code> 元素在文档中的出现和嵌套情况进行分支。每当发现一个 <code>HTML</code> 元素时，它就会从其各自的类中创建一个 <code>DOM</code> 节点（Node）对象（构造函数）。</p><blockquote><p>一个 <code>DOM</code> 节点并不总是必须是一个 <code>HTML</code> 元素。当浏览器创建 <code>DOM</code> 树时，它也会将注释、属性、文本等内容作为树中的单独节点保存。但为了简单起见，我们只考虑 <code>HTML</code> 元素的 <code>DOM</code> 节点，也就是 <code>DOM</code> 元素。<a href="https://www.w3schools.com/jsref/prop_node_nodetype.asp">这里</a>是所有 <code>DOM</code> 节点类型的列表。</p></blockquote><p>你可以在 <code>Google Chrome DevTools Console</code> 中看到 <code>DOM</code> 树，如下所示。这将显示 <code>DOM</code> 元素的层次结构（DOM 树的高级视图）以及每个 <code>DOM</code> 元素的属性。<br><img src="https://i.loli.net/2021/04/18/je8gfiSnCUZ9bY4.png" alt="1618742342888.png"></p><p><code>JavaScript</code> 不明白 <code>DOM</code> 是什么，它不是 <code>JavaScript</code> 规范的一部分。DOM 是浏览器提供的一种高级 <a href="https://developer.mozilla.org/en-US/docs/Web/API">Web API</a>，用于高效地渲染网页，供开发者动态操作 DOM 元素以达到各种目的。</p><blockquote><p>使用 DOM API，开发者可以添加或删除 HTML 元素，改变其外观或绑定事件监听器。使用 DOM API，可以在内存中创建或克隆 HTML 元素，并在不影响 DOM 树的情况下进行修改。这使得开发者有能力构建高度动态的网页，并提供丰富的用户体验。</p></blockquote><h3 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h3><p>当我们设计一个网站时，我们的目的是让它尽可能的好看。而我们通过为 <code>HTML</code> 元素提供一些样式来实现。在 <code>HTML</code> 页面中，我们使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS">CSS</a>(Cascading Style Sheets，即层叠样式表) 为 <code>HTML</code> 元素提供样式。使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS 选择器</a>，我们可以针对 <code>DOM</code> 元素，为样式属性设置一个值，比如颜色或字体大小。</p><p>将样式应用到 <code>HTML</code> 元素上有不同的方法，比如使用外部 <code>CSS</code> 文件、使用 <code>&lt;style&gt;</code> 标签嵌入 <code>CSS</code>、使用 <code>HTML</code> 元素上的 <code>style</code> 属性的内联方法或使用 <code>JavaScript</code>。但最终，浏览器还是要担起将 <code>CSS</code> 样式应用到 <code>DOM</code> 元素上的重任。</p><p>比方说，对于我们前面的例子，我们将使用下面的 <code>CSS</code> 样式（这不是截图中显示的卡片所使用的 <code>CSS</code>）。为了简单起见，我们不打算理会如何在 <code>HTML</code> 页面中导入 <code>CSS</code> 样式。</p><pre><code class="css">html &#123;  padding: 0;  margin: 0;&#125;body &#123;  font-size: 14px;&#125;.container &#123;  width: 300px;  height: 200px;  color: black;&#125;.container &gt; h1 &#123;  color: gray;&#125;.container &gt; p &#123;  font-size: 12px;  display: none;&#125;</code></pre><p>在构建了 <code>DOM</code> 之后，浏览器从所有的源头（外部的、嵌入式的、内嵌的、用户代理的等）读取 <code>CSS</code> ，并构建一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSSOM</a>。<code>CSSOM</code> 是 <code>CSS</code> 对象模型的缩写，它和 <code>DOM</code> 一样是一个树状结构。</p><p>这个树中的每个节点都包含 <code>CSS</code> 样式信息，这些信息将被应用到它所针对的 <code>DOM</code> 元素上（由选择器指定）。然而，<code>CSSOM</code> 并不包含那些不能在屏幕上打印的 <code>DOM</code> 元素，如 <code>&lt;meta&gt;、&lt;script&gt;、&lt;title&gt;</code>等。</p><p>我们知道，大多数浏览器都自带样式表，这个样式表被称为<a href="https://stackoverflow.com/questions/12582624/what-is-a-user-agent-stylesheet">用户代理样式表</a>，浏览器首先用开发者属性提供的 <code>CSS</code> 覆盖用户代理样式（使用特定性的规则），计算出 <code>DOM</code> 元素的最终 <code>CSS</code> 属性，然后构造一个节点。</p><p>即使某个 <code>HTML</code> 元素的 <code>CSS</code> 属性（如 <code>display</code> ）没有被开发者或浏览器定义，其值也会被设置为 <a href="https://www.w3.org/Style/CSS/">W3C CSS</a> 标准规定的该属性的默认值。在选择 <code>CSS</code> 属性的默认值时，如果某个属性符合 <a href="https://www.w3.org/TR/CSS1/#inheritance">W3C 文档</a>中提到的继承规则，则会使用一些继承规则。</p><p>例如，如果一个 <code>HTML</code> 元素缺少颜色和字体大小等属性，那么这些属性就会继承父元素的值。所以你可以想象一下，在一个 <code>HTML</code> 元素上有这些属性，它的所有子元素都会继承它。这就是所谓的样式层叠，这也是为什么 <code>CSS</code> 是层叠样式表的缩写。这也正是浏览器构建一个树状结构的 <code>CSSOM</code> 的原因，用于根据 <code>CSS</code> 层叠规则计算样式。</p><blockquote><p>您可以在 Element 面板中使用 Chrome DevTools 控制台查看 HTML 元素的计算样式。从左侧面板中选择任意一个 HTML 元素，然后点击右侧面板中的计算选项卡。</p></blockquote><p>我们可以用下图来使前面例子的 <code>CSSOM</code> 树可视化。为了简单起见，我们将忽略用户代理样式，而专注于前面提到的 <code>CSS</code> 样式。</p><p><img src="https://i.loli.net/2021/04/18/gvaLepK5cSJRzqG.png" alt="1618747003004.png"></p><p>从上图中可以看出，我们的 <code>CSSOM</code> 树中不包含 <code>&lt;link&gt;、&lt;title&gt;、&lt;script&gt;</code>等不会被打印到屏幕上的元素。红色的 <code>CSS</code> 属性值是从顶部层叠下来的，而灰色的属性值则是覆盖了继承的值。</p><h3 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h3><p><code>Render-Tree</code> 也是一个将 <code>DOM</code> 树和 <code>CSSOM</code> 树组合在一起构建的树状结构。浏览器要计算每个可见元素的布局，并把它们画在屏幕上，为此浏览器使用了这个 <code>Render-Tree</code>。因此，如果没有构建 <code>Render-Tree</code>，那么任何东西都不会被打印在屏幕上，这就是为什么我们同时需要 DOM 和 CSSOM 树。</p><p>由于 <code>Render-Tree</code> 是对最终将被打印在屏幕上的内容的低级表示，它不会包含在像素矩阵(页面)中不包含任何区域(一定情况下可认为是：不占空间)的节点。例如，<code>display:none</code>;元素的尺寸为 <code>0px X 0px</code>，因此它们不会出现在 <code>Render-Tree</code> 中。</p><p><img src="https://i.loli.net/2021/04/18/zRgLKcTsIUxMAie.png" alt="1618747752887.png"></p><p>从上图可以看出，<code>Render-Tree</code> 结合了 <code>DOM</code> 和 <code>CSSOM</code>，生成了一个树状结构，其中只包含了要打印在屏幕上的元素。</p><p>因为在 <code>CSSOM</code> 中，位于 <code>div</code> 内的 <code>p</code> 元素被设置了 <code>display:none;</code> 样式，所以它和它的子元素不会出现在 <code>Render-Tree</code> 中，因为它在屏幕上不占空间。但是，如果你有 <code>visibility:hidden</code> 或 <code>opacity:0</code> 的元素，它们将占据屏幕空间，因此它们将出现在 <code>Render-Tree</code> 中。</p><p>与 <code>DOM API</code> 不同的是 <code>，DOM API</code> 可以访问浏览器构建的 <code>DOM</code> 树中的 <code>DOM</code> 元素，而 <code>CSSOM</code> 则是对用户隐藏的。但由于浏览器将 <code>DOM</code> 和 <code>CSSOM</code> 结合在一起形成了 <code>Render Tree</code>，所以浏览器通过在 <code>DOM</code> 元素本身提供高级 <code>API</code> 来暴露 <code>DOM</code> 元素的 <code>CSSOM</code> 节点。这样开发者就可以访问或改变 <code>CSSOM</code> 节点的 <code>CSS</code> 属性。</p><blockquote><p>由于使用 <code>JavaScript</code> 操作元素的样式超出了本文的范围，所以这里有一个 <a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/">CSS Tricks 文章的链接</a>，它涵盖了 <code>CSSOM API</code> 的广泛范围。我们还有新的 <code>JavaScript</code> 中的 <a href="https://developers.google.com/web/updates/2018/03/cssom">CSS Typed Object API</a>，它可以更准确地操纵元素的样式。</p></blockquote><h2 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h2><p>现在我们已经很好地理解了什么是 <code>DOM、CSSOM</code>和 <code>Render-Tree</code>，让我们了解一下浏览如何使用它们来渲染一个典型的网页。对这个过程有一个最起码的了解对任何 Web 开发人员来说都是至关重要的，因为它将帮助我们设计我们的网站以获得最大的用户体验（UX）和性能。</p><p>当一个网页被加载时，浏览器首先读取 <code>HTML</code> 文本并从中构建 <code>DOM</code> 树。然后它处理 <code>CSS</code>，无论是内嵌的、嵌入式的、还是外部的 <code>CSS</code>，并从中构建 <code>CSSOM</code> 树。</p><p>构建完这些树后，它再从中构建 <code>Render-Tree</code>。一旦构建了 <code>Render-Tree</code>，浏览器就会开始在屏幕上打印各个元素。</p><h3 id="布局操作"><a href="#布局操作" class="headerlink" title="布局操作"></a>布局操作</h3><p>首先浏览器创建每个单独的 <code>Render-Tree</code> 节点的布局。布局包括每个节点的大小（以像素为单位）和它将被打印在屏幕上的位置。这个过程被称为布局，因为浏览器正在计算每个节点的布局信息。</p><p>这个过程也被称为回流或浏览器回流(reflow)，当你滚动、调整窗口大小或操作 DOM 元素时，也会发生这个过程。<a href="https://stackoverflow.com/a/27637245/2790983">这里</a>是可以触发元素布局/回流的事件列表。</p><blockquote><p>我们应该避免网页因为微不足道的原因进行多次布局操作，因为这是一种昂贵的操作。<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">这里</a>是 <a href="https://twitter.com/aerotwist">Paul Lewis</a> 的一篇文章，他讲述了我们如何避免复杂而昂贵的布局操作以及<a href="https://kellegous.com/j/2013/01/26/layout-performance/">布局打乱</a>。</p></blockquote><h3 id="绘制操作"><a href="#绘制操作" class="headerlink" title="绘制操作"></a>绘制操作</h3><p>直到现在，我们还有一个需要打印在屏幕上的几何体列表。由于 <code>Render-Tree</code> 中的元素（或子树）可以相互重叠，而且它们可以具有 <code>CSS</code> 属性，使它们经常改变外观、位置或几何显示（如动画），因此浏览器会为它创建一个图层。</p><p>创建图层可以帮助浏览器在网页的整个生命周期中高效地执行绘制操作，比如在滚动或调整浏览器窗口大小的时候。拥有图层还可以帮助浏览器按照开发者的意图，正确地按照堆叠顺序（沿 z 轴）绘制元素。</p><p>现在我们有了图层，我们可以将它们组合起来，并在屏幕上绘制。但是浏览器并不是一次性绘制所有的图层。每个图层都是先单独绘制的。</p><p>在每个图层里面，浏览器会对元素的任何可见属性，如边框、背景色、阴影、文字等进行单独的像素填充。这个过程也被称为栅格化。为了提高性能，浏览器可以使用不同的线程来执行栅格化。</p><p>Photoshop 中图层的类比也可以应用到浏览器渲染网页的方式。您可以从 Chrome DevTools 中看到网页上的不同图层。打开 DevTools，从更多工具选项中选择 “Layers”。您还可以从 “Rendering” 面板中看到图层边框。</p><blockquote><p>栅格化通常是在 CPU 中完成的，这使得它的速度很慢，而且成本很高，但是我们现在有了新的技术，可以在 GPU 中进行性能提升。这篇 <a href="https://software.intel.com/en-us/articles/software-vs-gpu-rasterization-in-chromium">intel 文章</a> 详细介绍了绘画主题，这是一篇必读的文章。要想详细了解图层的概念，<a href="https://www.html5rocks.com/en/tutorials/speed/layers/">这是</a>一篇必读的文章。</p></blockquote><h3 id="合成操作"><a href="#合成操作" class="headerlink" title="合成操作"></a>合成操作</h3><p>到目前为止，我们还没有在屏幕上绘制一个像素。我们拥有的是不同的图层（位图图像），它们应该按照特定的顺序绘制在屏幕上。在合成操作中，这些图层会被发送到 GPU 上，最终将其绘制在屏幕上。</p><p>每次回流（布局）或重绘时都要将整个图层送去绘制，这显然是很低效的。因此，一个图层被分解成不同的块，然后将其绘制在屏幕上。你也可以在 Chrome 的 DevTool Rendering 面板中看到这些块。</p><p>从上面的信息中，我们可以从简单的 HTML 和 CSS 文本内容中，构建出一整个 浏览器从一个网页到在屏幕上渲染出事物所经历的事件顺序。<br><img src="https://i.loli.net/2021/04/19/3QBv7VMJEYdSgef.png" alt="1618750000712.png"></p><p>这个事件顺序也被称为 <strong><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path">关键渲染路径</a></strong></p><blockquote><p><a href="https://twitter.com/kosamari">Mariko Kosaka</a> 为这个流程写了一篇<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">漂亮的文章</a>，有酷炫的插图和对每个概念的更广泛的解释。强烈推荐。</p></blockquote><h3 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h3><p>创建 <code>DOM</code> 树、<code>CSSOM</code> 树和处理渲染逻辑的工作是由一个叫做浏览器引擎（也称为渲染引擎或布局引擎）的浏览器进程来完成的，它位于浏览器内部。这个浏览器引擎包含了，将一个网页从 HTML 代码，渲染到屏幕上的实际像素的，所有必要的元素和逻辑。</p><p>如果你听到人们谈论 WebKit，他们说的是一个浏览器引擎。WebKit 被苹果的 Safari 浏览器使用，也是谷歌 Chrome 浏览器的默认渲染引擎。截至目前， Chromium 项目使用 Blink 作为默认渲染引擎。<a href="https://stackoverflow.com/a/3468311/2790983">这里</a>是一些顶级网络浏览器使用的不同浏览器引擎的列表。</p><h2 id="浏览器的渲染流程"><a href="#浏览器的渲染流程" class="headerlink" title="浏览器的渲染流程"></a>浏览器的渲染流程</h2><p>我们都知道 <code>JavaScript</code> 语言是通过 <code>ECMAScript</code> 标准来实现标准化的，其实由于 <code>JavaScript</code> 被注册为商标，所以我们现在只叫它 <code>ECMAScript</code>。因此，每一个 <code>JavaScript</code> 引擎提供商，如 V8、Chakra、Spider Monkey 等都要遵守这个标准的规则。</p><p>有了标准，我们就可以在所有 JavaScript 运行时，如浏览器、Node、Deno 等，获得一致的 JavaScript 体验。这对于多平台的 JavaScript（和 Web）应用的一致和完美的开发是非常好的。</p><p>然而，浏览器的渲染方式却并非如此。HTML、CSS 或 JavaScript，这些语言都是由某个实体或某个组织标准化的。然而，浏览器如何将它们管理在一起，在屏幕上呈现东西，却不是标准化的。谷歌 Chrome 的浏览器引擎可能会与 Safari 的浏览器引擎做不同的事情。</p><p>因此，很难预测特定浏览器的渲染顺序及其背后的机制。然而，HTML5 规范已经做出了一些努力，在理论上标准化渲染应该如何工作，但浏览器如何遵守这一标准完全取决于它们。</p><p>尽管存在这些不一致的地方，但所有浏览器之间通常都有一些共同的原则。让我们来了解一下浏览器在屏幕上渲染事物的常见方法，以及这个过程的生命周期事件。</p><h3 id="解析和外部资源"><a href="#解析和外部资源" class="headerlink" title="解析和外部资源"></a>解析和外部资源</h3><p>解析是指读取 HTML 内容并从中构建 DOM 树的过程。因此，这个过程也被称为 DOM 解析，完成这个过程的程序被称为 DOM 解析器。</p><p>大多数浏览器都提供了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMParser">DOMParser</a> Web API 来从 HTML 代码中构建 DOM 树。 <code>DOMParser</code> 类的一个实例代表了一个 DOM 解析器，使用 <code>parseFromString</code> 原型方法，我们可以将原始的 HTML 文本（代码）解析成一棵 DOM 树（如下图所示）。<br><img src="https://ftp.bmp.ovh/imgs/2021/04/b22c5a336e8ce5c5.png" alt=""></p><p>当浏览器请求一个网页，服务器响应一些 HTML 文本（Content-Type 头设置为 text/html）时，浏览器可能会在整个文档的几个字符或几行字可用时就开始解析 HTML。因此，浏览器可以逐步建立 DOM 树，一次一个节点。浏览器从上到下解析 HTML，而不是中间的任何地方，因为 HTML 代表了一个嵌套的树状结构。</p><p><img src="https://ftp.bmp.ovh/imgs/2021/04/6536b577a670503c.gif" alt=""></p><p>在上面的例子中，我们从 Node 服务器访问了 <code>incremental.html</code> 文件，并将网络速度设置为只有 <strong>10kbps</strong>（从网络面板）。由于浏览器加载（下载）这个文件需要很长的时间（因为它包含 1000 个 h1 元素），所以浏览器从最初的几个字节构建了一个 DOM 树，并将它们打印在屏幕上（因为它在后台下载 HTML 文件的剩余内容）。</p><p><img src="https://ftp.bmp.ovh/imgs/2021/04/ff674951ed4cf697.png" alt=""></p><p>如果你看一下上面请求的性能图，你就能在 Timing 行看到一些事件。这些事件通常被称为 <strong>性能指标</strong>。当这些事件放在尽可能近的地方，并且尽可能早的发生，用户体验会更好。</p><p><code>FP</code> 是 <code>First Paint</code> 的缩写，意思是浏览器开始在屏幕上打印东西的时间（可以简单到正文背景色的第一个像素）。</p><p><code>FCP</code> 是 <code>First Contentful Paint</code> 的缩写，意思是浏览器渲染出文字或图片等内容的第一个像素的时间。<code>LCP</code> 是 <code>Largest Contentful Paint</code> 的缩写，是指浏览器渲染大块文字或图片的时间。</p><p><code>L</code> 代表 <code>onload</code> 事件，它是由浏览器在 <code>window</code> 对象上发出的。同样，<code>DCL</code> 代表 <code>DOMContentLoaded</code> 事件，它是在 <code>document</code> 对象上发出的，但会冒泡到 <code>window</code> 上，因此你也可以在 <code>window</code> 上监听它。这些事件理解起来有点复杂，所以我们稍后会讨论它们。</p><p>每当浏览器遇到一个外部资源，如通过 <code>&lt;script src=&quot;url&quot;&gt;&lt;/script&gt;</code> 元素的脚本文件（JavaScript）、通过 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;url&quot;/&gt;</code> 标签的样式表文件（CSS）、通过 <code>&lt;img src=&quot;url&quot; /&gt;</code> 元素的图像文件或任何其他外部资源，浏览器将在后台（JavaScript 执行的主线程之外）开始下载该文件。</p><p>最重要的一点是，DOM 解析通常发生在主线程上。因此，如果主 JavaScript 执行线程很忙，DOM 解析将无法进行，直到该线程空闲下来。你可能会问为什么这么重要？因为脚本元素是会阻塞解析器的。除了脚本(.js)文件请求外，每一个外部文件请求，如图片、样式表、pdf、视频等都不会阻塞 DOM 的构建(解析)。</p><h3 id="解析器阻塞型脚本-Parser-Blocking-Scripts"><a href="#解析器阻塞型脚本-Parser-Blocking-Scripts" class="headerlink" title="解析器阻塞型脚本(Parser-Blocking Scripts)"></a>解析器阻塞型脚本(Parser-Blocking Scripts)</h3><p>解析器阻塞型脚本是一个 <code>script</code>（JavaScript）文件/代码，它可以停止对 HTML 的解析。当浏览器遇到一个 <code>script</code> 元素时，如果它是一个嵌入式 <code>script</code>，那么它将首先执行该 <code>script</code>，然后继续解析 HTML，构建 DOM 树。所以所有的嵌入式 <code>script</code>都是解析器阻塞型的，讨论结束。</p><p>如果 <code>script</code> 元素是外部 <code>script</code> 文件，浏览器会在主线程之外开始下载外部 <code>script</code> 文件，但在该文件下载完毕之前，会停止主线程的执行。这意味着在 <code>script</code> 文件下载之前，不会再进行 DOM 解析。</p><p>一旦 <code>script</code> 文件下载完毕，浏览器将首先在主线程上执行下载好的 <code>script</code> 文件，然后继续进行 DOM 解析。如果浏览器再次发现 HTML 中的其他 <code>script</code> 元素，就会执行同样的操作。那么为什么浏览器要停止 DOM 解析，直到 JavaScript 被下载并执行？</p><p>浏览器将 DOM API 暴露给 JavaScript 运行时，这意味着我们可以从 JavaScript 中访问和操作 DOM 元素。这就是 React 和 Angular 等动态 Web 框架的工作方式。但如果浏览器希望并行运行 DOM 解析和 <code>script</code> 执行，那么 DOM 解析线程和主线程之间可能会出现<a href="https://stackoverflow.com/questions/34510/what-is-a-race-condition"><strong>竞赛条件</strong></a>，这就是为什么 DOM 解析必须在主线程上进行。</p><p>然而，在后台下载 <code>script</code> 文件时停止 DOM 解析，在大多数情况下是完全没有必要的。因此，HTML5 为我们提供了 <code>script</code> 标签的 <code>async</code> 属性。当 <code>DOM</code> 解析器遇到一个带有 <code>async</code> 属性的外部 <code>script</code> 元素时，它不会在后台下载 <code>script</code> 文件时停止解析过程。但是一旦文件下载完毕，解析过程就会停止，<code>script</code>（代码）就会被执行。</p><p>我们还为 <code>script</code> 元素设置了一个神奇的 <code>defer</code> 属性，它的工作原理与 <code>async</code> 属性类似，但与 <code>async</code> 属性不同的是，即使文件完全下载完毕，<code>script</code> 也不会执行。一旦解析器解析了所有的 HTML，也就是说 DOM 树已经完全构建完成，所有的 <code>defer</code> <code>script</code>就会被执行。与异步 <code>script</code> 不同的是，所有的延迟 <code>script</code> 是按照它们在 HTML 文档（或 DOM 树）中出现的顺序来执行的。</p><p>所有普通的 <code>script</code>（嵌入式或外部）都是解析器阻塞型的，因为它们停止了 DOM 的构建。所有异步 <code>script</code> 在下载之前不会阻塞解析器。一旦一个异步 <code>script</code> 被下载，它就变成了阻断解析器的 <code>script</code>。然而，所有的 <code>defer</code> 脚本都是非阻断解析器型的脚本，因为它们不阻断解析器，并且在 DOM 树完全构建完成后执行。<br><img src="https://ae01.alicdn.com/kf/U798f6fa385254155a4e7105fbc84894a9.jpg" alt=""></p><p>在上面的例子中，parser-blocking.html 文件在 30 个元素后包含了一个阻塞解析的脚本，这就是为什么浏览器一开始显示 30 个元素，停止 DOM 解析，并开始加载脚本文件的原因。第二个脚本文件由于有 defer 属性，所以不会阻止解析，所以一旦 DOM 树完全构建完成，它就会执行。<br><img src="https://ae01.alicdn.com/kf/Uc714a2f94cfa4ff49431509a91bcab5aY.jpg" alt=""></p><p>如果我们看一下 <strong>Performance</strong> 面板，<code>FP</code> 和 <code>FCP</code> 会尽快发生（隐藏在 <strong>Timings</strong> 标签后面），因为浏览器一有 HTML 内容就开始建立 DOM 树，因此可以在屏幕上渲染一些像素。</p><p><code>LCP</code> 发生在 5 秒后，因为阻塞解析器的脚本已经阻断了 5 秒的 DOM 解析（它的下载时间），当 DOM 解析器被阻断时，屏幕上只呈现了 30 个文本元素，这不足以被称为最大的内容绘制（根据 Google Chrome 标准）。但是一旦下载并执行该脚本，DOM 解析就恢复了，并且在屏幕上呈现了大量的内容，这导致了 LCP 事件的触发。</p><blockquote><p>Parser-blocking 也被称为 render-blocking，因为除非 DOM 树被构造出来，否则渲染是不会发生的，但这两者是完全不同的事情，我们稍后会看到</p></blockquote><p>一些浏览器可能会包含一个<a href="https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing">推测性解析</a>策略，即 HTML 解析（但不包括 DOM 树的构建）被挂载到一个单独的线程中，这样浏览器就可以读取链接（CSS）、script、img 等元素，并更早地下载这些资源。</p><p>这对于以下这种情况来说是很有用的，比如你有三个紧贴的 <code>script</code> 元素，但由于 DOM 解析器无法读取第二个 <code>script</code> 元素，所以在第一个 <code>script</code> 下载完毕之前，浏览器无法开始下载第二个 <code>script</code>。我们可以通过使用 <code>async</code> 标签轻松解决这个问题，但是异步脚本不能保证按顺序执行。</p><p>之所以叫推测性解析，是因为浏览器在做一个推测，预计未来会加载某个资源，所以最好现在就在后台加载。但是，如果某些 JavaScript 操作 DOM，或用外部资源删除/隐藏元素，那么推测就失败了，这些文件就白白加载了。</p><blockquote><p>每个浏览器都有自己的规范，所以不能保证何时或是否会发生推测性解析。不过，你可以使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 元素要求浏览器提前加载一些资源。</p></blockquote><h3 id="渲染阻塞型-CSS"><a href="#渲染阻塞型-CSS" class="headerlink" title="渲染阻塞型 CSS"></a>渲染阻塞型 CSS</h3><p>正如我们所了解到的，除了阻塞解析器的 <code>script</code> 文件外，任何外部资源请求都不会阻塞 DOM 解析过程。因此，CSS（包括嵌入式）不会直接阻塞 DOM 解析器。等等，是的，CSS 可以阻止 DOM 解析，但在此之前，我们需要了解渲染过程。</p><p>浏览器内部的浏览器引擎使用从服务器接收到的 HTML 内容作为文本文档来构建 DOM 树。同样，它也会根据外部 CSS 文件或 HTML 中嵌入（以及内联）的 CSS 样式表内容来构建 CSSOM 树。</p><p>DOM 和 CSSOM 树的构建都发生在主线程上，而且这些树的构建是<strong>同时</strong>进行的。它们共同构成了用于在屏幕上打印东西的 Render Tree，而 Render Tree 也随着 DOM 树的构建而逐步构建。</p><p>我们已经了解到，DOM 树的生成是增量的，这意味着当浏览器读取 HTML 时，它会将 DOM 元素添加到 DOM 树中。但 CSSOM 树却不是这样。与 DOM 树不同，CSSOM 树的构建不是递增的，必须以特定的方式进行。</p><p>当浏览器找到 <code>&lt;style&gt;</code> 块时，它会解析所有嵌入的 CSS，并以新的 CSS （样式）规则更新 CSSOM 树。之后，它将继续以正常方式解析 HTML。内联样式也是如此。</p><p>然而，当浏览器遇到一个外部样式表文件时，事情就会发生巨大的变化。与外部 <code>script</code> 文件不同的是，外部样式表文件不是解析器阻塞型的资源，因此浏览器可以在后台静默地下载它，DOM 解析也会继续进行。</p><p>但与 HTML 文件（用于 DOM 构建）不同，浏览器不会一个字节一个字节地处理样式表文件内容。这是因为浏览器在读取 CSS 内容时，不能增量地构建 CSSOM 树。原因是，文件最后的 CSS 规则可能会覆盖写在文件顶部的 CSS 规则。</p><p>因此，如果浏览器在解析样式表内容时开始递增地构建 CSSOM，就会导致渲染树的多次渲染，因为样式覆盖规则会使同样的 CSSOM 节点，因后面新出现的样式表文件而导致更新。当 CSS 被解析时，可以在屏幕上看到元素样式的改变，这将是一种不愉快的用户体验。由于 CSS 样式是层叠的，一个规则的改变可能会影响许多元素。</p><p>因此，浏览器不会逐步处理外部 CSS 文件，CSSOM 树更新是在样式表中所有 CSS 规则处理完毕后一次性完成的。CSSOM 树更新完成后，再更新渲染树，然后渲染到屏幕上。</p><p>CSS 是一种渲染阻塞型资源。一旦浏览器提出获取外部样式表的请求，Render Tree 的构建就会停止。因此，<strong>关键渲染路径</strong>（CRP）也被卡住了，没有任何东西被渲染到屏幕上，如下图所示。然而，在后台下载样式表时，DOM 树的构建仍在进行中。</p><p><img src="https://ae01.alicdn.com/kf/Uf2fb7434f9144281885b7b7b71cf9fe2P.jpg" alt=""></p><p>浏览器可以使用 CSSOM 树的旧状态来生成 Render Tree，因为 HTML 正在被解析，以递增的方式在屏幕上呈现事物。但这有一个巨大的缺点。在这种情况下，一旦样式表被下载和解析，CSSOM 被更新，Render Tree 就会被更新并呈现在屏幕上。现在，用旧 CSSOM 生成的 Render Tree 节点将重绘新的样式，这也可能导致 Flash of Unstyled Content (FOUC)，这对用户体验非常不利。</p><p>因此，浏览器会等到样式表被加载和解析。一旦样式表被解析，CSSOM 被更新，Render Tree 就会被更新，CRP 就会继续进行，从而使 Render Tree 绘制在屏幕上。由于这个原因，建议尽早加载所有外部样式表。</p><p>让我们想象一下这样一个场景：浏览器已经开始解析 HTML，并且遇到了一个外部样式表文件。它将在后台开始下载文件，阻塞 CRP，并继续进行 DOM 解析。但是它又遇到了一个 <code>script</code> 标签，于是它就会在后台开始下载外部脚本文件，并阻止 DOM 解析。现在浏览器是坐等样式表和脚本文件完全下载完毕。</p><p>但这次外部脚本文件已经完全下载完毕，而样式表还在后台下载。浏览器要不要执行这个脚本文件？这样做有什么危害吗？</p><p>我们知道，CSSOM 提供了一个高级的 JavaScript API 来与 DOM 元素的样式进行交互。例如，你可以使用 <code>elem.style.backgroundColor</code> 属性来读取或更新一个 DOM 元素的背景颜色。与 <code>elem</code> 元素相关联的样式对象暴露了 CSSOM 的 API，还有很多其他的 API 可以做同样的事情（请阅读这篇 <a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/">css-tricks</a> 文章）。</p><p>当一个样式表被后台下载时，JavaScript 仍然可以执行，因为主线程没有被加载的样式表所阻挡。如果我们的 JavaScript 程序访问 DOM 元素的 CSS 属性（通过 CSSOM API），我们会得到一个合适的值（根据 CSSOM 的当前状态）。</p><p>但是一旦样式表被下载和解析，导致 CSSOM 更新，我们的 JavaScript 现在有一个过时的元素的 CSS 值，因为新的 CSSOM 更新可能已经改变了该 DOM 元素的 CSS 属性。由于这个原因，在下载样式表的时候执行 JavaScript 是不安全的。</p><p>根据 <a href="https://html.spec.whatwg.org/multipage/semantics.html#interactions-of-styling-and-scripting">HTML5 规范</a>，浏览器可以下载一个脚本文件，但不会执行它，除非之前所有的样式表都被解析了。当一个样式表阻止脚本的执行时，它被称为脚本阻塞型样式表(script-blocking stylesheet)或脚本阻塞型 CSS(script-blocking CSS)。</p><p><img src="https://ae01.alicdn.com/kf/U327ac1fe038246be86df228eb65080e5r.jpg" alt=""></p><p>在上面的例子中，script-blocking.html 包含了一个 <code>link</code> 标签（用于外部的样式表），后面是一个 <code>script</code> 标签（用于外部 JavaScript）。这里的 <code>script</code> 下载速度非常快，没有任何延迟，但样式表需要 6 秒才能下载完。因此，尽管我们可以从网络面板上看到，脚本已经完全下载，但浏览器并没有立即执行。只有在样式表加载后，我们看到脚本打印的 <code>Hello World</code> 消息。</p><blockquote><p>就像 <code>async</code> 或 <code>defer</code> 属性使 <code>script</code> 元素<strong>不阻塞解析</strong>一样，外部的样式表也可以通过 <code>media</code> 属性使其<strong>不阻塞渲染</strong>。使用 <code>media</code> 属性值，浏览器可以智能地决定何时去加载样式表</p></blockquote><h3 id="文档的-DOMContentLoader-事件"><a href="#文档的-DOMContentLoader-事件" class="headerlink" title="文档的 DOMContentLoader 事件"></a>文档的 DOMContentLoader 事件</h3><p><code>DOMContentLoaded</code>(DCL)事件标志着，浏览器从所有可用的 HTML 中，构建出了一个完整的 DOM 树的时间点。但 DCL 事件被触发时，有很多涉及到的因素会发生变化。</p><pre><code class="js">document.addEventListener(&quot;DOMContentLoaded&quot;, function (e) &#123;  console.log(&quot;DOM is fully parsed!&quot;);&#125;);</code></pre><p>如果我们的 HTML 中不包含任何脚本，DOM 解析就不会被阻塞，DCL 就会随着浏览器解析完整个 HTML 而触发。如果我们有解析器阻塞型脚本，那么 DCL 必须等待所有解析器阻塞型脚本被下载并执行。</p><p>当样式表被扔进页面时，事情就变得有点复杂了。即使你没有外部脚本，DCL 也会等到所有样式表被加载。因 DCL 标志着整个 DOM 树已经准备好的时间点，但是在 CSSOM 也被完全构建之前，访问 DOM 都是不太安全的（对于样式信息）。因此，大多数浏览器都会等到所有外部样式表被加载和解析。</p><p>脚本阻塞型样式表显然会延迟 DCL。在这种情况下，由于脚本在等待样式表的加载，DOM 树没有被构造出来。</p><p>DCL 是网站性能指标之一。我们应该优化 DCL，使其尽可能的小（发生的时间）。其中一个最好的做法是尽可能地使用 <code>defer</code> 和 <code>async</code> 标签来处理 <code>script</code> 元素，这样当脚本在后台下载时，浏览器可以执行其他事情。其次，我们应该优化脚本阻塞型和渲染阻塞型的样式表。</p><h3 id="窗口的-load-事件"><a href="#窗口的-load-事件" class="headerlink" title="窗口的 load 事件"></a>窗口的 <code>load</code> 事件</h3><p>我们知道 JavaScript 可以阻止 DOM 树的生成，但是对于外部的样式表和文件，如图片、视频等就不是这样了。</p><p><code>DOMContentLoaded</code> 事件标志着 DOM 树已经完全构造完成，可以安全访问，<code>window.onload</code> 事件标志着外部样式表和文件下载完毕，我们的 Web 应用已经完成下载的时间点。</p><pre><code class="js">window.addEventListener(&quot;load&quot;, function (e) &#123;  console.log(&quot;Page is fully loaded!&quot;);&#125;);</code></pre><p><img src="https://i.loli.net/2021/04/19/Jw4bepLi73yxYqP.png" alt="1618839528167.png"></p><p>在上面的例子中，rendering.html 文件的头部有一个外部样式表，下载时间大约为 5 秒。由于它在头部部分，<code>FP</code> 和 <code>FCP</code> 发生在 5 秒之后，因为样式表会阻止它下面的任何内容的渲染（也就是它阻止了 CRP）。</p><p>在这之后，我们有一个 <code>img</code> 元素，加载一个需要 10 秒左右下载的图片。所以浏览器会在后台一直下载这个文件，然后继续进行 DOM 的解析和渲染（因为外部图片资源既不阻挡解析器，也不阻挡渲染）。</p><p>接下来，我们有三个外部 JavaScript 文件，它们的下载时间分别为 3s、6s 和 9s，最重要的是，它们不是异步的。这意味着总的加载时间应该接近 18 秒，因为在前一个脚本执行之前，后续的脚本不会开始下载。然而，从 DCL 事件来看，我们的浏览器似乎采用了推测性策略，预先下载脚本文件，所以总加载时间接近 9 秒。</p><p>由于能够影响 DCL 的最后一个下载的文件是最后一个脚本文件，加载时间为 9 秒（因为样式表已经在 5 秒内下载完毕），所以 DCL 事件发生在 9.1 秒左右。</p><p>我们还有一个外部资源是图片文件，它一直在后台加载。当它完全下载完毕后（需要 10 秒），窗口的 <code>load</code> 事件在 10.2 秒后被启动，这标志着网页（应用程序）已经完全加载完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自 Uday Hiwarale 的 &lt;a href=&quot;https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969&quot;&gt;How the browser renders a web page? — DOM, CSSOM, and Rendering&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当你开发一个网站的时候，有些东西对于良好的用户体验来说是非常必要的。网站可能遇到的一些常见问题可能是资源加载缓慢，在初始渲染时等待不必要的文件下载，样式未应用的内容闪烁 &lt;code&gt;(flash of unstyled content (FOUC))&lt;/code&gt;等。为了避免类似问题，我们需要了解浏览器渲染典型网页的生命周期。&lt;/p&gt;
&lt;p&gt;首先，我们需要了解什么是 &lt;code&gt;DOM&lt;/code&gt;。当浏览器相服务器发送请求，获取一个 &lt;code&gt;HTML&lt;/code&gt; 文档的时候，服务器会返回一个二进制流格式的 &lt;code&gt;HTML&lt;/code&gt; 页面，它基本就是一个文本文件，其响应头的 &lt;code&gt;Content-Type&lt;/code&gt; 设置为 &lt;code&gt;text/html;charset-UTF-8&lt;/code&gt;。这里的 &lt;code&gt;text/html&lt;/code&gt; ·是一个 &lt;a href=&quot;https://en.wikipedia.org/wiki/Media_type&quot;&gt;MIME 类型&lt;/a&gt;，它告诉浏览器这是一个 &lt;code&gt;HTML&lt;/code&gt; 文档，&lt;code&gt;charset=UTF-8&lt;/code&gt; 告诉浏览器它是以 &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; 字符&lt;a href=&quot;https://medium.com/jspoint/introduction-to-character-encoding-3b9735f265a6&quot;&gt;编码&lt;/a&gt;的。利用这些信息，浏览器剋将二进制格式转换为可读的文本文件。如下图所示。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/04/17/c1MpWG2FosgNrhl.png&quot; alt=&quot;1_Tm-HPhmGA0BL7HIj38H8Qw.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果该 &lt;code&gt;header&lt;/code&gt; 缺失，浏览器将无法理解如何处理该文件，它将以纯文本格式呈现。但如果一切正常，经过这次转换后，浏览器就可以开始阅读 &lt;code&gt;HTML&lt;/code&gt; 文档了。一个典型的 &lt;code&gt;HTML&lt;/code&gt; 文档大致如下:&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器" scheme="https://kerbalhao.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从输入 URL 地址到看到页面，HTTP 应用层都经历了什么</title>
    <link href="https://kerbalhao.github.io/2021/03/22/%E5%9F%BA%E4%BA%8EHTTP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://kerbalhao.github.io/2021/03/22/%E5%9F%BA%E4%BA%8EHTTP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-03-22T11:48:48.000Z</published>
    <updated>2022-07-04T16:59:21.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从输入-URL-地址到看到页面，HTTP-应用层都经历了什么"><a href="#从输入-URL-地址到看到页面，HTTP-应用层都经历了什么" class="headerlink" title="从输入 URL 地址到看到页面，HTTP 应用层都经历了什么"></a>从输入 URL 地址到看到页面，HTTP 应用层都经历了什么</h2><h3 id="1-url-解析"><a href="#1-url-解析" class="headerlink" title="1. url 解析"></a>1. url 解析</h3><h4 id="url-会包含这些东西："><a href="#url-会包含这些东西：" class="headerlink" title="url 会包含这些东西："></a>url 会包含这些东西：</h4><p>一个 url 会类似这种： <a href="https://asdbc.com:443/index.html?key=value#anchor">https://asdbc.com:443/index.html?key=value#anchor</a><br>对上述的 url 进行解释：协议//域名（服务器地址）：端口号/请求资源的文件路径/?查询字符(key)=值(value)#片段标识符</p><h4 id="url-编码"><a href="#url-编码" class="headerlink" title="url 编码"></a>url 编码</h4><p>根据规定，只有字母和数字 <code>[0-9a-zA-Z]</code>、一些特殊符号”$-_.+!*‘(),”<code>[不包括双引号]</code>、以及某些保留字，才可以不经过编码直接用于 URL。因此，我们需要对 url 进行编码。</p><ul><li>encodeURI(url):它着眼于对整个 URL 进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码。</li><li>encodeURIComponent(url):与 encodeURI()的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个 URL 进行编码。因此，”; / ? : @ &amp; = + $ , #”，这些在 encodeURI()中不被编码的符号，在 encodeURIComponent()中统统会被编码。<span id="more"></span></li></ul><h3 id="2-缓存检查"><a href="#2-缓存检查" class="headerlink" title="2. 缓存检查"></a>2. 缓存检查</h3><ul><li>在解析 DNS 之前，会先判断是否存在强缓存</li><li>若命中则直接返回缓存内容，</li><li>若无则进行正常流程，进行 DNS 解析，建立 TCP 连接，发送 HTTP 请求</li><li>发送请求时回去验证协商缓存，若命中则返回 304，拿取缓存资源</li></ul><h4 id="强缓存（强缓存命中后是不会发送-http-请求的）"><a href="#强缓存（强缓存命中后是不会发送-http-请求的）" class="headerlink" title="强缓存（强缓存命中后是不会发送 http 请求的）"></a>强缓存（强缓存命中后是不会发送 http 请求的）</h4><h5 id="浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的"><a href="#浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的" class="headerlink" title="浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的"></a>浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的</h5><ul><li>Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1.0）</li><li>Cache-Control：cache-control: max-age=2592000 第一次拿到资源后的 2592000 秒内（30 天），再次发送请求，读取缓存中的信息（HTTP/1.1）</li><li>两者同时存在的话，Cache-Control 优先级高于 Expires</li></ul><p><a href="https://imgtu.com/i/6oQLE6"><img src="https://z3.ax1x.com/2021/03/22/6oQLE6.png" alt="强缓存.png"></a></p><h5 id="强缓存问题："><a href="#强缓存问题：" class="headerlink" title="强缓存问题："></a>强缓存问题：</h5><ol><li>服务器文件更新，但本地有缓存，则无法拿到最新文件</li><li>HTML 文件一般不做强缓存</li></ol><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><ol><li>服务器更新资源后，让资源名称变更，这样页面将导入全新的资源（webpack 打包文件带 hash 值）</li><li>当文件更新后，在 Html 导入时，设置一个后缀（时间戳）</li></ol><h4 id="协商缓存-Last-Modified-ETag"><a href="#协商缓存-Last-Modified-ETag" class="headerlink" title="协商缓存 Last-Modified / ETag"></a>协商缓存 Last-Modified / ETag</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</p><p><a href="https://imgtu.com/i/6olhZt"><img src="https://z3.ax1x.com/2021/03/22/6olhZt.png" alt="协商缓存.png"></a></p><h5 id="协商缓存流程："><a href="#协商缓存流程：" class="headerlink" title="协商缓存流程："></a>协商缓存流程：</h5><ol><li><p>第一次向服务器发送请求</p><ol><li>没有协商缓存，向服务器发送请求（未传递任何标识）<ul><li>服务请收到请求准备内容</li><li>Last-Modified：资源文件最后更新的时间</li><li>ETag：记录的是一个标识（即根据资源文件更新生成的，每次资源更新都会重新生成一个）</li></ul></li><li>客户端拿到信息后渲染，将信息和标识缓存到本地</li></ol></li><li><p>第二次发请求</p><ol><li>客户端发送 If-Modified-Since 与 If-None-Match<ul><li>If-Modified-Since 对应 Last-Modified 值</li><li>If-None-Match 对应 ETag 值</li></ul></li><li>发送给服务器</li><li>服务器根据标识判断文件是否更新</li></ol></li></ol><h5 id="Last-Modified-与-ETag-区别"><a href="#Last-Modified-与-ETag-区别" class="headerlink" title="Last-Modified 与 ETag 区别"></a>Last-Modified 与 ETag 区别</h5><p>Last-Modified 只能精确到秒，而 ETag 只要有改变就会重新生成</p><h5 id="强缓存和协商好缓存一般只应用于静态资源文件"><a href="#强缓存和协商好缓存一般只应用于静态资源文件" class="headerlink" title="强缓存和协商好缓存一般只应用于静态资源文件"></a>强缓存和协商好缓存一般只应用于静态资源文件</h5><h5 id="数据的缓存，一般由我们自己保存到客户端存储中，根据自己设置的过期时间判断是否需要更新"><a href="#数据的缓存，一般由我们自己保存到客户端存储中，根据自己设置的过期时间判断是否需要更新" class="headerlink" title="数据的缓存，一般由我们自己保存到客户端存储中，根据自己设置的过期时间判断是否需要更新"></a>数据的缓存，一般由我们自己保存到客户端存储中，根据自己设置的过期时间判断是否需要更新</h5><h5 id="协商缓存与强缓存区别："><a href="#协商缓存与强缓存区别：" class="headerlink" title="协商缓存与强缓存区别："></a>协商缓存与强缓存区别：</h5><ul><li>协商缓存总会和服务器协商，所以一定会发 http 请求</li></ul><h3 id="3-DNS-解析"><a href="#3-DNS-解析" class="headerlink" title="3. DNS 解析"></a>3. DNS 解析</h3><p>我们需要对 dns 进行解析才能找到域名对应的 ip 地址，但是 dns 解析也是一个耗时的操作，好在我们也存在 dns 缓存</p><p>对 DNS 缓存进行查询的时候，我们会按照 客户端 =&gt; 浏览器缓存 =&gt; 本地的 hosts 文件 =&gt; 本地 DNS 解析器缓存 =&gt; 本地 DNS 服务器 的方式进行迭代查询</p><p>若无法命中对应的 DNS 缓存，我们就需要对 DNS 服务器进行递归查询了</p><h4 id="优化-DNS-解析过程："><a href="#优化-DNS-解析过程：" class="headerlink" title="优化 DNS 解析过程："></a>优化 DNS 解析过程：</h4><ol><li><p>减少 DNS 请求，一个页面尽可能少用不同的域名，资源都放在相同的服务器中（很少用，因为资源存放的服务器很多，不同服务器压力不同）</p></li><li><p>使用 link 标签实现 dns 预解析：</p><pre><code class="html">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;&lt;url&gt;&quot; /&gt;</code></pre></li></ol><h4 id="服务器拆分优势："><a href="#服务器拆分优势：" class="headerlink" title="服务器拆分优势："></a>服务器拆分优势：</h4><ul><li>资源的合理利用</li><li>抗压能力加强</li><li>提高 HTTP 并发、</li></ul><h3 id="4-TCP-三次握手"><a href="#4-TCP-三次握手" class="headerlink" title="4. TCP 三次握手"></a>4. TCP 三次握手</h3><h4 id="TCP-名词介绍："><a href="#TCP-名词介绍：" class="headerlink" title="TCP 名词介绍："></a>TCP 名词介绍：</h4><ul><li>seq 序号，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记</li><li>ack 确认序号，只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1</li><li>标志位<ul><li>ACK：确认序号有效</li><li>RST：重置连接</li><li>SYN：发起一个新连接</li><li>FIN：释放一个连接</li></ul></li></ul><p><a href="https://imgtu.com/i/6oGQlF"><img src="https://z3.ax1x.com/2021/03/22/6oGQlF.png" alt="三次握手.png"></a></p><h4 id="三次握手为什么不用两次，或者四次"><a href="#三次握手为什么不用两次，或者四次" class="headerlink" title="三次握手为什么不用两次，或者四次?"></a>三次握手为什么不用两次，或者四次?</h4><ul><li>TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率！</li><li>我们可以模拟一下三次握手客户端和服务端的应答：<ul><li>客户端：你好（发送后等待服务端应答，确定服务端可以接收和发送数据）</li><li>服务端：你好（发送后等待客户端应答，确定客户端可以接受到数据）</li><li>客户端： 我要发信息了（发送后，双方已经确定对方能够正常收发数据，连接成功建立）</li></ul></li><li>因此，两次握手无法判断客户端可以正常接收到数据，而四次握手则会浪费资源</li></ul><h3 id="5-数据传输"><a href="#5-数据传输" class="headerlink" title="5. 数据传输"></a>5. 数据传输</h3><h4 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h4><p>发送请求报文</p><h4 id="HTTP-请求返回"><a href="#HTTP-请求返回" class="headerlink" title="HTTP 请求返回"></a>HTTP 请求返回</h4><p>返回 HTTP 响应</p><h4 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h4><ul><li>200 OK</li><li>202 Accepted ：服务器已接受请求，但尚未处理（异步）</li><li>204 No Content：服务器成功处理了请求，但不需要返回任何实体内容</li><li>206 Partial Content：服务器已经成功处理了部分 GET 请求（断点续传 Range/If-Range/Content-Range/Content-Type:”multipart/byteranges”/Content-Length….）</li><li>301 Moved Permanently</li><li>302 Move Temporarily</li><li>304 Not Modified</li><li>305 Use Proxy</li><li>400 Bad Request : 请求参数有误</li><li>401 Unauthorized：权限（Authorization）</li><li>404 Not Found</li><li>405 Method Not Allowed</li><li>408 Request Timeout</li><li>500 Internal Server Error</li><li>503 Service Unavailable</li><li>505 HTTP Version Not Supported</li></ul><h3 id="6-TCP-四次挥手"><a href="#6-TCP-四次挥手" class="headerlink" title="6. TCP 四次挥手"></a>6. TCP 四次挥手</h3><p><a href="https://imgtu.com/i/6oUeRP"><img src="https://z3.ax1x.com/2021/03/22/6oUeRP.png" alt="四次挥手.png"></a></p><h4 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4><ul><li>服务器端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文</li><li>但关闭连接时，当服务器端收到 FIN 报文时，很可能并不会立即关闭链接，所以只能先回复一个 ACK 报文，告诉客户端：“你发的 FIN 报文我收到了”，只有等到服务器端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要四步握手。</li></ul><h2 id="HTTP1-0-1-1-2-区别"><a href="#HTTP1-0-1-1-2-区别" class="headerlink" title="HTTP1.0/1.1/2 区别"></a>HTTP1.0/1.1/2 区别</h2><h3 id="HTTP-1-0-与-1-1-的一些区别"><a href="#HTTP-1-0-与-1-1-的一些区别" class="headerlink" title="HTTP 1.0 与 1.1 的一些区别"></a>HTTP 1.0 与 1.1 的一些区别</h3><ul><li>缓存处理，HTTP1.0 中主要使用 Last-Modified，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略：ETag，Cache-Control…</li><li>带宽优化及网络连接的使用，HTTP1.1 支持断点续传，即返回码是 206（Partial Content）</li><li>错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除…</li><li>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）</li><li>长连接，HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点</li></ul><h3 id="HTTP2-0-和-HTTP1-X-相比的新特性"><a href="#HTTP2-0-和-HTTP1-X-相比的新特性" class="headerlink" title="HTTP2.0 和 HTTP1.X 相比的新特性"></a>HTTP2.0 和 HTTP1.X 相比的新特性</h3><ul><li>新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合，基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮</li><li>header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小</li><li>服务端推送（server push），例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了<pre><code class="js">// 通过在应用生成HTTP响应头信息中设置Link命令Link: &lt;/styles.css&gt;; rel=preload; as=style, &lt;/example.png&gt;; rel=preload; as=image</code></pre></li><li>多路复用（MultiPlexing）<ul><li>HTTP/1.0 每次请求响应，建立一个 TCP 连接，用完关闭</li><li>HTTP/1.1 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li><li>HTTP/2.0 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>利用缓存<ul><li>对于静态资源文件实现强缓存和协商缓存（扩展：文件有更新，如何保证及时刷新？）</li><li>对于不经常更新的接口数据采用本地存储做数据缓存（扩展：cookie / localStorage / vuex|redux 区别？）</li></ul></li><li>DNS 优化<ul><li>分服务器部署，增加 HTTP 并发性（导致 DNS 解析变慢）</li><li>DNS Prefetch</li></ul></li><li>TCP 的三次握手和四次挥手</li></ol><ul><li>利用 Connection:keep-alive 来避免频繁开关 TCP 连接</li></ul><ol start="4"><li>数据传输 - 减少数据传输的大小 - 内容或者数据压缩（webpack 等） - 服务器端一定要开启 GZIP 压缩（一般能压缩 60%左右） - 大批量数据分批次请求（例如：下拉刷新或者分页，保证首次加载请求数据少） - 减少 HTTP 请求的次数 - 资源文件合并处理 - 字体图标 - 雪碧图 CSS-Sprit - 图片的 BASE64<br>……</li><li>CDN 服务器“地域分布式”</li><li>采用 HTTP2.0</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从输入-URL-地址到看到页面，HTTP-应用层都经历了什么&quot;&gt;&lt;a href=&quot;#从输入-URL-地址到看到页面，HTTP-应用层都经历了什么&quot; class=&quot;headerlink&quot; title=&quot;从输入 URL 地址到看到页面，HTTP 应用层都经历了什么&quot;&gt;&lt;/a&gt;从输入 URL 地址到看到页面，HTTP 应用层都经历了什么&lt;/h2&gt;&lt;h3 id=&quot;1-url-解析&quot;&gt;&lt;a href=&quot;#1-url-解析&quot; class=&quot;headerlink&quot; title=&quot;1. url 解析&quot;&gt;&lt;/a&gt;1. url 解析&lt;/h3&gt;&lt;h4 id=&quot;url-会包含这些东西：&quot;&gt;&lt;a href=&quot;#url-会包含这些东西：&quot; class=&quot;headerlink&quot; title=&quot;url 会包含这些东西：&quot;&gt;&lt;/a&gt;url 会包含这些东西：&lt;/h4&gt;&lt;p&gt;一个 url 会类似这种： &lt;a href=&quot;https://asdbc.com:443/index.html?key=value#anchor&quot;&gt;https://asdbc.com:443/index.html?key=value#anchor&lt;/a&gt;&lt;br&gt;对上述的 url 进行解释：协议//域名（服务器地址）：端口号/请求资源的文件路径/?查询字符(key)=值(value)#片段标识符&lt;/p&gt;
&lt;h4 id=&quot;url-编码&quot;&gt;&lt;a href=&quot;#url-编码&quot; class=&quot;headerlink&quot; title=&quot;url 编码&quot;&gt;&lt;/a&gt;url 编码&lt;/h4&gt;&lt;p&gt;根据规定，只有字母和数字 &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;、一些特殊符号”$-_.+!*‘(),”&lt;code&gt;[不包括双引号]&lt;/code&gt;、以及某些保留字，才可以不经过编码直接用于 URL。因此，我们需要对 url 进行编码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;encodeURI(url):它着眼于对整个 URL 进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp;amp; = + $ , #”，也不进行编码。&lt;/li&gt;
&lt;li&gt;encodeURIComponent(url):与 encodeURI()的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个 URL 进行编码。因此，”; / ? : @ &amp;amp; = + $ , #”，这些在 encodeURI()中不被编码的符号，在 encodeURIComponent()中统统会被编码。
    
    </summary>
    
    
      <category term="HTTP" scheme="https://kerbalhao.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://kerbalhao.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="https://kerbalhao.github.io/2021/01/09/%E6%89%8B%E5%86%99%20promise/"/>
    <id>https://kerbalhao.github.io/2021/01/09/%E6%89%8B%E5%86%99%20promise/</id>
    <published>2021-01-09T11:48:48.000Z</published>
    <updated>2022-07-05T02:12:38.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="极简版"><a href="#极简版" class="headerlink" title="极简版"></a>极简版</h2><pre><code class="js">// 常量const PENDING = &quot;pending&quot;, // 待定  FULFILLED = &quot;fulfilled&quot;, // 成功  REJECTED = &quot;rejected&quot;; // 失败class MyPromise &#123;  constructor(executor) &#123;    this.state = PENDING; // promise 的初始状态    this.value = undefined; // resolve后获得的值    this.reason = undefined; // reject 后获得的值    // executor 的函数参数，将 state 转为 fulfilled    let resolve = (value) =&gt; &#123;      if (this.state === PENDING) &#123;        this.state = FULFILLED;        this.value = value;      &#125;    &#125;;    // executor 的函数参数，将 state 转为 rejected    let reject = (reason) =&gt; &#123;      if (this.state === PENDING) &#123;        this.state = REJECTED;        this.reason = reason;      &#125;    &#125;;    // 执行 executor    try &#123;      executor(resolve, reject);    &#125; catch (e) &#123;      // 报错则直接将 promise 置为 rejected      reject(e);    &#125;  &#125;  // 重头戏  then(onFulfilled, onRejected) &#123;    if (this.state === FULFILLED) &#123;      onFulfilled(this.value);    &#125; else if (this.state === REJECTED) &#123;      onRejected(this.reason);    &#125;  &#125;&#125;</code></pre><span id="more"></span><p>以上代码实现了同步情况下的 promise 我们可以看一下以下的测试代码</p><pre><code class="js">// 测试// 同步let promise = new MyPromise((resolve, reject) =&gt; &#123;  resolve(100);&#125;);promise.then((val) =&gt; &#123;  console.log(val);&#125;);// 结果 : 100// 异步let promise1 = new MyPromise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    // setTimeout 异步执行，执行到 then 的时候， promise 中的 value 尚未得到    resolve(100);    console.log(&quot;didResolve&quot;);  &#125;, 0);&#125;);promise1.then((val) =&gt; &#123;  console.log(val); // undefined&#125;);// 结果： undefined -&gt; didResolve</code></pre><p>通过以上测试代码，我们可以知道，我们定义的 <code>MyPromise</code> 目前只能处理同步的情况。当遇到异步(上述的 <code>setTimeout</code> 宏任务)的时候，会先执行同步代码，即先执行 <code>then()</code> 方法，此时的 <code>val</code> 为 <code>undefined</code>。 因此返回一个 undefined，而后才执行 <code>resolve</code>，因此，我们的 <code>MyPromise</code> 还需要升级。</p><h2 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h2><pre><code class="js">class MyPromise &#123;  constructor(executor) &#123;    this.status = PENDING;    this.value = undefined;    this.reason = undefined;    this.onResolveFuncs = []; // *1    this.onRejectedFuncs = []; // *2    let resolve = (value) =&gt; &#123;      if (this.status === PENDING) &#123;        this.value = value;        this.status = FULFILLED;        this.onResolveFuncs.forEach((onResolveFunc) =&gt; onResolveFunc()); // *3      &#125;    &#125;;    let reject = (reason) =&gt; &#123;      if (this.status === PENDING) &#123;        this.reason = reason;        this.status = REJECTED;        this.onRejectedFuncs.forEach((onRejectedFunc) =&gt; onRejectedFunc()); // *4      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (e) &#123;      reject(e);    &#125;  &#125;  then(onFulfilled, onRejected) &#123;    // 返回一个 promise    let promise = new Promise((resolve, reject) =&gt; &#123;      if (this.status === FULFILLED) &#123;        let x = onFulfilled(this.value);      &#125; else if (this.status === REJECTED) &#123;        onRejected(this.reason);      &#125; else &#123;        this.onResolveFuncs.push(() =&gt; onFulfilled(this.value)); // *5        this.onRejectedFuncs.push(() =&gt; onRejected(this.reason)); // *6      &#125;    &#125;);    return promise;  &#125;&#125;// testlet promise1 = new MyPromise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(100);    console.log(&quot;didResolve&quot;);  &#125;, 0);&#125;);promise1.then((val) =&gt; &#123;  console.log(val);&#125;);// 100 -&gt; didResolve</code></pre><p>如上，我们新增加了 6 段代码，让我们一一来说明一下：</p><ol><li>*1 和 *2： 新建了 <code>MyPromise</code> 的两个原型属性 <code>onResolveFuncs</code> 和 <code>onRejectedFuncs</code>；</li><li>*5 和 *6： 当我们执行到 <code>then</code> 方法，而 <code>MyPromise</code> 的状态还是 <code>pending</code> 时（即当 <code>MyPromise</code> 是异步的时候），将 <code>then</code> 方法中的回调函数（参数）都注册到 <code>onResolveFuncs</code> 和 <code>onRejectedFuncs</code> 中，来接收将来 <code>resolve</code> 或者 <code>reject</code> 掉的 <code>value</code> 或者 <code>reason</code>；</li><li>*3 和 *4： 当 <code>MyPromise</code> 实例执行了 <code>resolve</code> 或 <code>reject</code> 方法时，遍历执行注册（储存）在 <code>onResolveFuncs</code> 和 <code>onRejectedFuncs</code> 的所有函数</li></ol><p>以上可以解决 <code>MyPromise</code> 异步导致的 <code>then</code> 方法的函数参数无法顺利执行问题。</p><p><strong>我们可以知道，<code>resolve</code> 和 <code>reject</code> 方法其实很简单，只是用于改变 <code>promise</code> 的状态，获得 <code>executor</code> 赋予的 <code>value</code> 或者 <code>reason</code>，并最终调用注册在 <code>onResolveFuncs</code> 和 <code>onRejectedFuncs</code> 的所有函数。</strong></p><p>但是，问题它又来了，因为仅按照上面的代码，无法实现 <code>then</code> 方法的链式调用，而链式调用时怎么做的呢？</p><p>根据 <code>Promises/A+</code> 规范，<code>then</code> 方法必须返回一个新的 <code>promise</code>，接下来我们可以看一下升级版是如何实现的</p><h2 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h2><p>简单来说，要实现 <code>promise</code> 的链式调用，则在 <code>then</code> 方法中需要返回一个新的 <code>Promise</code> 实例，在触发 <code>then</code> 方法的回调函数时，根据函数返回的结果，分情况将结果 <code>resolve</code> 或者 <code>reject</code> 出去，从而返回一个 <code>settled</code> 的 <code>Promise</code> 用于继续调用 <code>then</code> 方法。</p><pre><code class="js">/** promise: then 方法返回的新的 Promise 实例* x: then 方法的函数参数调用后返回的结果* resolve, reject：Promise 内声明的方法*/// then 方法调用就会调用此方法// 此方法用于将 then 返回的 新的 promise 进行 resolve 或者 rejectfunction resolvePromise(promise, x, resolve, reject) &#123; // *1  if (x === promise) &#123; // 阻止 promise 的循环引用    throw new TypeError(&quot;Chaining cycle detected for promise&quot;);  &#125;  // 声明一个变量用于防止重复 resolve 或者 reject  let called;  // 规范规定，带有 then 方法的对象或者函数都是 promise  if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123;    try &#123;      let then = x.then;      // 若原始实例的 then 方法的函数参数返回了一个 promise，则将继续调用此方法， 将该 promise 状态变为 settled，并将获得的值 resolve 或 reject 掉      if (typeof then === &quot;function&quot;) &#123;        then.call(          x,          (y) =&gt; &#123;            if (called) return;            called = true;            resolvePromise(promise, y, resolve, reject)          &#125;,          (err) =&gt; &#123;            if (called) return;          called = true;          reject(err)          &#125;        ) else &#123;          resolve(x)        &#125;      &#125;    &#125; catch(e) &#123;      if(called) return      called = true      reject(e)    &#125;  &#125; else &#123; // 若是普通值，则直接 resolve 出去    resolve(x);  &#125;&#125;class MyPromise &#123;  constructor(executor) &#123;    // ... 同上  &#125;  then(onFulfilled, onRejected) &#123;    // 返回一个 新的promise    let promise = new Promise((resolve, reject) =&gt; &#123;      if (this.status === FULFILLED) &#123;        // resolvePromise 中的 promise 是由 MyPromise 创建的        // setTimeout 用于保证可以获取到 MyPromise 的实例 promise        setTimeout(()=&gt; &#123; // *2          try &#123;            let x = onFulfilled(this.value);            resolvePromise(promise, x, resolve, reject);          &#125; catch(e) &#123;            reject(e)          &#125;        &#125;, 0)      &#125; else if (this.status === REJECTED) &#123;        setTimeout(()=&gt; &#123;          try &#123;            let x = onRejected(this.reason);            resolvePromise(promise, x, resolve, reject);          &#125; catch(e) &#123;            reject(e)          &#125;        &#125;, 0)      &#125; else &#123;        this.onResolveFuncs.push(() =&gt; &#123;          setTimeout(()=&gt; &#123;            try &#123;              let x = onFulfilled(this.value);              resolvePromise(promise, x, resolve, reject);            &#125; catch(e) &#123;              reject(e)            &#125;          &#125;, 0)        &#125;);        this.onRejectedFuncs.push(() =&gt; &#123;          setTimeout(()=&gt; &#123;            try &#123;              let x = onRejected(this.reason);              resolvePromise(promise, x, resolve, reject);            &#125; catch(e) &#123;              reject(e)            &#125;          &#125;, 0)        &#125;);      &#125;    &#125;);    return promise;  &#125;  catch(onReject) &#123;    return this.then(null, onReject)  &#125;&#125;</code></pre><h2 id="Promise-的静态方法"><a href="#Promise-的静态方法" class="headerlink" title="Promise 的静态方法"></a>Promise 的静态方法</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>我们知道， <code>Promise.all</code> 接受一个 <code>promise</code> 数组作为参数（从技术上讲，它可以是任何可迭代的，但通常是一个数组）并返回一个新的 <code>promise</code>。</p><p>当所有给定的 <code>promise</code> 都被 <code>settled</code> 时，新的 <code>promise</code> 才会 <code>resolve</code>，并且其结果数组将成为新的 <code>promise</code> 的结果。</p><p>如果任意一个 <code>promise</code> 被 <code>reject</code>，由 <code>Promise.all</code> 返回的 <code>promise</code> 就会立即 <code>reject</code>，并且带有的就是这个 <code>error</code>。</p><pre><code class="js">// 判断参数是否为 promise 对象function isPromise(obj) &#123;  if ((typeof obj === &quot;object&quot; &amp;&amp; obj !== null) || typeof obj === &quot;function&quot;) &#123;    if (typeof obj.then === &quot;function&quot;) &#123;      return true;    &#125;  &#125; else &#123;    return false;  &#125;&#125;// 定义 promise.allPromise.all = function (arr) &#123;  return new MyPromise((resolve, reject) =&gt; &#123;    let results = [];    let length = 0; // 计数器，判断何时 resolve 整个结果    arr.forEach((value, i) =&gt; &#123;      // 将数组内的元素都 promise 化，以拥有 then 方法      Promise.resolve(value).then(        (v) =&gt; &#123;          results[i] = v;          if (++length === arr.length) &#123;            resolve(results);          &#125;        &#125;,        (e) =&gt; &#123;          reject(e);        &#125;      );    &#125;);  &#125;);&#125;;</code></pre><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled 与 Promise.all 类似，也接收一个 Promise 数组，但其返回一个数组，包括 fulfilled 和 rejected 的值，返回值格式：</p><pre><code class="[&#123;status:"></code></pre><p>手写如下：</p><pre><code class="js">const FULFILLED = &quot;fulfilled&quot;, // 成功  REJECTED = &quot;rejected&quot;; // 失败MyPromise.allSettled = function (array) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let results = [];    let length = 0;    // 定义一个函数用于处理数据，根据状态 status 将数据包装成对象    function resolveData(state, item, index) &#123;      results[index] = &#123; status: state, value: item &#125;;      if (++length === array.length) &#123;        resolve(results);      &#125;    &#125;    array.forEach((item, i) =&gt; &#123;      if (isPromise(item)) &#123;        item.then(          (v) =&gt; &#123;            resolveData(FULFILLED, v, i);          &#125;,          (e) =&gt; &#123;            resolveData(REJECTED, e, i);          &#125;        );      &#125; else &#123;        resolveData(FULFILLED, item, i);      &#125;    &#125;);  &#125;);&#125;;</code></pre><p>根据大佬的 Polyfill， 发现可以写成这样:</p><pre><code class="js">const resolveHandler = val =&gt; &#123;status: &#39;fulfilled&#39;, value: val&#125;,  rejectHandler = err =&gt; &#123;status: &#39;rejected&#39;, reason: err&#125;MyPromise.allSettled = function(arr) &#123;  let toSettled = arr.map(promise =&gt; Promise.resolve(promise).then(resolveHandler, rejectHandler)) // *1  return Promise.all(toSettled)&#125;</code></pre><p>注意 *1 中先将 arr v 中的所有元素转变为 promise 对象，从而可以使用 then 方法。而后使用 Promise.all 方法等待结果返回。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>与 Promise.all 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。</p><p>当第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略。</p><pre><code class="js">MyPromise.race = function (arr) &#123;  return new Promise((resolve, reject) =&gt; &#123;    arr.forEach((item) =&gt; &#123;      // 给所有元素都注册 then 方法，then 方法调用回调函数，则立刻resolve 或 reject      Promise.resolve(item).then(resolve, reject);    &#125;);  &#125;);&#125;;</code></pre><h3 id="Promise-resolve-Promise-reject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve / Promise.reject"></a>Promise.resolve / Promise.reject</h3><pre><code class="js">MyPromise.resolve = function (promise) &#123;  return new Promise((resolve, reject) =&gt; &#123;    resolve(promise);  &#125;);&#125;;MyPromise.reject = function (promise) &#123;  return new Promise((resolve, reject) =&gt; &#123;    reject(promise);  &#125;);&#125;;</code></pre><p>参考文章：<br><a href="https://www.cnblogs.com/sugar-tomato/p/11353546.html">史上最最最详细的手写 Promise 教程</a><br><a href="https://zh.javascript.info/promise-api">现代 JavaScript 教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;极简版&quot;&gt;&lt;a href=&quot;#极简版&quot; class=&quot;headerlink&quot; title=&quot;极简版&quot;&gt;&lt;/a&gt;极简版&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// 常量
const PENDING = &amp;quot;pending&amp;quot;, // 待定
  FULFILLED = &amp;quot;fulfilled&amp;quot;, // 成功
  REJECTED = &amp;quot;rejected&amp;quot;; // 失败

class MyPromise &amp;#123;
  constructor(executor) &amp;#123;
    this.state = PENDING; // promise 的初始状态

    this.value = undefined; // resolve后获得的值
    this.reason = undefined; // reject 后获得的值

    // executor 的函数参数，将 state 转为 fulfilled
    let resolve = (value) =&amp;gt; &amp;#123;
      if (this.state === PENDING) &amp;#123;
        this.state = FULFILLED;
        this.value = value;
      &amp;#125;
    &amp;#125;;

    // executor 的函数参数，将 state 转为 rejected
    let reject = (reason) =&amp;gt; &amp;#123;
      if (this.state === PENDING) &amp;#123;
        this.state = REJECTED;
        this.reason = reason;
      &amp;#125;
    &amp;#125;;

    // 执行 executor
    try &amp;#123;
      executor(resolve, reject);
    &amp;#125; catch (e) &amp;#123;
      // 报错则直接将 promise 置为 rejected
      reject(e);
    &amp;#125;
  &amp;#125;

  // 重头戏
  then(onFulfilled, onRejected) &amp;#123;
    if (this.state === FULFILLED) &amp;#123;
      onFulfilled(this.value);
    &amp;#125; else if (this.state === REJECTED) &amp;#123;
      onRejected(this.reason);
    &amp;#125;
  &amp;#125;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="https://kerbalhao.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React 思维导图</title>
    <link href="https://kerbalhao.github.io/2020/04/27/LearningReact/"/>
    <id>https://kerbalhao.github.io/2020/04/27/LearningReact/</id>
    <published>2020-04-27T19:01:49.000Z</published>
    <updated>2022-07-05T03:02:34.951Z</updated>
    
    <content type="html"><![CDATA[<p>React 学习，思维导图</p><span id="more"></span><!-- more --><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_c74b777a975efd137587e0ec2c5c96f8.jpeg" alt="React.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 学习，思维导图&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/React/"/>
    
    
      <category term="JS" scheme="https://kerbalhao.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>个人 Dota2 项目</title>
    <link href="https://kerbalhao.github.io/2020/04/23/dota2/"/>
    <id>https://kerbalhao.github.io/2020/04/23/dota2/</id>
    <published>2020-04-23T22:02:46.000Z</published>
    <updated>2022-07-05T03:02:34.955Z</updated>
    
    <content type="html"><![CDATA[<p>此文档用于备份，防止 Github 仓库无法访问<br><a href="https://github.com/KerbalHao/personal_dota2_data">Github仓库地址</a></p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><ul><li>本项目是基于 dota2 中文官网以及 17173 网站中关于 dota2 的数据创建的全栈项目，仅用于个人练习。</li><li>项目使用了 flex 布局，主要支持使用移动端浏览。</li><li>项目支持登录和注销操作，大部分功能需要登录使用，账号密码为 admin。<span id="more"></span></li><li>英雄页面可以点击查看英雄具体内容，包括背景故事、昵称、阵营、技能（技能详情需要进一步的数据）等，支持筛选过滤，可在详情页面收藏该英雄</li><li>物品界面模拟网上商城，可以进行购物、结算等操作，有点击加入购物车的动画（小球抛物线）。</li><li>用户界面处理登录和注册事宜，且可查看已购买和已收藏。</li><li>后端使用 jwt 校验用户是否登录</li><li>用户数据保存在 server\routes\data 中</li></ul><p><img src="https://i.loli.net/2020/04/20/YjzpNb5FMLyrwAu.gif" alt="index.gif"></p><ul><li><p>物品界面</p><p><img src="https://i.loli.net/2020/04/20/rBauZ5bTOE6K8vJ.gif" alt="item.gif"></p></li><li><p>个人中心界面</p></li></ul><p><img src="https://i.loli.net/2020/04/20/oeNlvTGgrnPVfbA.gif" alt="mine.gif"></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>使用了 Vue 全家桶(Vue，Vue-Router，Vuex)，cube-ui 组件库以及 CSS 预处理器 stylus 进行前端的开发以及样式的书写。</li><li>使用 axios 进行进行数据的请求</li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li>使用 express 框架构建了基础的后台服务，通过前端发出请求进行数据的交流</li><li>使用 JSON Web Token 进行跨域认证，校验用户是否登录</li></ul><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><pre><code>npm install</code></pre><h3 id="修改原始配置"><a href="#修改原始配置" class="headerlink" title="修改原始配置"></a>修改原始配置</h3><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>因为在使用 cube-ui 是使用了 amfe-flexibale，文档字体大小 rem 被固定，修改需要到找到 <code>node_modules\amfe-flexible\index.js</code> 文件，修改函数 <code>setRemUnit</code>，重新设置其 rem 的单位大小，本人修改如下：</p><pre><code class="js">function setRemUnit () &#123;    var rem = docEl.clientWidth / 20    docEl.style.fontSize = rem + &#39;px&#39;  &#125;</code></pre><h3 id="启用后台服务"><a href="#启用后台服务" class="headerlink" title="启用后台服务"></a>启用后台服务</h3><pre><code>npm start </code></pre><h3 id="启用开发环境"><a href="#启用开发环境" class="headerlink" title="启用开发环境"></a>启用开发环境</h3><pre><code>npm run serve</code></pre><h3 id="启用生产环境"><a href="#启用生产环境" class="headerlink" title="启用生产环境"></a>启用生产环境</h3><pre><code>npm run build</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文档用于备份，防止 Github 仓库无法访问&lt;br&gt;&lt;a href=&quot;https://github.com/KerbalHao/personal_dota2_data&quot;&gt;Github仓库地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本项目是基于 dota2 中文官网以及 17173 网站中关于 dota2 的数据创建的全栈项目，仅用于个人练习。&lt;/li&gt;
&lt;li&gt;项目使用了 flex 布局，主要支持使用移动端浏览。&lt;/li&gt;
&lt;li&gt;项目支持登录和注销操作，大部分功能需要登录使用，账号密码为 admin。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Lua 基础学习</title>
    <link href="https://kerbalhao.github.io/2020/04/14/Lua%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kerbalhao.github.io/2020/04/14/Lua%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-14T11:08:06.000Z</published>
    <updated>2022-07-05T03:02:34.951Z</updated>
    
    <content type="html"><![CDATA[<p>以下是我学习 lua 时做的思维导图，方便自己记忆与理解，点击详情查看。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/kerbalhao/blog_images/img/2020/Lua_learning.svg" alt="lua思维导图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是我学习 lua 时做的思维导图，方便自己记忆与理解，点击详情查看。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Lua" scheme="https://kerbalhao.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Js 12个重要概念</title>
    <link href="https://kerbalhao.github.io/2019/12/28/JS%2012%E4%B8%AA%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8Areduce%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://kerbalhao.github.io/2019/12/28/JS%2012%E4%B8%AA%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8Areduce%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-12-28T19:48:48.000Z</published>
    <updated>2022-07-05T03:02:34.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript方面"><a href="#JavaScript方面" class="headerlink" title="JavaScript方面"></a><code>JavaScript</code>方面</h2><h3 id="12-个-JS概念"><a href="#12-个-JS概念" class="headerlink" title="12 个 JS概念"></a>12 个 <code>JS</code>概念</h3><p>来源: <a href="https://www.infoq.cn/article/3L*kK19KH2Ey7GIVBGsN?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com">infoQ 了解这 12 个概念，让你的 JavaScript 水平更上一层楼</a></p><h4 id="1-变量赋值（值与引用）"><a href="#1-变量赋值（值与引用）" class="headerlink" title="1. 变量赋值（值与引用）"></a>1. 变量赋值（值与引用）</h4><p><code>JavaScript</code>总是按照值来给变量赋值。当指定的值是 <code>JavaScript</code>的五种原始类型之一（即 <code>Boolean</code>、<code>null</code>、<code>undefined</code>、<code>String</code>和 <code>Number</code>）时，将为变量分配实际的值。但是，当指定的值是 <code>Array</code>、<code>Function</code>或 <code>Object</code>时，将为变量分配内存的对象引用。</p><span id="more"></span><h4 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h4><p>闭包是一种重要的 <code>JavaScript</code>模式，可用于访问私有变量。在下面的示例中，<code>createGreeter</code>返回一个匿名函数，这个函数可以访问参数 <code>greeting</code>（在这里是“<code>Hello</code>”）。在后续的调用中，<code>sayHello</code>将有权访问这个 <code>greeting</code>！</p><pre><code class="javascript">function createGreeter(greeting) &#123;  return function (name) &#123;    console.log(greeting + &quot;, &quot; + name);  &#125;;&#125;const sayHello = createGreeter(&quot;Hello&quot;);sayHello(&quot;Joe&quot;);// Hello, Joe</code></pre><p>在一个更真实的场景中，你可以设想一个初始化函数 <code>apiConnect</code>(<code>apiKey</code>)，它返回一些使用 <code>API</code>密钥的方法。在这种情况下，只需要提供一次 <code>apiKey</code>即可。</p><pre><code class="javascript">function apiConnect(apiKey) &#123;  function get(route) &#123;    return fetch(`$&#123;route&#125;?key=$&#123;apiKey&#125;`);  &#125;  function post(route, params) &#123;    return fetch(route, &#123;      method: &quot;POST&quot;,      body: JSON.stringify(params),      headers: &#123;        Authorization: `Bearer $&#123;apiKey&#125;`,      &#125;,    &#125;);  &#125;  return &#123; get, post &#125;;&#125;const api = apiConnect(&quot;my-secret-key&quot;);// No need to include the apiKey anymoreapi.get(&quot;http://www.example.com/get-endpoint&quot;);api.post(&quot;http://www.example.com/post-endpoint&quot;, &#123; name: &quot;Joe&quot; &#125;);</code></pre><h4 id="3-解构"><a href="#3-解构" class="headerlink" title="3. 解构"></a>3. 解构</h4><p><code>JavaScript</code>参数解构是一种从对象中提取属性的常用方法。</p><pre><code class="javascript">const obj = &#123;  name: &quot;Joe&quot;,  food: &quot;cake&quot;,&#125;;const &#123; name, food &#125; = obj;console.log(name, food);// &#39;Joe&#39; &#39;cake&#39;</code></pre><p>如果需要以其他名称来提取属性，可以使用以下格式来指定它们。</p><pre><code class="javascript">const obj = &#123;  name: &quot;Joe&quot;,  food: &quot;cake&quot;,&#125;;const &#123; name: myName, food: myFood &#125; = obj;console.log(myName, myFood);// &#39;Joe&#39; &#39;cake&#39;</code></pre><p>在下面的示例中，解构被用来将 <code>person</code>对象传给 <code>introduce</code>函数。换句话说，解构可以（并且经常）直接用于提取传给函数的参数。如果你熟悉 <code>React</code>，可能已经见过这个！</p><pre><code class="javascript">const person = &#123;  name: &quot;Eddie&quot;,  age: 24,&#125;;function introduce(&#123; name, age &#125;) &#123;  console.log(`I&#39;m $&#123;name&#125; and I&#39;m $&#123;age&#125; years old!`);&#125;console.log(introduce(person));// &quot;I&#39;m Eddie and I&#39;m 24 years old!&quot;</code></pre><p>详细可看阮一峰的 <a href="http://es6.ruanyifeng.com/#docs/destructuring">ES6 入门</a></p><h4 id="4-展开（spread）语法"><a href="#4-展开（spread）语法" class="headerlink" title="4. 展开（spread）语法"></a>4. 展开（<code>spread</code>）语法</h4><p>在下面的示例中，<code>Math.max</code>不能直接接受 <code>arr</code>数组，因为它的参数不是数组类型，但可以以数组中的各个元素作为参数。展开运算符 <code>…</code>可用于提取数组的各个元素。</p><pre><code class="javascript">const arr = [4, 6, -1, 3, 10, 4];const max = Math.max(...arr);console.log(max);// 10</code></pre><h4 id="5-变长参数-rest-语法"><a href="#5-变长参数-rest-语法" class="headerlink" title="5.变长参数 (rest) 语法"></a>5.变长参数 (<code>rest</code>) 语法</h4><p>可以用它将 传给函数的 任意数量的 参数放入数组中</p><pre><code class="javascript">function myFunc(...args) &#123;  console.log(args[0] + args[1]);&#125;myFunc(1, 2, 3, 4);// 3</code></pre><h4 id="6-数组方法"><a href="#6-数组方法" class="headerlink" title="6.数组方法"></a>6.数组方法</h4><p><code>JavaScript</code>数组方法通常可以为你提供令人难以置信的优雅方式来执行所需的数据转换</p><h5 id="map、filter、reduce"><a href="#map、filter、reduce" class="headerlink" title="map、filter、reduce"></a><code>map</code>、<code>filter</code>、<code>reduce</code></h5><ul><li><code>map:</code>返回一个数组，其中每个元素都是用指定函数进行过转换。</li></ul><pre><code class="javascript">const arr = [1, 2, 3, 4, 5, 6];const mapped = arr.map((el) =&gt; el + 20);console.log(mapped);// [21, 22, 23, 24, 25, 26]</code></pre><ul><li><code>filter:</code>返回一个数字，只有当指定函数返回 <code>true</code>时，相应的元素才会被包含在数组内。</li></ul><pre><code class="javascript">const arr = [1, 2, 3, 4, 5, 6];const filtered = arr.filter((el) =&gt; el === 2 || el === 4);console.log(filtered);// [2, 4]</code></pre><ul><li><code>reduce</code>：基于给定函数累加值。<br>语法： <code>arr.reduce(callback,[initialValue])</code></li><li><code>callback</code>（执行数组中每个值的函数，包含四个参数）<ul><li><code>previousValue</code>（上一次调用回调返回的值，或者是提供的初始值（<code>initialValue</code>））</li><li><code>currentValue</code>（数组中当前被处理的元素）<br><code>index</code>（当前元素在数组中的索引）</li><li><code>array</code>（调用 <code>reduce</code>的数组）</li></ul></li><li><code>initialValue</code>（作为第一次调用 <code>callback</code>的第一个参数。）</li></ul><p>基本应用如下：</p><pre><code class="javascript">var items = [10, 120, 1000];// our reducer functionvar reducer = function add(sumSoFar, item) &#123;  return sumSoFar + item;&#125;;// do the jobvar total = items.reduce(reducer, 0);console.log(total); // 1130</code></pre><p><code>reduce</code>函数的返回结果类型和传入的初始值相同，上个实例中初始值为 <code>number</code>类型，同理，初始值也可为 <code>object</code>类型。</p><pre><code class="javascript">var items = [10, 120, 1000];// our reducer functionvar reducer = function add(sumSoFar, item) &#123;  sumSoFar.sum = sumSoFar.sum + item;  return sumSoFar;&#125;;// do the jobvar total = items.reduce(reducer, &#123; sum: 0 &#125;);console.log(total); // &#123;sum:1130&#125;</code></pre><p><strong><code>reduce</code>进阶应用</strong>:<br>详见<a href="https://segmentfault.com/a/1190000010731933">思否 数组 reduce 方法的高级技巧</a> by <a href="https://segmentfault.com/u/taotao123">风雨后见彩虹</a></p><ul><li><p>我们看下面一个例子。</p><ol><li><p><strong>某同学的期末成绩如下表示</strong></p><pre><code class="javascript">var result = [  &#123;    subject: &quot;math&quot;,    score: 88,  &#125;,  &#123;    subject: &quot;chinese&quot;,    score: 95,  &#125;,  &#123;    subject: &quot;english&quot;,    score: 80,  &#125;,];</code></pre><ul><li><p>如何求该同学的总成绩？</p></li><li><p>我们可以使用 <code>reduce</code>来搞定这个问题</p><pre><code class="javascript">var sum = result.reduce(function (prev, cur) &#123;  return cur.score + prev;&#125;, 0);</code></pre><p>这个时候，我们给 <code>reduce</code>参数添加了第二个参数。通过打印我发现设置了这个参数之后，<code>reduce</code>遍历便已经从第一项开始了。</p><p>这第二个参数就是设置 <code>prev</code>的初始类型和初始值，比如为 0，就表示 <code>prev</code>的初始值为 <code>number</code>类型，值为 0，因此，<code>reduce</code>的最终结果也会是 <code>number</code>类型。</p></li></ul></li><li><p><strong>因为第二个参数为累计结果的初始值，因此假设该同学因为违纪被处罚在总成绩总扣 10 分，只需要将初始值设置为-10 即可。</strong></p><pre><code class="javascript">var sum = result.reduce(function (prev, cur) &#123;  return cur.score + prev;&#125;, -10);</code></pre></li><li><p><strong>假如该同学的总成绩中，各科所占的比重不同，分别为 50%，30%，20%，我们应该如何求出最终的权重结果呢？</strong></p><p>解决方案如下：</p><pre><code class="javascript">var dis = &#123;  math: 0.5,  chinese: 0.3,  english: 0.2,&#125;;var sum = result.reduce(function (prev, cur) &#123;  console.log(prev);  return cur.score + prev;&#125;, -10);var qsum = result.reduce(function (prev, cur) &#123;  return prev + cur.score * dis[cur.subject];&#125;, 0);console.log(sum, qsum);</code></pre><p>为了计算出权重之后的总值，我们在回调函数内部修改了数组当前项，是使他和权重比例相关联，并重新返回一个一样的回调函数，将新修改的当前项传入，就和之前的例子是一样的了。</p></li><li><p><strong>如何知道一串字符串中每个字母出现的次数？</strong></p><p>我们同样可以使用 <code>reduce</code>来解决这个问题</p><p>我们在 <code>reduce</code>的第二个参数里面初始了回调函数第一个参数的类型和值，将字符串转化为数组，那么迭代的结果将是一个对象，对象的每一项 <code>key</code>值就是字符串的字母。</p><pre><code class="javascript">var arrString = &quot;abcdaabc&quot;;arrString.split(&quot;&quot;).reduce(function (res, cur) &#123;  res[cur] ? res[cur]++ : (res[cur] = 1);  return res;&#125;, &#123;&#125;);</code></pre><p>由于可以通过第二参数设置叠加结果的类型初始值，因此这个时候 <code>reduce</code>就不再仅仅只是做一个加法了，我们可以灵活的运用它来进行各种各样的类型转换，比如将数组按照一定规则转换为对象，也可以将一种形式的数组转换为另一种形式的数组，大家可以动手去尝试一样。</p><pre><code class="javascript">[1, 2].reduce(function (res, cur) &#123;  res.push(cur + 1);  return res;&#125;, []);</code></pre><p>这种特性使得 <code>reduce</code>在实际开发中大有可为！但是需要注意点，在 <code>ie9</code>一下的浏览器中，并不支持该方法 ！</p></li></ol></li><li><p>此外，使用 <code>reduce</code>方法可以完成多维度的数据叠加。如上例中的初始值{<code>sum: 0</code>}，这仅仅是一个维度的操作，如果涉及到了多个属性的叠加，如{<code>sum: 0</code>,<code>totalInEuros: 0</code>,<code>totalInYen: 0</code>}，则需要相应的逻辑进行处理。</p><ol><li><p>在下面的方法中，采用分而治之的方法，即将 <code>reduce</code>函数第一个参数 <code>callback</code>封装为一个数组，由数组中的每一个函数单独进行叠加并完成 <code>reduce</code>操作。所有的一切通过一个 <code>manager</code>函数来管理流程和传递初始参数。</p><pre><code class="javascript">var manageReducers = function (reducers) &#123;  return function (state, item) &#123;    return Object.keys(reducers).reduce(function (nextState, key) &#123;      reducers[key](state, item);      return state;    &#125;, &#123;&#125;);  &#125;;&#125;;</code></pre><p>上面就是 <code>manager</code>函数的实现，它需要 <code>reducers</code>对象作为参数，并返回一个 <code>callback</code>类型的函数，作为 <code>reduce</code>的第一个参数。在该函数内部，则执行多维的叠加工作（<code>Object.keys</code>（））。</p></li><li><p>通过这种分治的思想，可以完成目标对象多个属性的同时叠加，完整代码如下：</p><pre><code class="javascript">var reducers = &#123;  totalInEuros: function (state, item) &#123;    return (state.euros += item.price * 0.897424392);  &#125;,  totalInYen: function (state, item) &#123;    return (state.yens += item.price * 113.852);  &#125;,&#125;;var manageReducers = function (reducers) &#123;  return function (state, item) &#123;    return Object.keys(reducers).reduce(function (nextState, key) &#123;      reducers[key](state, item);      return state;    &#125;, &#123;&#125;);  &#125;;&#125;;var bigTotalPriceReducer = manageReducers(reducers);var initialState = &#123; euros: 0, yens: 0 &#125;;var items = [&#123; price: 10 &#125;, &#123; price: 120 &#125;, &#123; price: 1000 &#125;];var totals = items.reduce(bigTotalPriceReducer, initialState);console.log(totals);</code></pre></li></ol></li></ul><h5 id="find、findIndex、indexOf"><a href="#find、findIndex、indexOf" class="headerlink" title="find、findIndex、indexOf"></a><code>find</code>、<code>findIndex</code>、<code>indexOf</code></h5><ul><li><p><code>find</code>：返回与指定条件匹配的第一个实例，不会继续查找其他匹配的实例。</p><pre><code class="javascript">const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];const found = arr.find((el) =&gt; el &gt; 5);console.log(found);// 6</code></pre></li></ul><p>虽然 5 之后的元素都符合条件，但只返回第一个匹配的元素。</p><ul><li><p><code>findIndex</code>：这与 <code>find</code>几乎完全相同，但不返回第一个匹配的元素，而是返回第一个匹配元素的索引。</p><pre><code class="javascript">const arr = [&quot;Nick&quot;, &quot;Frank&quot;, &quot;Joe&quot;, &quot;Frank&quot;];const foundIndex = arr.findIndex((el) =&gt; el === &quot;Frank&quot;);console.log(foundIndex);// 1</code></pre></li><li><p><code>indexOf</code>：与 <code>findIndex</code>几乎完全相同，但它的参数不是一个函数，而是一个简单的值。</p><pre><code class="javascript">const arr = [&quot;Nick&quot;, &quot;Frank&quot;, &quot;Joe&quot;, &quot;Frank&quot;];const foundIndex = arr.indexOf(&quot;Frank&quot;);console.log(foundIndex);// 1</code></pre></li></ul><h5 id="push、pop、shift、unshift"><a href="#push、pop、shift、unshift" class="headerlink" title="push、pop、shift、unshift"></a><code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code></h5><ul><li><p>push：这是一个相对简单的方法，它将一个项添加到数组的末尾。它就地修改数组，函数本身会返回数组的新长度。</p><pre><code class="javascript">let arr = [1, 2, 3, 4];const pushed = arr.push(5);console.log(arr);// [1, 2, 3, 4, 5]console.log(pushed);// 5</code></pre></li><li><p><code>pop</code>：从数组中删除最后一项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。</p><pre><code class="javascript">let arr = [1, 2, 3, 4];const popped = arr.pop();console.log(arr);// [1, 2, 3]console.log(popped);// 4</code></pre></li><li><p><code>shift</code>：从数组中删除第一个项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。</p><pre><code class="javascript">let arr = [1, 2, 3, 4];const shifted = arr.shift();console.log(arr);// [2, 3, 4]console.log(shifted);// 1</code></pre></li><li><p><code>unshift</code>：将一个或多个元素添加到数组的开头。同样，它也是就地修改数组。与其他方法不同的是，函数本身返回数组最新的长度。</p><pre><code class="javascript">let arr = [1, 2, 3, 4];const unshifted = arr.unshift(5, 6, 7);console.log(arr);// [5, 6, 7, 1, 2, 3, 4]console.log(unshifted);// 7</code></pre></li></ul><h5 id="splice、slice、sort"><a href="#splice、slice、sort" class="headerlink" title="splice、slice、sort"></a><code>splice</code>、<code>slice</code>、<code>sort</code></h5><ul><li><p><code>splice</code>：通过删除或替换现有元素或者添加新元素来修改数组的内容。这个方法也是就地修改数组。<br>下面的代码示例的意思是：在数组的位置 1 上删除 0 个元素，并插入 b。</p><pre><code class="javascript">let arr = [&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];arr.splice(1, 0, &quot;b&quot;);</code></pre></li><li><p><code>slice</code>：从指定的起始位置和结束位置之前返回数组的浅拷贝。如果未指定结束位置，则返回数组的其余部分。这个方法不会修改数组，只是返回所需的子集。</p><pre><code class="javascript">let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];const sliced = arr.slice(2, 4);console.log(sliced);// [&#39;c&#39;, &#39;d&#39;]console.log(arr);// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</code></pre></li><li><p><code>sort</code>：根据提供的函数对数组进行排序。这个方法就地修改数组。如果函数返回负数或 0，则顺序保持不变。如果返回正数，则交换元素顺序。</p><pre><code class="javascript">let arr = [1, 7, 3, -1, 5, 7, 2];const sorter = (firstEl, secondEl) =&gt; firstEl - secondEl;arr.sort(sorter);console.log(arr);// [-1, 1, 2, 3, 5, 7, 7]</code></pre></li></ul><h4 id="7-生成器"><a href="#7-生成器" class="headerlink" title="7. 生成器"></a>7. 生成器</h4><p>详看阮一峰<a href="http://es6.ruanyifeng.com/#docs/generator">es6 入门</a><br>生成器函数指定下一次调用 <code>next</code>() 时会生成什么 <code>value</code>。既可以生成有限数量的 <code>value</code>（最后调用 <code>next</code>() 会返回 <code>undefined</code>），也可以使用循环生成无限数量的 value。</p><pre><code class="javascript">function* greeter() &#123;  yield &quot;Hi&quot;;  yield &quot;How are you?&quot;;  yield &quot;Bye&quot;;&#125;const greet = greeter();console.log(greet.next().value);// &#39;Hi&#39;console.log(greet.next().value);// &#39;How are you?&#39;console.log(greet.next().value);// &#39;Bye&#39;console.log(greet.next().value);// undefined</code></pre><p>使用生成器生成无限个值：</p><pre><code class="javascript">function* idCreator() &#123;  let i = 0;  while (true) yield i++;&#125;const ids = idCreator();console.log(ids.next().value);// 0console.log(ids.next().value);// 1console.log(ids.next().value);// 2// etc...</code></pre><h4 id="与"><a href="#与" class="headerlink" title="=== 与 =="></a><code>===</code> 与 <code>==</code></h4><p>一定要知道 <code>JavaScript</code>中 === 运算符和 == 运算符之间的区别！== 运算符在比较之前会进行类型转换，而 === 运算符在比较之前不会进行类型转换。</p><pre><code class="javascript">console.log(0 == &quot;0&quot;);// trueconsole.log(0 === &quot;0&quot;);// false</code></pre><h4 id="9-对象比较"><a href="#9-对象比较" class="headerlink" title="9. 对象比较"></a>9. 对象比较</h4><p><code>JavaScript</code>新手容易犯的一个错误是直接比较对象。变量一般是指向内存中对象的引用，而不是对象本身！比较对象的一种方法是将它们转换成 <code>JSON</code>字符串。但这样做有一个缺点：无法保证对象属性的顺序！一种更安全的方法是使用专门进行深度对象比较的库（例如 <code>lodash</code>的 <code>isEqual</code>，<a href="https://lodash.com/docs#isEqual）。">https://lodash.com/docs#isEqual）。</a><br>下面的对象看起来相同，但它们实际上指向不同的引用。</p><pre><code class="javascript">const joe1 = &#123; name: &quot;Joe&quot; &#125;;const joe2 = &#123; name: &quot;Joe&quot; &#125;;console.log(joe1 === joe2);// false</code></pre><p>相反，下面的结果为 <code>true</code>，因为使用其中一个对象为另一个对象赋值，它们都指向相同的引用（内存中只有一个对象）。</p><pre><code class="javascript">const joe1 = &#123; name: &quot;Joe&quot; &#125;;const joe2 = joe1;console.log(joe1 === joe2);// true</code></pre><h4 id="10-回调函数"><a href="#10-回调函数" class="headerlink" title="10. 回调函数"></a>10. 回调函数</h4><p>很多人都被 <code>JavaScript</code>回调函数吓倒了！它们其实很简单，请看下面的例子。<code>console.log</code>函数作为回调传给 <code>myFunc</code>，并在 <code>setTimeout</code>完成时执行。</p><pre><code class="javascript">function myFunc(text, callback) &#123;  setTimeout(function () &#123;    callback(text);  &#125;, 2000);&#125;myFunc(&quot;Hello world!&quot;, console.log);// &#39;Hello world!&#39;</code></pre><h4 id="11-promise"><a href="#11-promise" class="headerlink" title="11. promise"></a>11. <code>promise</code></h4><p>详看阮一峰的<a href="http://es6.ruanyifeng.com/#docs/promise">es6 入门</a><br>一旦你理解了 <code>JavaScript</code>回调，很快就会发现自己陷入了“回调地狱”中。这个时候可以使用 <code>promise</code>！将异步逻辑包装在 <code>promise</code>中，使用“<code>then</code>”来处理成功的情况，使用“<code>catch</code>”来处理异常。</p><pre><code class="javascript">const myPromise = new Promise(function (res, rej) &#123;  setTimeout(function () &#123;    if (Math.random() &lt; 0.9) &#123;      return res(&quot;Hooray!&quot;);    &#125;    return rej(&quot;Oh no!&quot;);  &#125;, 1000);&#125;);myPromise  .then(function (data) &#123;    console.log(&quot;Success: &quot; + data);  &#125;)  .catch(function (err) &#123;    console.log(&quot;Error: &quot; + err);  &#125;);// If Math.random() returns less than 0.9 the following is logged:// &quot;Success: Hooray!&quot;// If Math.random() returns 0.9 or greater the following is logged:// &quot;Error: On no!&quot;</code></pre><h4 id="12-Async-Await"><a href="#12-Async-Await" class="headerlink" title="12. Async/Await"></a>12. <code>Async</code>/<code>Await</code></h4><p>详看阮一峰的<a href="http://es6.ruanyifeng.com/#docs/async">es6 入门</a><br>在掌握了 <code>promise</code>的用法后，你可能也会喜欢 <code>async await</code>，它只是一种基于 <code>promise</code>的“语法糖”。在下面的示例中，我们创建了一个 <code>async</code>函数，并 <code>await greeter promise</code>。</p><pre><code class="javascript">const greeter = new Promise((res, rej) =&gt; &#123;  setTimeout(() =&gt; res(&quot;Hello world!&quot;), 2000);&#125;);async function myFunc() &#123;  const greeting = await greeter;  console.log(greeting);&#125;myFunc();// &#39;Hello world!&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript方面&quot;&gt;&lt;a href=&quot;#JavaScript方面&quot; class=&quot;headerlink&quot; title=&quot;JavaScript方面&quot;&gt;&lt;/a&gt;&lt;code&gt;JavaScript&lt;/code&gt;方面&lt;/h2&gt;&lt;h3 id=&quot;12-个-JS概念&quot;&gt;&lt;a href=&quot;#12-个-JS概念&quot; class=&quot;headerlink&quot; title=&quot;12 个 JS概念&quot;&gt;&lt;/a&gt;12 个 &lt;code&gt;JS&lt;/code&gt;概念&lt;/h3&gt;&lt;p&gt;来源: &lt;a href=&quot;https://www.infoq.cn/article/3L*kK19KH2Ey7GIVBGsN?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com&quot;&gt;infoQ 了解这 12 个概念，让你的 JavaScript 水平更上一层楼
&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-变量赋值（值与引用）&quot;&gt;&lt;a href=&quot;#1-变量赋值（值与引用）&quot; class=&quot;headerlink&quot; title=&quot;1. 变量赋值（值与引用）&quot;&gt;&lt;/a&gt;1. 变量赋值（值与引用）&lt;/h4&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;总是按照值来给变量赋值。当指定的值是 &lt;code&gt;JavaScript&lt;/code&gt;的五种原始类型之一（即 &lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;和 &lt;code&gt;Number&lt;/code&gt;）时，将为变量分配实际的值。但是，当指定的值是 &lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Function&lt;/code&gt;或 &lt;code&gt;Object&lt;/code&gt;时，将为变量分配内存的对象引用。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JS" scheme="https://kerbalhao.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>MJT-异步迭代器与生成器</title>
    <link href="https://kerbalhao.github.io/2019/09/12/MJT-%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://kerbalhao.github.io/2019/09/12/MJT-%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2019-09-12T10:36:09.000Z</published>
    <updated>2022-07-05T02:30:14.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Async-iterator-and-generators"><a href="#Async-iterator-and-generators" class="headerlink" title="Async iterator and generators"></a>Async iterator and generators</h1><p><strong>翻译自<a href="https://javascript.info/async-iterators-generators">Morden Javascript Tutorial-Async Iterators and Generators</a></strong></p><p>异步 <code>iterator</code> 可以迭代异步请求得到的数据。例如，我们从网络分段下载的数据。异步 <code>generators</code> 使这一步骤更加方便。</p><p>首先，让我们来看一个简单的示例来掌握句法，然后再去看一看现实生活中的例子。</p><h2 id="Async-iterator"><a href="#Async-iterator" class="headerlink" title="Async iterator"></a>Async iterator</h2><p><code>Async iterator</code> 与常规的 <code>iterator</code> 类似，不过有一点语法上的区别。</p><p>一个“常规的” <code>iterables</code> 对象，即我们在 <a href="info:iterable">info:iterable</a> 章节中提到的，是这样的：</p><pre><code class="js">let range = &#123;  from: 1,  to: 5,  // 使用 for..of 语句的时候就会调用一次这个方法*!*  [Symbol.iterator]() &#123;*/!*    // ... 它返回一个 iterator 对象：    // 进一步说, for..of 只能作用于可迭代对象,    // 使用 next() 方法访问下一个 values    return &#123;      current: this.from,      last: this.to,      // next() 被 for..of 循环在每一次迭代过程中调用*!*      next() &#123; // (2)        // 它应该返回一个类似  &#123;done:.., value :...&#125; 的对象*/!*        if (this.current &lt;= this.last) &#123;          return &#123; done: false, value: this.current++ &#125;;        &#125; else &#123;          return &#123; done: true &#125;;        &#125;      &#125;    &#125;;  &#125;&#125;;for(let value of range) &#123;  alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5&#125;</code></pre><p>有需要的话，您可以返回关于 <a href="info:iterable">info:iterable</a> 的章节查看常规的 <code>iterators</code> 的详细内容。</p><span id="more"></span><p>为了使对象可以异步地迭代：</p><ol><li>我们需要使用 <code>Symbol.asyncIterator</code> 取代 <code>Symbol.iterator</code>。</li><li><code>next()</code> 方法应该返回一个 <code>promise</code>。</li><li>我们应该使用 <code>for await (let item of iterable)</code> 循环来迭代这样的对象</li></ol><p>接下来，让我们创建一个类似于之前的，可迭代的 <code>range</code> 对象，不过现在它会按照每秒一个的速度，异步地返回 values：</p><pre><code class="js">let range = &#123;  from: 1,  to: 5,  // 使用 for await..of 语句的时候就会调用一次这个方法*!*  [Symbol.asyncIterator]() &#123; // (1)*/!*    // ... 它返回一个 iterator 对象：    // 进一步说, for await..of 只能作用于可迭代对象,    // 使用 next() 方法访问下一个 values    return &#123;      current: this.from,      last: this.to,      // next() 被 for await..of 循环在每一次迭代过程中调用*!*      async next() &#123; // (2)        // 它应该返回一个类似  &#123;done:.., value :...&#125; 的对象        // (会被 async 关键字自动包装成一个 promise)*/!**!*        // 可以在内部使用 await 关键字来执行异步任务:        await new Promise(resolve =&gt; setTimeout(resolve, 1000)); // (3)*/!*        if (this.current &lt;= this.last) &#123;          return &#123; done: false, value: this.current++ &#125;;        &#125; else &#123;          return &#123; done: true &#125;;        &#125;      &#125;    &#125;;  &#125;&#125;;(async () =&gt; &#123;*!*  for await (let value of range) &#123; // (4)    alert(value); // 1,2,3,4,5  &#125;*/!*&#125;)()</code></pre><p>正如我们看到的，其结构类似于常规的 iterators:</p><ol><li>为了异步地迭代一个对象，这个对象必须有 <code>Symbol.asyncIterator</code> 方法 <code>(1)</code></li><li>这个方法必须返回一个带有 <code>next()</code> 方法的对象，该方法会返回一个 <code>promise</code>。<code>(2)</code></li><li>这个 <code>next()</code> 方法可以不使用 <code>async</code> 关键字，它可以是一个常规的方法返回一个 <code>promise</code>，但是使用 <code>async</code> 关键字允许在方法内部使用 <code>await</code>，所以会更加方便。这里我们只是用来延迟 1 秒操作。<code>(3)</code></li><li>我们使用 <code>for await(let value of range)</code> <code>(4)</code>，也就是在 <code>for</code> 后面增加 <code>await</code>。它会调用一次 <code>range[Symbol.asyncIterator]()</code> 方法一次然后调用它的 <code>next()</code> 方法访问 <code>values</code></li></ol><p>这里有一个备忘单表示：</p><table><thead><tr><th></th><th>Iterators</th><th>Async iterators</th></tr></thead><tbody><tr><td>提供 <code>iterator</code> 的对象方法</td><td><code>Symbol.iterator</code></td><td><code>Symbol.asyncIterator</code></td></tr><tr><td><code>next()</code> 返回的值是</td><td>任意值</td><td><code>Promise</code></td></tr><tr><td>使用的循环语法是</td><td><code>for..of</code></td><td><code>for await..of</code></td></tr></tbody></table><p>````warn header=”展开运算符 <code>...</code>无法执行异步操作” 展开运算符要求常规的，同步的 <code>iterators</code>，无法工作于异步的 <code>iterators</code>。</p><p>例如，展开运算符在以下代码无法执行：</p><pre><code class="js">alert([...range]); // 错误，没有 Symbol.iterator</code></pre><p>这很正常，因为它要找到 <code>Symbol.iterator</code>，正如 <code>for..of</code> 没有 <code>await</code>，而非 <code>Symbol.asyncIterator</code>。</p><pre><code></code></pre><h2 id="Async-generators"><a href="#Async-generators" class="headerlink" title="Async generators"></a>Async generators</h2><p>正如我们所知，JavaScript 也支持 <code>generators</code>，并且他们也是可迭代的。</p><p>让我们来回顾一下 <code>generators</code> 所在的章节 <a href="info:generators">info:generators</a>。它从 <code>start</code> 到 <code>end</code> 生成了一系列的值：</p><pre><code class="js">function* generateSequence(start, end) &#123;  for (let i = start; i &lt;= end; i++) &#123;    yield i;  &#125;&#125;for (let value of generateSequence(1, 5)) &#123;  alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5&#125;</code></pre><p>在常规的 <code>generators</code> 中，我们无法使用 <code>await</code>， 所有的值都必须同步获得：无法在 <code>for..of</code> 循环中延迟执行，这是一个同步的结构。</p><p>但如果我们在 <code>generator</code> 内使用 <code>await</code> 呢？我们可以以网络请求为例子。</p><p>很简单，只需要在前面加上 <code>async</code>，就像这样：</p><pre><code class="js">*!*async*/!* function* generateSequence(start, end) &#123;  for (let i = start; i &lt;= end; i++) &#123;*!*    // 很好，可以使用 await!    await new Promise(resolve =&gt; setTimeout(resolve, 1000));*/!*    yield i;  &#125;&#125;(async () =&gt; &#123;  let generator = generateSequence(1, 5);  for *!*await*/!* (let value of generator) &#123;    alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5  &#125;&#125;)();</code></pre><p>现在，我们有了 <code>async generator</code>，可以使用 <code>for await...of</code> 迭代。</p><p>这实际上非常简单。我们加了 <code>async</code> 关键字，然后我们就能在 <code>generator</code> 内部使用 <code>await</code>，来执行 <code>promise</code> 和其他异步函数。</p><p>从技术上来讲，<code>async generator</code> 的另一个不同之处在于，它的 <code>generatr.next()</code> 方法现在也是异步地，它返回一个 <code>promise</code></p><p>在一个常规的 <code>generator</code> 中，我们使用 <code>result = generator.next()</code> 来获得值。但在一个 <code>async generator</code> 中，我们应该添加 <code>await</code> 关键字，如下：</p><pre><code class="js">result = await generator.next(); // result = &#123;value: ..., done: true/false&#125;</code></pre><h2 id="Async-iterables"><a href="#Async-iterables" class="headerlink" title="Async iterables"></a>Async iterables</h2><p>如我们所知道的，要是一个对象可迭代，我们需要给它添加 <code>Symbol.iterator</code>。</p><pre><code class="js">let range = &#123;  from: 1,  to: 5,*!*  [Symbol.iterator]() &#123;    return &lt;object with next to make range iterable&gt;  &#125;*/!*&#125;</code></pre><p>对于 <code>Symbol.iterator</code> 来说，一个通常的做法是返回一个 <code>generator</code>，这好过返回一个带有 <code>next()</code> 方法的简单对象。</p><p>让我们来回想一下之前<a href="info:generators"></a>章节中的一个示例：</p><pre><code class="js">let range = &#123;  from: 1,  to: 5,  *[Symbol.iterator]() &#123;    // 是 [Symbol.iterator]: function*() 的简写    for (let value = this.from; value &lt;= this.to; value++) &#123;      yield value;    &#125;  &#125;,&#125;;for (let value of range) &#123;  alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5&#125;</code></pre><p>这有一个可迭代的对象 <code>range</code>，并且它的 <code>generator</code> <code>*[Symbol.iterator]</code> 实现了列出 <code>value</code> 的逻辑</p><p>如果们想要给 <code>generator</code> 加上异步操作，那么我们应该将 <code>Symbol.iterator</code> 带换成异步的 <code>Symbol.asyncIterator</code>：</p><pre><code class="js">let range = &#123;  from: 1,  to: 5,*!*  async *[Symbol.asyncIterator]() &#123; // 等价于 [Symbol.asyncIterator]: async function*()*/!*    for(let value = this.from; value &lt;= this.to; value++) &#123;      // 在获得 value 之间暂停，执行其他任务      await new Promise(resolve =&gt; setTimeout(resolve, 1000));      yield value;    &#125;  &#125;&#125;;(async () =&gt; &#123;  for *!*await*/!* (let value of range) &#123;    alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5  &#125;&#125;)();</code></pre><p>现在 <code>value</code> 都是延迟 1 秒后才弹出</p><h2 id="真实例子"><a href="#真实例子" class="headerlink" title="真实例子"></a>真实例子</h2><p>到目前为止，我们为了获得基础的了解，看到的都是简单的例子。接下来，我们就看一下真实应用的例子。</p><p>目前，有很多网络服务都是传递分页的数据。例如，当我们需要一个用户的清单，一个请求只返回了一个预定义数量的用户（例如：100 个用户） - “一页”，并且提供了一个前往下一页的 <code>URL</code>。</p><p>这种模式非常常见。不只是用户，基本所有数据都是。例如， GitHub 允许使用相同的，分页的方式找回提交记录：</p><ul><li>我们应该提交一个请求到这种格式的 <code>URL</code>： <code>https://api.github.com/repos/&lt;repo&gt;/commits</code>。</li><li>它返回一个包含 30 条提交记录的 <code>JSON</code> 对象，并且在返回头的 <code>Link</code> 中提供了一个前往下一页的链接</li><li>然后我们可以使用那个链接作为下一个请求地址，获得更多的提交记录。</li></ul><p>但是我们可以有一个更简单的 API：一个带有提交记录的可迭代对象，然后我们可以像这样来访问它们：</p><pre><code class="js">let repo = &quot;javascript-tutorial/en.javascript.info&quot;; // 获得提交记录的 GitHub 仓库for await (let commit of fetchCommits(repo)) &#123;  // 处理提交记录&#125;</code></pre><p>我们可以使用一个函数 <code>fetchCommits(repo)</code> ，用来在任何需要的时候，为我们获取提交记录，发送请求等。并且让它关注于所有分页的数据。对于我们来说，它就是一个简单的 <code>for await..of</code>。</p><p>通过使用 <code>async generator</code>，我们可以很简单的实现它：</p><pre><code class="js">async function* fetchCommits(repo) &#123;  let url = `https://api.github.com/repos/$&#123;repo&#125;/commits`;  while (url) &#123;    const response = await fetch(url, &#123;      // (1)      headers: &#123; &quot;User-Agent&quot;: &quot;Our script&quot; &#125;, // github 要求 user-agent 头部    &#125;);    const body = await response.json(); // (2) 返回的数据是一个 JSON (提交记录的列表)    // (3) 前往下一页的 URL 在头部，需要将其提取出来    let nextPage = response.headers.get(&quot;Link&quot;).match(/&lt;(.*?)&gt;; rel=&quot;next&quot;/);    nextPage = nextPage &amp;&amp; nextPage[1];    url = nextPage;    for (let commit of body) &#123;      // (4) 一个接一个地 yield 提交记录，直到最后一页      yield commit;    &#125;  &#125;&#125;</code></pre><ol><li>我们使用浏览器的 <a href="info:fetch">info:fetch</a> 方法从 <code>URL</code> 下载数据。它允许我们提供授权和其他需要的头部，这里 GitHub 需要的是 <code>User-Agent</code></li><li><code>fetch</code> 的结果作为 <code>JSON</code> 被解析，那也是一个 <code>fetch</code> 的特殊方法</li><li>我们应该从返回头的 <code>Link</code> 中获得前往下一页的 <code>URL</code>。它有一个特殊的格式，所以我们可以使用正则表达式得到它。前往下一页的 <code>URL</code> 看起来像：<code>https://api.github.com/repositories/93253246/commits?page=2</code>，这是由 GitHub 自己生成的。</li><li>然后我们将接收的提交记录 <code>yield</code> 出来，当它结束的时候 – 下一个 <code>while(url)</code> 迭代将会触发，从而发送下一个请求</li></ol><p>这是一个使用的例子（将会在用户的控制台显示）</p><pre><code class="js">(async () =&gt; &#123;  let count = 0;  for await (const commit of fetchCommits(    &quot;javascript-tutorial/en.javascript.info&quot;  )) &#123;    console.log(commit.author.login);    if (++count == 100) &#123;      // let&#39;s stop at 100 commits      break;    &#125;  &#125;&#125;)();</code></pre><p>这就是我们想要的。从外面无法看到内部的是如何处理分页数据的请求的。对我们来说，那只是一个返回提交记录的 <code>async generator</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于无需花费很长时间生成的数据，常规的 <code>iterators</code> 和 <code>generators</code> 工作良好。</p><p>当我们需要异步获得数据的时候，它们的异步的同行则有了发挥的机会，<code>for await..of</code> 会去替代 <code>for..of</code>。</p><p>异步与常规 <code>iterator</code> 的语法区别：</p><table><thead><tr><th></th><th>Iterable</th><th>Async Iterable</th></tr></thead><tbody><tr><td>提供 <code>iterator</code> 的方法</td><td><code>Symbol.iterator</code></td><td><code>Symbol.asyncIterator</code></td></tr><tr><td><code>next()</code> 返回的值是</td><td><code>&#123;value:…, done: true/false&#125;</code></td><td>被 <code>resolves</code> 成 <code>&#123;value:…, done: true/false&#125;</code> 的 <code>Promise</code></td></tr></tbody></table><p>异步与常规 <code>generator</code> 的语法区别：</p><table><thead><tr><th></th><th>Generators</th><th>Async generators</th></tr></thead><tbody><tr><td>声明方式</td><td><code>function*</code></td><td><code>async function*</code></td></tr><tr><td><code>next()</code> 返回的值是</td><td><code>&#123;value:…, done: true/false&#125;</code></td><td>被 <code>resolves</code> 成 <code>&#123;value:…, done: true/false&#125;</code> 的 <code>Promise</code></td></tr></tbody></table><p>在网络开发中，我们经常会遇到数据流，例如下载或者上传大文件。</p><p>我们可以使用 <code>async generator</code> 来处理类似的数据。值得注意的是，在一些环境，例如浏览器环境下，还有另外一个 API 被叫做 <code>Streams</code>，它提供一些特殊的接口来操作类似的数据流，来传输数据或将其从一个数据流传递到另一个数据流（例如，从一个地方下载后立刻将其发送到其他地方）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Async-iterator-and-generators&quot;&gt;&lt;a href=&quot;#Async-iterator-and-generators&quot; class=&quot;headerlink&quot; title=&quot;Async iterator and generators&quot;&gt;&lt;/a&gt;Async iterator and generators&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;翻译自&lt;a href=&quot;https://javascript.info/async-iterators-generators&quot;&gt;Morden Javascript Tutorial-Async Iterators and Generators&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异步 &lt;code&gt;iterator&lt;/code&gt; 可以迭代异步请求得到的数据。例如，我们从网络分段下载的数据。异步 &lt;code&gt;generators&lt;/code&gt; 使这一步骤更加方便。&lt;/p&gt;
&lt;p&gt;首先，让我们来看一个简单的示例来掌握句法，然后再去看一看现实生活中的例子。&lt;/p&gt;
&lt;h2 id=&quot;Async-iterator&quot;&gt;&lt;a href=&quot;#Async-iterator&quot; class=&quot;headerlink&quot; title=&quot;Async iterator&quot;&gt;&lt;/a&gt;Async iterator&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Async iterator&lt;/code&gt; 与常规的 &lt;code&gt;iterator&lt;/code&gt; 类似，不过有一点语法上的区别。&lt;/p&gt;
&lt;p&gt;一个“常规的” &lt;code&gt;iterables&lt;/code&gt; 对象，即我们在 &lt;a href=&quot;info:iterable&quot;&gt;info:iterable&lt;/a&gt; 章节中提到的，是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;let range = &amp;#123;
  from: 1,
  to: 5,

  // 使用 for..of 语句的时候就会调用一次这个方法
*!*
  [Symbol.iterator]() &amp;#123;
*/!*
    // ... 它返回一个 iterator 对象：
    // 进一步说, for..of 只能作用于可迭代对象,
    // 使用 next() 方法访问下一个 values
    return &amp;#123;
      current: this.from,
      last: this.to,

      // next() 被 for..of 循环在每一次迭代过程中调用
*!*
      next() &amp;#123; // (2)
        // 它应该返回一个类似  &amp;#123;done:.., value :...&amp;#125; 的对象
*/!*
        if (this.current &amp;lt;= this.last) &amp;#123;
          return &amp;#123; done: false, value: this.current++ &amp;#125;;
        &amp;#125; else &amp;#123;
          return &amp;#123; done: true &amp;#125;;
        &amp;#125;
      &amp;#125;
    &amp;#125;;
  &amp;#125;
&amp;#125;;

for(let value of range) &amp;#123;
  alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有需要的话，您可以返回关于 &lt;a href=&quot;info:iterable&quot;&gt;info:iterable&lt;/a&gt; 的章节查看常规的 &lt;code&gt;iterators&lt;/code&gt; 的详细内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js现代教程" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E7%8E%B0%E4%BB%A3%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JS" scheme="https://kerbalhao.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>ES6-迭代器与生成器</title>
    <link href="https://kerbalhao.github.io/2019/08/19/ES6_%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://kerbalhao.github.io/2019/08/19/ES6_%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2019-08-19T10:36:09.000Z</published>
    <updated>2022-07-05T02:13:34.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-迭代器与生成器"><a href="#ES6-迭代器与生成器" class="headerlink" title="ES6 迭代器与生成器"></a>ES6 迭代器与生成器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是一种特殊的对象，具有专为 迭代过程 设计的撰有接口，迭代器对象都有一个 <code>next()</code> 方法，该方法调用后会返回一个结果对象。</p><p>该结果对象有两个属性：</p><ol><li><code>value</code>，表示下一个将要返回的值</li><li><code>done</code>，是一个布尔值，表示是否迭代完数据集</li></ol><p>迭代其中有一个内部指针，用来指向当前集合中 值 的位置，每调用一次 <code>next()</code> 方法，都会返回下一个可用的 值。</p><p>当最后一个值返回后再调用 <code>next()</code> 方法，返回的对象中 属性 <code>done</code> 的值为 <code>true</code>， 属性 <code>value</code> 则包含迭代器最终返回的 值（这个返回值不是 数据集 中的一部分，它与函数的返回值类似，是函数调用过程中最后一次给 调用者 传递信息 的方法，如果没有相关数据则返回 <code>undefined</code>）</p><span id="more"></span><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是一中返回 迭代器 的函数，通过 <code>function</code> 关键字后的星号(<code>*</code>)来表示，函数中会用到新的关键字 <code>yield</code>，如</p><pre><code class="js">function* createIterator() &#123;  yield 1; // yield 关键字可以返回任何值或者表达式，每当执行完一句 yield 语句后，函数会自动停止执行，知道再次调用迭代器的 next() 方法  yield 2;  yield 3;&#125;// 生成器的调用方式与普通函数一致，不过 返回一个迭代器let iterator = createIterator();console.log(iterator.next().value); //1console.log(iterator.next().value); //2console.log(iterator.next().value); //3</code></pre><p><strong>注意，<code>yield</code> 关键字只能在生成器内部使用，在其他地方，即使是生成器内部的函数内使用，都会抛出错误</strong></p><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>生成器可以用表达式的方式来创建，如下</p><pre><code class="js">let createIterator = function *(item) &#123;//code...&#125;let iterator = createIterator()</code></pre><h3 id="生成器对象的方法"><a href="#生成器对象的方法" class="headerlink" title="生成器对象的方法"></a>生成器对象的方法</h3><p>生成器本身就是函数，所以可以将它们添加到对象中</p><pre><code class="js">let obj = &#123;  *creeateIterator() &#123;    yield 1;  &#125;,&#125;;let iterator = o.createIterator();</code></pre><h3 id="可迭代对象和-for-of-循环"><a href="#可迭代对象和-for-of-循环" class="headerlink" title="可迭代对象和 for-of 循环"></a>可迭代对象和 <code>for-of</code> 循环</h3><p>可迭代对象都具有 <code>Symbol.iterator</code> 属性，是一种与迭代器密切相关的对象。</p><p><code>Symbol.iterator</code> （默认被作为生成器）通过指定的函数可以返回一个作用于附属对象的迭代器</p><p>在 ES6 中，所有的集合对象和字符串都是可迭代对象，都有默认的迭代器</p><p>生成器默认会为 <code>Symbol.iterator</code> 属性赋值，所有通过生成器创建的迭代器都是可迭代对象</p><p><code>for-of</code> 循环每执行一次都会调用可迭代对象的 <code>next()</code> 方法，并将迭代器返回的结果对象 的 <code>value</code> 属性存储在一个变量值，循环将持续执行这一过程，知道对象的 <code>done</code> 属性的 值 为 <code>true</code>,如下：</p><pre><code class="js">let values = [1, 2, 3];for (let num of values) &#123;  console.log(num); //被依次输出 1; 2; 3&#125;</code></pre><p>以上代码调用 数组 <code>values</code> 的 <code>Symbol.iterator</code> 方法来获取迭代器，随后迭代器的 <code>next()</code> 方法被多次调用，从它的 返回对象的 <code>value</code> 属性 堆区值 并存储在变量 <code>num</code> 中，当结果对象的 <code>done</code> 属性值为 <code>true</code> 时退出循环，所以 <code>num</code> 不会被赋值为 undefined。</p><h4 id="for-of-与-for-in-区别"><a href="#for-of-与-for-in-区别" class="headerlink" title="for-of 与 for-in 区别"></a><code>for-of</code> 与 <code>for-in</code> 区别</h4><ul><li><code>for-of</code> 循环只可用于可迭代对象，否则会报错。</li><li><code>for-in</code> 循环可枚举对象的属性键，<code>for-of</code> 循环可迭代对象的值</li></ul><h3 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h3><p>我们可以通过访问对象的 <code>Symbol.iterator</code> 来获得对象的 默认迭代器，例如：</p><pre><code class="js">let values = [1, 2, 3];// 将 values 的迭代器赋值给 iteratorlet iterator = values[Symbol.iterator]();console.log(iterator.next()); // &#39;&#123;value: 1, done: false&#125;&#39;...</code></pre><p>因为具有 <code>Symbol.iterator</code> 属性的对象都有默认的迭代器，因此可以使用 <code>typeof obj[Symbol.iterator === &#39;function</code> 来检测对象是否为可迭代对象</p><h3 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h3><p>默认情况下，开发者定义的对象都是不可迭代对象，如果给 <code>Symbol.iterator</code> 属性添加一个生成器，则可以将其变为可迭代对象</p><pre><code class="js">let obj = &#123;  items: [],  *[Symbol.iterator]() &#123;    for (let item of this.items) &#123;      yield item;    &#125;  &#125;,&#125;;obj.items.push(1);obj.items.push(2);obj.items.push(3);for (let x of obj) &#123;  console.log(x);&#125;</code></pre><h2 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h2><h3 id="集合对象迭代器"><a href="#集合对象迭代器" class="headerlink" title="集合对象迭代器"></a>集合对象迭代器</h3><p>ES6 中的集合对象有三种： 数组、<code>Map</code> 集合与 <code>Set</code> 集合，这三种对象都内建了以下三种迭代器</p><ul><li><code>enteries()</code> 返回一个迭代器，其值为多个 键值对。每次调用 <code>next()</code> 方法时，<code>entries()</code> 迭代器都会返回一个数组，数组中的两个元素分别表示 集合中 每个元素的键与值。<code>Map</code> 集合的默认迭代器就是 <code>entries()</code> 方法</li><li><code>values()</code> 返回一个迭代器，其值为集合中的所有值，<code>values()</code> 方法是 数组与 <code>Set</code>集合的默认迭代器方法</li><li><code>keys()</code> 返回一个迭代器，其值为集合中的所有键名</li></ul><h4 id="字符串迭代器"><a href="#字符串迭代器" class="headerlink" title="字符串迭代器"></a>字符串迭代器</h4><p>字符串的默认迭代器与数组的默认迭代器一致，都是 <code>values()</code> 方法。</p><h4 id="NodeList-迭代器"><a href="#NodeList-迭代器" class="headerlink" title="NodeList 迭代器"></a><code>NodeList</code> 迭代器</h4><p><code>NodeList</code> 的默认迭代器与数组的默认迭代器一致，都是 <code>values()</code> 方法。</p><h2 id="展开运算符-与-非数组可迭代对象"><a href="#展开运算符-与-非数组可迭代对象" class="headerlink" title="展开运算符 与 非数组可迭代对象"></a>展开运算符 与 非数组可迭代对象</h2><p>通过展开运算符，可以将任何 非数组可迭代对象 转换为 数组</p><pre><code class="js">let map = new Map([[&#39;name&#39;,&#39;Nich&#39;], [&#39;age&#39;: 25]]),    array = [...map]console.log(array) // [[&#39;name&#39;,&#39;Nich&#39;], [&#39;age&#39;: 25]]let small = [1, 2, 3],    big = [100, 101, 102]    all = [0, ...small, ...big]console.log(all) // [0, 1, 2, 3, 100, 101, 102]</code></pre><h2 id="高级迭代器功能"><a href="#高级迭代器功能" class="headerlink" title="高级迭代器功能"></a>高级迭代器功能</h2><h3 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h3><p>迭代器的 <code>next()</code> 方法可以接受参数，这个参数的值会替代生成器内部，<strong>上一条</strong> <code>yield</code> 语句的返回值。</p><pre><code class="js">function* createIterator() &#123;  let first = yield 1;  let second = yield first + 2;  yield second + 3;&#125;let iterator = createIterator();// 第一次调用 next() 方法时，传入的参数会被丢弃console.log(iterator.next()); // &#39;&#123;value: 1, done: false&#125;&#39;console.log(iterator.next(4)); // &#39;&#123;value: 6, done: false&#125;&#39;console.log(iterator.next(5)); // &#39;&#123;value: 8, done: false&#125;&#39;console.log(iterator.next()); // &#39;&#123;value: undefined, done: true&#125;&#39;</code></pre><p>在含参的 <code>yield</code> 语句中，<code>yield</code> 关键字后面的计算结果 即为 当前 <code>next()</code> 方法调用后的返回值；<code>next()</code> 方法中传递的参数，是作为 上一次 <code>next()</code> 方法调用后的返回值，用于计算此次 <code>next()</code> 调用后的返回值</p><h3 id="生成器返回语句"><a href="#生成器返回语句" class="headerlink" title="生成器返回语句"></a>生成器返回语句</h3><p>由于生成其实函数，因此可以通过 <code>return</code> 语句提前退出函数执行，对于最后一次 <code>next()</code> 方法调用，可以主动为其指定一个返回值。在生成其中， <code>return</code> 表示所有操作已经完成，属性 <code>done</code> 被设置为 <code>true</code>，如果提供了相应的值，则属性 <code>value</code> 会被设置成这个值。 <code>return</code> 语句指定的返回值，只会在返回对象中出现一次，在后续调用返回的对象中， <code>value</code> 属性会被重置为 <code>undefined</code>。</p><pre><code class="js">function* createIterator() &#123;  yield 1;  return 2;  // 3 将不会出现  yield 3;&#125;let iterator = createIterator();console.log(iterator.next()); // &#123;value: 1, done: false&#125;console.log(iterator.next()); // &#123;value: 2, done: true&#125;console.log(iterator.next()); // &#123;value: undefined, done: true&#125;</code></pre><h3 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h3><p>我们可以创建一个生成器，再给 <code>yield</code> 语句添加一个星号，就可以将生成数据的过程委托给其他生成器。</p><pre><code class="js">funtion *createNumber() &#123;  yield 1  yield 2&#125;function *createColor() &#123;  yield &#39;red&#39;  yield &#39;green&#39;&#125;function *createCombined() &#123;  yield *createNumber()  yield *createColor()  yield true&#125;let iterator = createCombined()console.log(iterator.next()) // &#123;value: 1, done: false&#125;console.log(iterator.next()) // &#123;value: 2, done: false&#125;console.log(iterator.next()) // &#123;value: &#39;red, done: false&#125;console.log(iterator.next()) // &#123;value: &#39;green&#39;, done: false&#125;console.log(iterator.next()) // &#123;value: true, done: false&#125;console.log(iterator.next()) // &#123;value: undefined, done: true&#125;</code></pre><h2 id="异步迭代器与生成器"><a href="#异步迭代器与生成器" class="headerlink" title="异步迭代器与生成器"></a>异步迭代器与生成器</h2><p>可以查看我翻译自 《现代 JavaScript 教程》 的文章 <a href="https://zh.javascript.info/async-iterators-generators">异步迭代器与生成器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-迭代器与生成器&quot;&gt;&lt;a href=&quot;#ES6-迭代器与生成器&quot; class=&quot;headerlink&quot; title=&quot;ES6 迭代器与生成器&quot;&gt;&lt;/a&gt;ES6 迭代器与生成器&lt;/h1&gt;&lt;h2 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h2&gt;&lt;p&gt;迭代器是一种特殊的对象，具有专为 迭代过程 设计的撰有接口，迭代器对象都有一个 &lt;code&gt;next()&lt;/code&gt; 方法，该方法调用后会返回一个结果对象。&lt;/p&gt;
&lt;p&gt;该结果对象有两个属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;，表示下一个将要返回的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;done&lt;/code&gt;，是一个布尔值，表示是否迭代完数据集&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;迭代其中有一个内部指针，用来指向当前集合中 值 的位置，每调用一次 &lt;code&gt;next()&lt;/code&gt; 方法，都会返回下一个可用的 值。&lt;/p&gt;
&lt;p&gt;当最后一个值返回后再调用 &lt;code&gt;next()&lt;/code&gt; 方法，返回的对象中 属性 &lt;code&gt;done&lt;/code&gt; 的值为 &lt;code&gt;true&lt;/code&gt;， 属性 &lt;code&gt;value&lt;/code&gt; 则包含迭代器最终返回的 值（这个返回值不是 数据集 中的一部分，它与函数的返回值类似，是函数调用过程中最后一次给 调用者 传递信息 的方法，如果没有相关数据则返回 &lt;code&gt;undefined&lt;/code&gt;）&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="https://kerbalhao.github.io/tags/ES6/"/>
    
      <category term="迭代器与生成器" scheme="https://kerbalhao.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Set Map</title>
    <link href="https://kerbalhao.github.io/2019/08/09/ES6_Set,Map/"/>
    <id>https://kerbalhao.github.io/2019/08/09/ES6_Set,Map/</id>
    <published>2019-08-09T10:36:09.000Z</published>
    <updated>2022-07-05T02:14:38.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-Set-集合与-Map-集合"><a href="#ES6-Set-集合与-Map-集合" class="headerlink" title="ES6- Set 集合与 Map 集合"></a>ES6- <code>Set</code> 集合与 <code>Map</code> 集合</h1><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a><code>Set</code> 集合</h2><p>ES6 新增的 <code>Set</code> 类型是一种有序列表，其中含有一些相互独立的 非重复值，通过 <code>Set</code> 集合可以快速访问其中的数据，更有效的追踪各种离散值</p><h3 id="创建-Set-集合并添加元素"><a href="#创建-Set-集合并添加元素" class="headerlink" title="创建 Set 集合并添加元素"></a>创建 <code>Set</code> 集合并添加元素</h3><p>使用 <code>new Set()</code> 创建 <code>Set</code> 集合，调用 <code>add()</code> 方法 可以添加元素，访问 <code>Set</code> 集合的 <code>size</code> 属性 可以获取集合中目前的元素数量。</p><p>调用 <code>add()</code> 方法 将元素添加到 <code>Set</code> 集合中时，不会对所存的值进行强制的类型转换，所以数字 ·<code>5</code> 与 字符串 <code>&#39;5&#39;</code> 可以作为两个独立的存在， <code>Set</code> 中的对象相互之间也保持独立。添加重复元素时，其不会被添加到集合中， <code>Set</code> 集合中的 <code>size</code> 属性 会保持不变。</p><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>调用 <code>delete()</code> 方法 可以移除 <code>Set</code> 集合中的指定元素，调用 <code>clear()</code> 方法 会移除集合中的所有元素</p><span id="more"></span><h3 id="Set-集合的-forEach-方法"><a href="#Set-集合的-forEach-方法" class="headerlink" title="Set 集合的 forEach() 方法"></a><code>Set</code> 集合的 <code>forEach()</code> 方法</h3><p><code>Set</code> 集合 的 <code>forEach</code> 方法与 数组的 <code>forEach</code> 方法类似，但其 <code>回调函数</code> 接受3个参数：</p><ol><li><code>Set</code> 集合中下一次索引的位置</li><li>与第一个参数一样的值</li><li>北边里的 <code>Set</code> 集合本身</li></ol><p>其第一个参数与第二个参数一致很奇怪是吧？我们可以联想一下 数组的 <code>forEach</code> 与 <code>Map</code> 集合的 <code>forEach</code> 方法，这两个集合的 <code>forEach</code> 方法都接受三个参数，与 <code>Set</code> 集合不同的是，它们的前两个参数分别是 值 和 键名(对于数组来说，是 数值型索引值)，而 <code>Set</code> 集合是没有键名也没有数值型索引值的，为了使 <code>forEach</code> 方法的使用便捷，决定将 <code>Set</code> 集合的每个元素也按照键名和值的形式储存(值与键同值)</p><p><code>forEach</code> 方法接受将 <code>this</code> 作为第二个参数，从而可以在回调函数中使用 <code>this</code> 引用</p><p><strong>注意，<code>Set</code> 集合无法通过访问索引访问集合中的元素，不过我们可以将 <code>Set</code> 集合转换为数组</strong></p><h3 id="将-Set-集合转换为数组"><a href="#将-Set-集合转换为数组" class="headerlink" title="将 Set 集合转换为数组"></a>将 <code>Set</code> 集合转换为数组</h3><ul><li>将数组转换为 <code>Set</code> 集合： 给 <code>Set</code> 构造函数传入数组即可，转换为 <code>Set</code> 集合后，<code>Set</code> 集合中不会有重复的元素</li><li>使用展开运算符 <code>...</code> 将 <code>Set</code> 集合转换回数组, 新数组中保存的是 <code>Set</code> 集合中的元素<pre><code class="js">// 数组 转换为 Set 集合let setG = new Set([1, 2, 3, 4, 5, 3, 3, 3]);console.log(setG) // Set(5) &#123;1, 2, 3, 4, 5&#125;// Set 集合转换为 数组let  arr = [...setG]console.log(arr) // (5) [1, 2, 3, 4, 5]</code></pre></li></ul><h3 id="Weak-Set-集合"><a href="#Weak-Set-集合" class="headerlink" title="Weak Set 集合"></a><code>Weak Set</code> 集合</h3><p><code>Set</code> 集合是强引用的 <code>Set</code> 集合：</p><pre><code class="js">let setG = new Set(),    key = &#123;&#125;// 将 对象 key 添加进 Set 中set.add(key)console.log(setG.size) // 1// 移除原始引用key = nullconsole.log(setG.size) // 1// Set 集合保留了对原始对象的引用，仍然可以访问 引用的值，导致垃圾回收机制不能释放原始引用对象的内存空间，可能会造成内存泄漏key = [...setG][0]</code></pre><p><code>Weak Set</code> 集合是弱引用的 <code>Set</code> 集合，只存储对象的弱引用，并且 <strong>不可以存储原始值</strong>，如果集合中包含任何非对象值，会抛出错误；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存</p><h4 id="创建-Weak-Set-集合"><a href="#创建-Weak-Set-集合" class="headerlink" title="创建 Weak Set 集合"></a>创建 <code>Weak Set</code> 集合</h4><p>用 <code>WeakSet</code> 构造函数可以创建 <code>Weak Set</code> 集合，集合支持3个方法：</p><ol><li><code>add()</code> 方法，向集合中添加元素、</li><li><code>has()</code>方法 检查集合中是否存在指定对象的引用、</li><li><code>delete()</code> 移除指定对象的引用</li></ol><h4 id="两种-Set-类型的区别"><a href="#两种-Set-类型的区别" class="headerlink" title="两种 Set 类型的区别"></a>两种 <code>Set</code> 类型的区别</h4><ol><li>在 <code>WeakSet</code> 实例中，如果向 <code>add(), has(). delete()</code> 这三个方法传入非对象参数都会导致程序报错</li><li><code>Weak Set</code> 集合不可迭代，不能被用于 <code>for-of</code> 循环</li><li><code>Weak Set</code> 集合不暴露任何迭代器方法，所以无法通关程序本身来检测其中的内容</li><li><code>Weak Set</code> 集合不支持 <code>forEach()</code> 方法</li><li><code>Weak Set</code> 集合不支持 <code>size</code> 属性</li></ol><h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a><code>Map</code> 集合</h2><p><code>Map</code> 类型是一种储存着许多 键值对 的 有序列表，其中的 键名 和 值 支持所有的数据属性。</p><p><code>Map</code> 类型的 键名 不会被强制类型转换，所以数字 <code>5</code> 与 字符串 <code>&#39;5&#39;</code> 可以作为两个独立的键</p><p>可以访问 <code>Map</code> 集合的 <code>size</code> 属性，获得集合中元素的数量</p><p><code>Map</code> 类型还能以 对象 作为键值，并将其储存在集合中</p><h3 id="Map-集合支持的方法"><a href="#Map-集合支持的方法" class="headerlink" title="Map 集合支持的方法"></a><code>Map</code> 集合支持的方法</h3><ul><li><code>set()</code> 方法: 分别传入 键名 和 对应的值 作为两个参数，向 <code>Map</code> 集合中添加新的元素</li><li><code>get()</code> 方法： 传入要访问的 键名， 用于访问 <code>Map</code> 集合中的对应键名的值，如果 传入的键名 在集合中不存在，则返回 <code>undefined</code></li><li><code>has()</code> 方法，传入一个指定的键名， 检测指定的键名在 <code>Map</code> 集合中是否已存在</li><li><code>delete()</code> 方法 从 <code>Map</code> 集合中移除指定的键名及其对应的值</li><li><code>clear()</code> 移除 <code>Map</code> 集合中的所有键值对</li></ul><h3 id="Map-集合的初始化方法"><a href="#Map-集合的初始化方法" class="headerlink" title="Map 集合的初始化方法"></a><code>Map</code> 集合的初始化方法</h3><p>可以向 <code>Map</code> 构造函数传入一个数组来初始化一个 <code>Map</code> 集合。数组中的每个元素 都是一个 子数组，子数组中包含一个 键值对的 键名 与 值 两个元素</p><pre><code class="js">let age = 25, obj = &#123;&#125;let map = new Map([[&#39;name&#39;, &#39;a&#39;], [&#39;age&#39;, age], [obj, obj]])console.log(map.get(&#39;name&#39;)) // &#39;a&#39;console.log(map.get(&#39;age&#39;)) // 25console.log(map.get(obj)) //&#123;&#125;</code></pre><h3 id="Map-集合的-forEach-方法"><a href="#Map-集合的-forEach-方法" class="headerlink" title="Map 集合的 forEach() 方法"></a><code>Map</code> 集合的 <code>forEach()</code> 方法</h3><p><code>Map</code> 集合 的 <code>forEach</code> 方法与 数组的 <code>forEach</code> 方法类似，其 <code>回调函数</code> 接受3个参数：</p><ol><li><code>Set</code> 集合中下一次索引的位置</li><li>值对应的键名</li><li>北边里的 <code>Set</code> 集合本身</li></ol><p>遍历过程中，会按照 键值对 插入 <code>Map</code> 集合中的顺序，将相应信息传入 <code>forEach()</code> 方法的回调函数</p><h3 id="Weak-Map-集合"><a href="#Weak-Map-集合" class="headerlink" title="Weak Map 集合"></a><code>Weak Map</code> 集合</h3><p><code>Weak Map</code> 是弱引用的 <code>Map</code> 集合，用域存储对象的弱引用。 <code>Weak Map</code> 集合中的键名必须是一个对象，使用非对象键名会报错；集合中的键名保存的是这些对象的弱引用，如果在弱引用之外不存在其他的强引用，引擎的垃圾回收机制会自动回收这个对象，同时也会移除 <code>Weak Map</code> 集合中的 <strong>键值对</strong>。</p><p>**注意，只有集合的键名遵守这个规则，键名对应的 值 如果是一个对象，则保存的是对象的 强引用，不会触发垃圾回收机制。</p><h4 id="Weak-Map-集合支持的方法"><a href="#Weak-Map-集合支持的方法" class="headerlink" title="Weak Map 集合支持的方法"></a><code>Weak Map</code> 集合支持的方法</h4><p><code>Weak Map</code> 类型是一种存储着许多键值对的 无序 列表，列表的键名 必须是非 <code>null</code> 类型的对象，键名对应的值可以是任意类型。</p><ul><li><p><code>WeakMap</code> 集合通过 <code>set()</code> 方法添加数据，通过 <code>get()</code> 方法获取数据</p><pre><code class="js">let map1 = new WeakMap(),    element = &#123;&#125;map1.set(element, &#39;Original&#39;)let value = map1.get(element)console.log(value) // &#39;Original&#39;// 移除 element 元素element.parentNode.removeChild(element)element = null// 由于没有键对应的引用，无法通过 get() 方法获取到对应的值，Weak Map 集合自动切断了访问这个值的途径，当垃圾回收程序运行时，被这个值占用的内存将会被释放map1.get(element) // undefinedmap1.has(element) // false</code></pre></li><li><p><code>has()</code> 方法可以检测指定的 键 在集合中是否存在</p></li><li><p><code>delete()</code> 方法可以根据给定的键名，移除指定的键值对</p></li></ul><h4 id="Weak-Map-集合的初始化方法"><a href="#Weak-Map-集合的初始化方法" class="headerlink" title="Weak Map 集合的初始化方法"></a><code>Weak Map</code> 集合的初始化方法</h4><p>调用 <code>WeakMap</code> 构造函数并传入一个数组容器，容器内包含其他数组，每一个数组由两个元素够撑，第一个元素是一个键名，传入的值必须是非 <code>null</code> 的对象，第二个元素是这个键对应的值，可以实任意类型</p><h4 id="创建对象私有数据"><a href="#创建对象私有数据" class="headerlink" title="创建对象私有数据"></a>创建对象私有数据</h4><p>我们可以使用 <code>Weak Map</code> 集合来存放私有数据</p><pre><code class="js">let Person = (function() &#123;  let PrivateData = new WeakMap()  function Person1(name) &#123;    // Person 对象的实例被直接作为集合的键使用，用于跟踪数据，值是对象包含的私有数据(name)    privateData.set(this, &#123;name: name&#125;)  &#125;  // 调用 getName 是可以获得私有数据  Person1.prototype.getName = function() &#123;    return privateData.get(this).name  &#125;  return Person1&#125;)()//对象实例被销毁时，相关的信息也会被销毁</code></pre><h3 id="Weak-Map-与-Map-区别"><a href="#Weak-Map-与-Map-区别" class="headerlink" title="Weak Map 与 Map 区别"></a><code>Weak Map</code> 与 <code>Map</code> 区别</h3><ol><li><code>Weak Map</code> 只能使用 对象 作为集合的键名</li><li><code>Map</code> 的键名是强引用，<code>Weak Map</code> 的键名是弱引用</li><li><code>Weak Map</code> 集合不支持 <code>forEach()</code>, <code>clear()</code> 方法和 <code>size</code> 属性。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-Set-集合与-Map-集合&quot;&gt;&lt;a href=&quot;#ES6-Set-集合与-Map-集合&quot; class=&quot;headerlink&quot; title=&quot;ES6- Set 集合与 Map 集合&quot;&gt;&lt;/a&gt;ES6- &lt;code&gt;Set&lt;/code&gt; 集合与 &lt;code&gt;Map&lt;/code&gt; 集合&lt;/h1&gt;&lt;h2 id=&quot;Set-集合&quot;&gt;&lt;a href=&quot;#Set-集合&quot; class=&quot;headerlink&quot; title=&quot;Set 集合&quot;&gt;&lt;/a&gt;&lt;code&gt;Set&lt;/code&gt; 集合&lt;/h2&gt;&lt;p&gt;ES6 新增的 &lt;code&gt;Set&lt;/code&gt; 类型是一种有序列表，其中含有一些相互独立的 非重复值，通过 &lt;code&gt;Set&lt;/code&gt; 集合可以快速访问其中的数据，更有效的追踪各种离散值&lt;/p&gt;
&lt;h3 id=&quot;创建-Set-集合并添加元素&quot;&gt;&lt;a href=&quot;#创建-Set-集合并添加元素&quot; class=&quot;headerlink&quot; title=&quot;创建 Set 集合并添加元素&quot;&gt;&lt;/a&gt;创建 &lt;code&gt;Set&lt;/code&gt; 集合并添加元素&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;new Set()&lt;/code&gt; 创建 &lt;code&gt;Set&lt;/code&gt; 集合，调用 &lt;code&gt;add()&lt;/code&gt; 方法 可以添加元素，访问 &lt;code&gt;Set&lt;/code&gt; 集合的 &lt;code&gt;size&lt;/code&gt; 属性 可以获取集合中目前的元素数量。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;add()&lt;/code&gt; 方法 将元素添加到 &lt;code&gt;Set&lt;/code&gt; 集合中时，不会对所存的值进行强制的类型转换，所以数字 ·&lt;code&gt;5&lt;/code&gt; 与 字符串 &lt;code&gt;&amp;#39;5&amp;#39;&lt;/code&gt; 可以作为两个独立的存在， &lt;code&gt;Set&lt;/code&gt; 中的对象相互之间也保持独立。添加重复元素时，其不会被添加到集合中， &lt;code&gt;Set&lt;/code&gt; 集合中的 &lt;code&gt;size&lt;/code&gt; 属性 会保持不变。&lt;/p&gt;
&lt;h3 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h3&gt;&lt;p&gt;调用 &lt;code&gt;delete()&lt;/code&gt; 方法 可以移除 &lt;code&gt;Set&lt;/code&gt; 集合中的指定元素，调用 &lt;code&gt;clear()&lt;/code&gt; 方法 会移除集合中的所有元素&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://kerbalhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="https://kerbalhao.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
