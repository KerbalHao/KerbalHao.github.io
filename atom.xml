<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kerbalHao</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kerbalhao.github.io/"/>
  <updated>2022-04-06T10:48:44.284Z</updated>
  <id>https://kerbalhao.github.io/</id>
  
  <author>
    <name>KerbalHao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack学习</title>
    <link href="https://kerbalhao.github.io/posts/f13afe2d/"/>
    <id>https://kerbalhao.github.io/posts/f13afe2d/</id>
    <published>2022-04-06T10:48:44.284Z</published>
    <updated>2022-04-06T10:48:44.284Z</updated>
    
    <content type="html"><![CDATA[<p><code>Webpack</code> 是一个打包工具，可以在主目录创建 <code>webpack.config.js</code> 配置文件对其进行配置。</p><a id="more"></a><p>配置内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js 配置</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-weback-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);<span class="comment">// css 文件提取插件，无此插件，css 与 js 被编译到同一个文件</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>); <span class="comment">//打包前清理输出目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有以下插件的情况下，在 webpack 提取出的 js 和 css 文件中，只会压缩 js 文件，不会压缩 css 文件，因此，需要手动配置插件压缩 css 文件，但是手动压缩 css 文件后， js 文件也需要手动压缩</span></span><br><span class="line"><span class="keyword">const</span> TerserJSPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>); <span class="comment">//压缩js</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>); <span class="comment">// 压缩 css</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">  entry: entrfile.js <span class="comment">// 配置总的入口文件</span></span><br><span class="line"></span><br><span class="line">  output ：&#123; </span><br><span class="line">    filename: output.js,<span class="comment">// 配置创建的出口文件名</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'output.js'</span>) <span class="comment">// 输出文件的路径， path.resolve 是 node.js 的 path 库自带的api, 用于拼接绝对路径，__dirname 表示当前目录</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以下是可选项</span></span><br><span class="line">  devServer: &#123;<span class="comment">// 配置 webpack 的开发服务器，使用该服务器需要在 package.json 中设置命令调用 "webpack-dev-server"</span></span><br><span class="line">    port: <span class="number">8080</span>,<span class="comment">//端口号</span></span><br><span class="line">    open: <span class="literal">true</span>, <span class="comment">//布尔值，是否自动打开页面</span></span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">//布尔值。是否启动gzip压缩</span></span><br><span class="line">    contentBase: <span class="string">'aa'</span> <span class="comment">//放置静态资源文件文件夹的路径，可在服务器上直接访问</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  optimization: &#123; <span class="comment">// 优化方法</span></span><br><span class="line">      <span class="comment">// 注册压缩器</span></span><br><span class="line">      minimizer: [<span class="keyword">new</span> TerserJSPlugin(&#123;&#125;), <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)],</span><br><span class="line">     &#125;,</span><br><span class="line">   </span><br><span class="line">  plugins: [ <span class="comment">// 注册并配置 webpack 相关插件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="comment">//插件，用于自动将模板文件内的 js 路径编译为打包后的 js 文件路径，该插件需要使用 require('html-webpack-plugin') 引用</span></span><br><span class="line">      template: <span class="string">'index.js'</span>, <span class="comment">//模板文件绝对路径，</span></span><br><span class="line">      filename: <span class="string">'bundle.js'</span> <span class="comment">//输出替换换后的文件名</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MiniExtractPlugin(&#123;</span><br><span class="line">        filename:<span class="string">"css/main.css"</span> <span class="comment">// 设置提取出来的 css 名称</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123; <span class="comment">// 确定哪些文件需要转换，需要使用什么 loader 去进行转化</span></span><br><span class="line"></span><br><span class="line">    rules: [ <span class="comment">// 需要注意 loader 配置的顺序，按数组反向加载，即从后往前</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>使用正则表达式匹配需要转换的文件，</span><br><span class="line">        use:  [</span><br><span class="line">          &#123; <span class="comment">// 使用 css 提取插件以后，css 不再使用 style 标签引用，而是使用 link 标签引用，因此需要使用以下 loader</span></span><br><span class="line">            loader:MiniExtractPlugin.loader</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; <span class="comment">// 此处是为了解析 在 css 文件内引用了 less 文件的嵌套的情况</span></span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">1</span> <span class="comment">// 表示用后面的 1 个 loader 去解析</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">"postcss-loader"</span>, <span class="comment">//使用 postcss loader</span></span><br><span class="line">          <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>, <span class="comment">//使用正则表达式 匹配需要转换的文件</span></span><br><span class="line">        use:  [<span class="string">'style-loader'</span>,<span class="string">"css-loader"</span>, <span class="string">'less-loader'</span>] <span class="comment">// 配置对应的loader,需要注意 loader 配置的顺序，</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>postcss-loader</code> 样式处理工具，可以借助自定义的插件重新定义 <code>css</code></p><p>比如加私有前缀的插件 <code>autoprefixer</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//postcss.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="comment">//配置插件</span></span><br><span class="line">  plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Webpack&lt;/code&gt; 是一个打包工具，可以在主目录创建 &lt;code&gt;webpack.config.js&lt;/code&gt; 配置文件对其进行配置。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JS类型检测</title>
    <link href="https://kerbalhao.github.io/posts/b6a5ef32/"/>
    <id>https://kerbalhao.github.io/posts/b6a5ef32/</id>
    <published>2022-04-06T10:48:44.280Z</published>
    <updated>2022-04-06T10:48:44.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h1><p>JS 中有多个可以检测数据类型的方法，比如：</p><ul><li><p>typeof</p></li><li><p>instanceof</p></li><li><p>constructor</p></li><li><p>Object.prototype.toString.call(instance)</p></li></ul><p>但是它们基本都有一些不足，接下来就让我来一一说明一下</p><a id="more"></a><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>我们经常使用 typeof 判断数据的类型，其性能很高，但是它有两个致命的缺陷：</p><ol><li><code>typeof null === &#39;object&#39; // =&gt; true</code><ol><li>对 <code>null</code> 使用 <code>typeof</code> 会返回 <code>object</code></li><li>这是因为 <code>typeof</code> 是浏览器底层基于二进制对值进行判断，对象类型是用 000 开头的二进制储存的，而 <code>null</code> 的二进制值是全为 0，因此它会被 <code>typeof</code> 判断为 <code>object</code></li></ol></li><li>对除了 <code>Function</code> 以外的原生对象类型使用 <code>typeof</code>，其都只返回一个 <code>object</code></li></ol><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>a instanceof b</code> 可以被认为判断在 a 的原型链上是否存在 b 的原型对象，可以简单的认为判断 a 是否为 b 的实例对象。<br>话虽如此，但是因为在 JS 中，我们可以随意改变原型的指向，因此此方法并不一定准确，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">fn.prototype = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> fn();</span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>此外， instanceof 无法判断基本类型在上述代码中，fn 是一个函数，但是我们通过将其的原型对象指定为 Array 的原型对象，导致 Array 的原型对象出现在 fn 的实例的原型链上，因此返回了 true。</p><p>在我们知道了 instanceof 的原理之后，我们可以自己实现一个 instanceof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">instance, classFunc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> classFuncProto = classFunc.prototype; <span class="comment">// 获取父类的原型</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototype(proto); <span class="comment">// 获取实例的原型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归获取实例原型链上的原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 当实例原型链原型走到了 Object.prototype 即 null 时，</span></span><br><span class="line">    <span class="comment">// 表示整个原型链都不存在父类原型</span></span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === classFuncProto) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototype(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>正如我们所知，一个实例的 constructor 等于其构造函数的 constructor，因此我们可以根据这个原理来判断对象的数据类型。constructor</p><p>但是，它也和 instanceof 一样，JavaScript 自身并不能确保正确的 <code>constructor</code> 函数值。它只存在于函数的默认 <code>prototype</code> 中，可以被随时改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> fn();</span><br><span class="line">f.constructor === fn; <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 fn 的构造函数指向</span></span><br><span class="line">fn.prototype.constructor = <span class="built_in">Array</span>;</span><br><span class="line">f.constructor === fn; <span class="comment">// =&gt; false</span></span><br><span class="line">f.constructor === <span class="built_in">Array</span>; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="Object-prototype-toString-call-instance"><a href="#Object-prototype-toString-call-instance" class="headerlink" title="Object.prototype.toString.call(instance)"></a>Object.prototype.toString.call(instance)</h2><p>其返回的值可能是: [object Number/String/Boolean/Null/Undefined/Symbol/Object/Array/RegExp/Date/Function]<br>这个方法可以说是究极方法了，这个方法用的是原型链最顶端的 toString 方法，通过调用 call 将 this 绑定到要检测的对象身上，会返回一个字符串”[object Type ]”，Type 是判断出来的类型。</p><p>该方法的缺点在于代码太长，如果判断基本类型的话，我们也可以直接使用 typeof 来检测，因此我们可以考虑优化一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;</span><br><span class="line">ve toString = class2type.toString</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置映射表</span></span><br><span class="line">[<span class="string">'Boolean'</span>,<span class="string">'Number'</span>,<span class="string">'String'</span>,<span class="string">'Function'</span>,<span class="string">'Array'</span>,<span class="string">'Date'</span>,<span class="string">'RegExp'</span>,<span class="string">'Object'</span>,<span class="string">'Error'</span>,<span class="string">'Symbol'</span>].forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  class2type[<span class="string">`[object <span class="subst">$&#123;name&#125;</span>]`</span>] =name.toLowerCase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj + <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) ? class2type[toString.call(obj)] : <span class="keyword">typeof</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类型检测&quot;&gt;&lt;a href=&quot;#类型检测&quot; class=&quot;headerlink&quot; title=&quot;类型检测&quot;&gt;&lt;/a&gt;类型检测&lt;/h1&gt;&lt;p&gt;JS 中有多个可以检测数据类型的方法，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;typeof&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;instanceof&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;constructor&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Object.prototype.toString.call(instance)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是它们基本都有一些不足，接下来就让我来一一说明一下&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浏览器是如何渲染网页的？——DOM,CSSOM以及渲染</title>
    <link href="https://kerbalhao.github.io/posts/65f9e7b2/"/>
    <id>https://kerbalhao.github.io/posts/65f9e7b2/</id>
    <published>2021-04-17T02:35:10.000Z</published>
    <updated>2022-04-06T10:48:44.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自 Uday Hiwarale 的 <a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969">How the browser renders a web page? — DOM, CSSOM, and Rendering</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当你开发一个网站的时候，有些东西对于良好的用户体验来说是非常必要的。网站可能遇到的一些常见问题可能是资源加载缓慢，在初始渲染时等待不必要的文件下载，样式未应用的内容闪烁<code>(flash of unstyled content (FOUC))</code>等。为了避免类似问题，我们需要了解浏览器渲染典型网页的生命周期。</p><p>首先，我们需要了解什么是 <code>DOM</code>。当浏览器相服务器发送请求，获取一个 <code>HTML</code> 文档的时候，服务器会返回一个二进制流格式的 <code>HTML</code> 页面，它基本就是一个文本文件，其响应头的 <code>Content-Type</code> 设置为 <code>text/html;charset-UTF-8</code>。这里的 <code>text/html</code> ·是一个 <a href="https://en.wikipedia.org/wiki/Media_type">MIME 类型</a>，它告诉浏览器这是一个 <code>HTML</code> 文档，<code>charset=UTF-8</code> 告诉浏览器它是以 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> 字符<a href="https://medium.com/jspoint/introduction-to-character-encoding-3b9735f265a6">编码</a>的。利用这些信息，浏览器剋将二进制格式转换为可读的文本文件。如下图所示。<br><img src="https://i.loli.net/2021/04/17/c1MpWG2FosgNrhl.png" alt="1_Tm-HPhmGA0BL7HIj38H8Qw.png"></p><p>如果该 <code>header</code> 缺失，浏览器将无法理解如何处理该文件，它将以纯文本格式呈现。但如果一切正常，经过这次转换后，浏览器就可以开始阅读 <code>HTML</code> 文档了。一个典型的 <code>HTML</code> 文档大致如下:</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Rendering Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- stylesheet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./style.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a sample paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- script --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的文档中，我们的网页依赖 <code>style.css</code> 给 <code>HTML</code> 元素提供样式，<code>main.js</code> 来执行一些 <code>JavaScript</code> 操作。通过一些 <code>CSS</code> 样式，我们上面的网页就会变成这样：<br><img src="https://i.loli.net/2021/04/17/c1MpWG2FosgNrhl.png" alt="1_Tm-HPhmGA0BL7HIj38H8Qw.png"></p><p>但问题还是在于，浏览器是如何从一个简单的，只包含文本的 <code>HTML</code> 文件渲染出这个好看的网页呢？为此，我们需要了解什么是 <code>DOM</code>、<code>CSSOM</code> 和 <code>Render Tree</code></p><h3 id="Document-Object-Model-DOM"><a href="#Document-Object-Model-DOM" class="headerlink" title="Document Object Model (DOM)"></a>Document Object Model (DOM)</h3><p>当浏览器读取 <code>HTML</code> 代码时，只要遇到 <code>body、div</code> 等 <code>HTML</code> 元素，就会创建一个名为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node">Node</a> 的 <code>JavaScript</code> 对象。</p><p>由于每个 HTML 元素都有不同的属性，所以 Node 对象将从不同的类(构造函数)中创建。例如，div 元素的 Node 对象是由继承自 Node 类的 HTMLDivElement 创建的。对于我们前面的 HTML 文档，我们可以用一个简单的测试来可视化这些节点，如下图：<br><img src="https://i.loli.net/2021/04/18/FhZEbDYPlCBifR2.png" alt="1618739869298.png"></p><p>浏览器自带了 <code>HTMLDivElement、HTMLScriptElement、Node</code> 等内置类。</p><p>浏览器从 HTML 文档中创建了 <code>Node</code> 之后，就要把这些节点对象创建成树状结构。由于我们在 <code>HTML</code> 文件中的 <code>HTML</code> 元素是互相嵌套的，所以浏览器需要使用之前创建的 <code>Node</code> 对象复制它们。这将帮助浏览器在网页的整个生命周期中高效地渲染和管理网页。</p><p><img src="https://i.loli.net/2021/04/18/FhZEbDYPlCBifR2.png" alt="1618739869298.png"></p><p>我们之前的 <code>HTML</code> 文档的 <code>DOM</code> 树就像上面一样。一棵 <code>DOM</code> 树从最上面的 <code>html</code> 元素开始，根据 <code>HTML</code> 元素在文档中的出现和嵌套情况进行分支。每当发现一个 <code>HTML</code> 元素时，它就会从其各自的类中创建一个 <code>DOM</code> 节点（Node）对象（构造函数）。</p><blockquote><p>一个 <code>DOM</code> 节点并不总是必须是一个 <code>HTML</code> 元素。当浏览器创建 <code>DOM</code> 树时，它也会将注释、属性、文本等内容作为树中的单独节点保存。但为了简单起见，我们只考虑 <code>HTML</code> 元素的 <code>DOM</code> 节点，也就是 <code>DOM</code> 元素。<a href="https://www.w3schools.com/jsref/prop_node_nodetype.asp">这里</a>是所有 <code>DOM</code> 节点类型的列表。</p></blockquote><p>你可以在 <code>Google Chrome DevTools Console</code> 中看到 <code>DOM</code> 树，如下所示。这将显示 <code>DOM</code> 元素的层次结构（DOM 树的高级视图）以及每个 <code>DOM</code> 元素的属性。<br><img src="https://i.loli.net/2021/04/18/je8gfiSnCUZ9bY4.png" alt="1618742342888.png"></p><p><code>JavaScript</code> 不明白 <code>DOM</code> 是什么，它不是 <code>JavaScript</code> 规范的一部分。DOM 是浏览器提供的一种高级 <a href="https://developer.mozilla.org/en-US/docs/Web/API">Web API</a>，用于高效地渲染网页，供开发者动态操作 DOM 元素以达到各种目的。</p><blockquote><p>使用 DOM API，开发者可以添加或删除 HTML 元素，改变其外观或绑定事件监听器。使用 DOM API，可以在内存中创建或克隆 HTML 元素，并在不影响 DOM 树的情况下进行修改。这使得开发者有能力构建高度动态的网页，并提供丰富的用户体验。</p></blockquote><h3 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h3><p>当我们设计一个网站时，我们的目的是让它尽可能的好看。而我们通过为 <code>HTML</code> 元素提供一些样式来实现。在 <code>HTML</code> 页面中，我们使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS">CSS</a>(Cascading Style Sheets，即层叠样式表) 为 <code>HTML</code> 元素提供样式。使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS 选择器</a>，我们可以针对 <code>DOM</code> 元素，为样式属性设置一个值，比如颜色或字体大小。</p><p>将样式应用到 <code>HTML</code> 元素上有不同的方法，比如使用外部 <code>CSS</code> 文件、使用 <code>&lt;style&gt;</code> 标签嵌入 <code>CSS</code>、使用 <code>HTML</code> 元素上的 <code>style</code> 属性的内联方法或使用 <code>JavaScript</code>。但最终，浏览器还是要担起将 <code>CSS</code> 样式应用到 <code>DOM</code> 元素上的重任。</p><p>比方说，对于我们前面的例子，我们将使用下面的 <code>CSS</code> 样式（这不是截图中显示的卡片所使用的 <code>CSS</code>）。为了简单起见，我们不打算理会如何在 <code>HTML</code> 页面中导入 <code>CSS</code> 样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构建了 <code>DOM</code> 之后，浏览器从所有的源头（外部的、嵌入式的、内嵌的、用户代理的等）读取 <code>CSS</code> ，并构建一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSSOM</a>。<code>CSSOM</code> 是 <code>CSS</code> 对象模型的缩写，它和 <code>DOM</code> 一样是一个树状结构。</p><p>这个树中的每个节点都包含 <code>CSS</code> 样式信息，这些信息将被应用到它所针对的 <code>DOM</code> 元素上（由选择器指定）。然而，<code>CSSOM</code> 并不包含那些不能在屏幕上打印的 <code>DOM</code> 元素，如<code>&lt;meta&gt;、&lt;script&gt;、&lt;title&gt;</code>等。</p><p>我们知道，大多数浏览器都自带样式表，这个样式表被称为<a href="https://stackoverflow.com/questions/12582624/what-is-a-user-agent-stylesheet">用户代理样式表</a>，浏览器首先用开发者属性提供的 <code>CSS</code> 覆盖用户代理样式（使用特定性的规则），计算出 <code>DOM</code> 元素的最终 <code>CSS</code> 属性，然后构造一个节点。</p><p>即使某个 <code>HTML</code> 元素的 <code>CSS</code> 属性（如 <code>display</code> ）没有被开发者或浏览器定义，其值也会被设置为 <a href="https://www.w3.org/Style/CSS/">W3C CSS</a> 标准规定的该属性的默认值。在选择 <code>CSS</code> 属性的默认值时，如果某个属性符合 <a href="https://www.w3.org/TR/CSS1/#inheritance">W3C 文档</a>中提到的继承规则，则会使用一些继承规则。</p><p>例如，如果一个 <code>HTML</code> 元素缺少颜色和字体大小等属性，那么这些属性就会继承父元素的值。所以你可以想象一下，在一个 <code>HTML</code> 元素上有这些属性，它的所有子元素都会继承它。这就是所谓的样式层叠，这也是为什么 <code>CSS</code> 是层叠样式表的缩写。这也正是浏览器构建一个树状结构的<code>CSSOM</code> 的原因，用于根据 <code>CSS</code> 层叠规则计算样式。</p><blockquote><p>您可以在 Element 面板中使用 Chrome DevTools 控制台查看 HTML 元素的计算样式。从左侧面板中选择任意一个 HTML 元素，然后点击右侧面板中的计算选项卡。</p></blockquote><p>我们可以用下图来使前面例子的 <code>CSSOM</code> 树可视化。为了简单起见，我们将忽略用户代理样式，而专注于前面提到的 <code>CSS</code> 样式。</p><p><img src="https://i.loli.net/2021/04/18/gvaLepK5cSJRzqG.png" alt="1618747003004.png"></p><p>从上图中可以看出，我们的 <code>CSSOM</code> 树中不包含<code>&lt;link&gt;、&lt;title&gt;、&lt;script&gt;</code>等不会被打印到屏幕上的元素。红色的 <code>CSS</code> 属性值是从顶部层叠下来的，而灰色的属性值则是覆盖了继承的值。</p><h3 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h3><p><code>Render-Tree</code> 也是一个将 <code>DOM</code> 树和 <code>CSSOM</code> 树组合在一起构建的树状结构。浏览器要计算每个可见元素的布局，并把它们画在屏幕上，为此浏览器使用了这个 <code>Render-Tree</code>。因此，如果没有构建 <code>Render-Tree</code>，那么任何东西都不会被打印在屏幕上，这就是为什么我们同时需要 DOM 和 CSSOM 树。</p><p>由于 <code>Render-Tree</code> 是对最终将被打印在屏幕上的内容的低级表示，它不会包含在像素矩阵(页面)中不包含任何区域(一定情况下可认为是：不占空间)的节点。例如，<code>display:none</code>;元素的尺寸为<code>0px X 0px</code>，因此它们不会出现在 <code>Render-Tree</code> 中。</p><p><img src="https://i.loli.net/2021/04/18/zRgLKcTsIUxMAie.png" alt="1618747752887.png"></p><p>从上图可以看出，<code>Render-Tree</code> 结合了 <code>DOM</code> 和 <code>CSSOM</code>，生成了一个树状结构，其中只包含了要打印在屏幕上的元素。</p><p>因为在 <code>CSSOM</code> 中，位于 <code>div</code> 内的 <code>p</code> 元素被设置了 <code>display:none;</code> 样式，所以它和它的子元素不会出现在 <code>Render-Tree</code> 中，因为它在屏幕上不占空间。但是，如果你有 <code>visibility:hidden</code> 或 <code>opacity:0</code> 的元素，它们将占据屏幕空间，因此它们将出现在 <code>Render-Tree</code> 中。</p><p>与 <code>DOM API</code> 不同的是<code>，DOM API</code> 可以访问浏览器构建的 <code>DOM</code> 树中的 <code>DOM</code> 元素，而 <code>CSSOM</code> 则是对用户隐藏的。但由于浏览器将 <code>DOM</code> 和 <code>CSSOM</code> 结合在一起形成了 <code>Render Tree</code>，所以浏览器通过在 <code>DOM</code> 元素本身提供高级 <code>API</code> 来暴露 <code>DOM</code> 元素的 <code>CSSOM</code> 节点。这样开发者就可以访问或改变 <code>CSSOM</code> 节点的 <code>CSS</code> 属性。</p><blockquote><p>由于使用 <code>JavaScript</code> 操作元素的样式超出了本文的范围，所以这里有一个 <a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/">CSS Tricks 文章的链接</a>，它涵盖了 <code>CSSOM API</code> 的广泛范围。我们还有新的 <code>JavaScript</code> 中的 <a href="https://developers.google.com/web/updates/2018/03/cssom">CSS Typed Object API</a>，它可以更准确地操纵元素的样式。</p></blockquote><h2 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h2><p>现在我们已经很好地理解了什么是 <code>DOM、CSSOM</code>和 <code>Render-Tree</code>，让我们了解一下浏览如何使用它们来渲染一个典型的网页。对这个过程有一个最起码的了解对任何 Web 开发人员来说都是至关重要的，因为它将帮助我们设计我们的网站以获得最大的用户体验（UX）和性能。</p><p>当一个网页被加载时，浏览器首先读取 <code>HTML</code> 文本并从中构建 <code>DOM</code> 树。然后它处理 <code>CSS</code>，无论是内嵌的、嵌入式的、还是外部的 <code>CSS</code>，并从中构建 <code>CSSOM</code> 树。</p><p>构建完这些树后，它再从中构建 <code>Render-Tree</code>。一旦构建了 <code>Render-Tree</code>，浏览器就会开始在屏幕上打印各个元素。</p><h3 id="布局操作"><a href="#布局操作" class="headerlink" title="布局操作"></a>布局操作</h3><p>首先浏览器创建每个单独的 <code>Render-Tree</code> 节点的布局。布局包括每个节点的大小（以像素为单位）和它将被打印在屏幕上的位置。这个过程被称为布局，因为浏览器正在计算每个节点的布局信息。</p><p>这个过程也被称为回流或浏览器回流(reflow)，当你滚动、调整窗口大小或操作 DOM 元素时，也会发生这个过程。<a href="https://stackoverflow.com/a/27637245/2790983">这里</a>是可以触发元素布局/回流的事件列表。</p><blockquote><p>我们应该避免网页因为微不足道的原因进行多次布局操作，因为这是一种昂贵的操作。<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">这里</a>是 <a href="https://twitter.com/aerotwist">Paul Lewis</a> 的一篇文章，他讲述了我们如何避免复杂而昂贵的布局操作以及<a href="https://kellegous.com/j/2013/01/26/layout-performance/">布局打乱</a>。</p></blockquote><h3 id="绘制操作"><a href="#绘制操作" class="headerlink" title="绘制操作"></a>绘制操作</h3><p>直到现在，我们还有一个需要打印在屏幕上的几何体列表。由于 <code>Render-Tree</code> 中的元素（或子树）可以相互重叠，而且它们可以具有 <code>CSS</code> 属性，使它们经常改变外观、位置或几何显示（如动画），因此浏览器会为它创建一个图层。</p><p>创建图层可以帮助浏览器在网页的整个生命周期中高效地执行绘制操作，比如在滚动或调整浏览器窗口大小的时候。拥有图层还可以帮助浏览器按照开发者的意图，正确地按照堆叠顺序（沿 z 轴）绘制元素。</p><p>现在我们有了图层，我们可以将它们组合起来，并在屏幕上绘制。但是浏览器并不是一次性绘制所有的图层。每个图层都是先单独绘制的。</p><p>在每个图层里面，浏览器会对元素的任何可见属性，如边框、背景色、阴影、文字等进行单独的像素填充。这个过程也被称为栅格化。为了提高性能，浏览器可以使用不同的线程来执行栅格化。</p><p>Photoshop 中图层的类比也可以应用到浏览器渲染网页的方式。您可以从 Chrome DevTools 中看到网页上的不同图层。打开 DevTools，从更多工具选项中选择 “Layers”。您还可以从 “Rendering” 面板中看到图层边框。</p><blockquote><p>栅格化通常是在 CPU 中完成的，这使得它的速度很慢，而且成本很高，但是我们现在有了新的技术，可以在 GPU 中进行性能提升。这篇 <a href="https://software.intel.com/en-us/articles/software-vs-gpu-rasterization-in-chromium">intel 文章</a> 详细介绍了绘画主题，这是一篇必读的文章。要想详细了解图层的概念，<a href="https://www.html5rocks.com/en/tutorials/speed/layers/">这是</a>一篇必读的文章。</p></blockquote><h3 id="合成操作"><a href="#合成操作" class="headerlink" title="合成操作"></a>合成操作</h3><p>到目前为止，我们还没有在屏幕上绘制一个像素。我们拥有的是不同的图层（位图图像），它们应该按照特定的顺序绘制在屏幕上。在合成操作中，这些图层会被发送到 GPU 上，最终将其绘制在屏幕上。</p><p>每次回流（布局）或重绘时都要将整个图层送去绘制，这显然是很低效的。因此，一个图层被分解成不同的块，然后将其绘制在屏幕上。你也可以在 Chrome 的 DevTool Rendering 面板中看到这些块。</p><p>从上面的信息中，我们可以从简单的 HTML 和 CSS 文本内容中，构建出一整个 浏览器从一个网页到在屏幕上渲染出事物所经历的事件顺序。<br><img src="https://i.loli.net/2021/04/19/3QBv7VMJEYdSgef.png" alt="1618750000712.png"></p><p>这个事件顺序也被称为 <strong><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path">关键渲染路径</a></strong></p><blockquote><p><a href="https://twitter.com/kosamari">Mariko Kosaka</a> 为这个流程写了一篇<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">漂亮的文章</a>，有酷炫的插图和对每个概念的更广泛的解释。强烈推荐。</p></blockquote><h3 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h3><p>创建 <code>DOM</code> 树、<code>CSSOM</code> 树和处理渲染逻辑的工作是由一个叫做浏览器引擎（也称为渲染引擎或布局引擎）的浏览器进程来完成的，它位于浏览器内部。这个浏览器引擎包含了，将一个网页从 HTML 代码，渲染到屏幕上的实际像素的，所有必要的元素和逻辑。</p><p>如果你听到人们谈论 WebKit，他们说的是一个浏览器引擎。WebKit 被苹果的 Safari 浏览器使用，也是谷歌 Chrome 浏览器的默认渲染引擎。截至目前， Chromium 项目使用 Blink 作为默认渲染引擎。<a href="https://stackoverflow.com/a/3468311/2790983">这里</a>是一些顶级网络浏览器使用的不同浏览器引擎的列表。</p><h2 id="浏览器的渲染流程"><a href="#浏览器的渲染流程" class="headerlink" title="浏览器的渲染流程"></a>浏览器的渲染流程</h2><p>我们都知道 <code>JavaScript</code> 语言是通过 <code>ECMAScript</code> 标准来实现标准化的，其实由于 <code>JavaScript</code> 被注册为商标，所以我们现在只叫它 <code>ECMAScript</code>。因此，每一个 <code>JavaScript</code> 引擎提供商，如 V8、Chakra、Spider Monkey 等都要遵守这个标准的规则。</p><p>有了标准，我们就可以在所有 JavaScript 运行时，如浏览器、Node、Deno 等，获得一致的 JavaScript 体验。这对于多平台的 JavaScript（和 Web）应用的一致和完美的开发是非常好的。</p><p>然而，浏览器的渲染方式却并非如此。HTML、CSS 或 JavaScript，这些语言都是由某个实体或某个组织标准化的。然而，浏览器如何将它们管理在一起，在屏幕上呈现东西，却不是标准化的。谷歌 Chrome 的浏览器引擎可能会与 Safari 的浏览器引擎做不同的事情。</p><p>因此，很难预测特定浏览器的渲染顺序及其背后的机制。然而，HTML5 规范已经做出了一些努力，在理论上标准化渲染应该如何工作，但浏览器如何遵守这一标准完全取决于它们。</p><p>尽管存在这些不一致的地方，但所有浏览器之间通常都有一些共同的原则。让我们来了解一下浏览器在屏幕上渲染事物的常见方法，以及这个过程的生命周期事件。</p><h3 id="解析和外部资源"><a href="#解析和外部资源" class="headerlink" title="解析和外部资源"></a>解析和外部资源</h3><p>解析是指读取 HTML 内容并从中构建 DOM 树的过程。因此，这个过程也被称为 DOM 解析，完成这个过程的程序被称为 DOM 解析器。</p><p>大多数浏览器都提供了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMParser">DOMParser</a> Web API 来从 HTML 代码中构建 DOM 树。 <code>DOMParser</code> 类的一个实例代表了一个 DOM 解析器，使用 <code>parseFromString</code> 原型方法，我们可以将原始的 HTML 文本（代码）解析成一棵 DOM 树（如下图所示）。<br><img src="https://ftp.bmp.ovh/imgs/2021/04/b22c5a336e8ce5c5.png" alt=""></p><p>当浏览器请求一个网页，服务器响应一些 HTML 文本（Content-Type 头设置为 text/html）时，浏览器可能会在整个文档的几个字符或几行字可用时就开始解析 HTML。因此，浏览器可以逐步建立 DOM 树，一次一个节点。浏览器从上到下解析 HTML，而不是中间的任何地方，因为 HTML 代表了一个嵌套的树状结构。</p><p><img src="https://ftp.bmp.ovh/imgs/2021/04/6536b577a670503c.gif" alt=""></p><p>在上面的例子中，我们从 Node 服务器访问了 <code>incremental.html</code> 文件，并将网络速度设置为只有 <strong>10kbps</strong>（从网络面板）。由于浏览器加载（下载）这个文件需要很长的时间（因为它包含 1000 个 h1 元素），所以浏览器从最初的几个字节构建了一个 DOM 树，并将它们打印在屏幕上（因为它在后台下载 HTML 文件的剩余内容）。</p><p><img src="https://ftp.bmp.ovh/imgs/2021/04/ff674951ed4cf697.png" alt=""></p><p>如果你看一下上面请求的性能图，你就能在 Timing 行看到一些事件。这些事件通常被称为 <strong>性能指标</strong>。当这些事件放在尽可能近的地方，并且尽可能早的发生，用户体验会更好。</p><p><code>FP</code> 是 <code>First Paint</code> 的缩写，意思是浏览器开始在屏幕上打印东西的时间（可以简单到正文背景色的第一个像素）。</p><p><code>FCP</code> 是 <code>First Contentful Paint</code> 的缩写，意思是浏览器渲染出文字或图片等内容的第一个像素的时间。<code>LCP</code> 是 <code>Largest Contentful Paint</code> 的缩写，是指浏览器渲染大块文字或图片的时间。</p><p><code>L</code> 代表 <code>onload</code> 事件，它是由浏览器在 <code>window</code> 对象上发出的。同样，<code>DCL</code> 代表 <code>DOMContentLoaded</code> 事件，它是在 <code>document</code> 对象上发出的，但会冒泡到 <code>window</code> 上，因此你也可以在 <code>window</code> 上监听它。这些事件理解起来有点复杂，所以我们稍后会讨论它们。</p><p>每当浏览器遇到一个外部资源，如通过 <code>&lt;script src=&quot;url&quot;&gt;&lt;/script&gt;</code> 元素的脚本文件（JavaScript）、通过 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;url&quot;/&gt;</code> 标签的样式表文件（CSS）、通过 <code>&lt;img src=&quot;url&quot; /&gt;</code> 元素的图像文件或任何其他外部资源，浏览器将在后台（JavaScript 执行的主线程之外）开始下载该文件。</p><p>最重要的一点是，DOM 解析通常发生在主线程上。因此，如果主 JavaScript 执行线程很忙，DOM 解析将无法进行，直到该线程空闲下来。你可能会问为什么这么重要？因为脚本元素是会阻塞解析器的。除了脚本(.js)文件请求外，每一个外部文件请求，如图片、样式表、pdf、视频等都不会阻塞 DOM 的构建(解析)。</p><h3 id="解析器阻塞型脚本-Parser-Blocking-Scripts"><a href="#解析器阻塞型脚本-Parser-Blocking-Scripts" class="headerlink" title="解析器阻塞型脚本(Parser-Blocking Scripts)"></a>解析器阻塞型脚本(Parser-Blocking Scripts)</h3><p>解析器阻塞型脚本是一个 <code>script</code>（JavaScript）文件/代码，它可以停止对 HTML 的解析。当浏览器遇到一个 <code>script</code> 元素时，如果它是一个嵌入式 <code>script</code>，那么它将首先执行该 <code>script</code>，然后继续解析 HTML，构建 DOM 树。所以所有的嵌入式 <code>script</code>都是解析器阻塞型的，讨论结束。</p><p>如果 <code>script</code> 元素是外部 <code>script</code> 文件，浏览器会在主线程之外开始下载外部 <code>script</code> 文件，但在该文件下载完毕之前，会停止主线程的执行。这意味着在 <code>script</code> 文件下载之前，不会再进行 DOM 解析。</p><p>一旦 <code>script</code> 文件下载完毕，浏览器将首先在主线程上执行下载好的 <code>script</code> 文件，然后继续进行 DOM 解析。如果浏览器再次发现 HTML 中的其他 <code>script</code> 元素，就会执行同样的操作。那么为什么浏览器要停止 DOM 解析，直到 JavaScript 被下载并执行？</p><p>浏览器将 DOM API 暴露给 JavaScript 运行时，这意味着我们可以从 JavaScript 中访问和操作 DOM 元素。这就是 React 和 Angular 等动态 Web 框架的工作方式。但如果浏览器希望并行运行 DOM 解析和 <code>script</code> 执行，那么 DOM 解析线程和主线程之间可能会出现<a href="https://stackoverflow.com/questions/34510/what-is-a-race-condition"><strong>竞赛条件</strong></a>，这就是为什么 DOM 解析必须在主线程上进行。</p><p>然而，在后台下载 <code>script</code> 文件时停止 DOM 解析，在大多数情况下是完全没有必要的。因此，HTML5 为我们提供了 <code>script</code> 标签的 <code>async</code> 属性。当 <code>DOM</code> 解析器遇到一个带有 <code>async</code> 属性的外部 <code>script</code> 元素时，它不会在后台下载 <code>script</code> 文件时停止解析过程。但是一旦文件下载完毕，解析过程就会停止，<code>script</code>（代码）就会被执行。</p><p>我们还为 <code>script</code> 元素设置了一个神奇的 <code>defer</code> 属性，它的工作原理与 <code>async</code> 属性类似，但与 <code>async</code> 属性不同的是，即使文件完全下载完毕，<code>script</code> 也不会执行。一旦解析器解析了所有的 HTML，也就是说 DOM 树已经完全构建完成，所有的 <code>defer</code> <code>script</code>就会被执行。与异步 <code>script</code> 不同的是，所有的延迟 <code>script</code> 是按照它们在 HTML 文档（或 DOM 树）中出现的顺序来执行的。</p><p>所有普通的 <code>script</code>（嵌入式或外部）都是解析器阻塞型的，因为它们停止了 DOM 的构建。所有异步 <code>script</code> 在下载之前不会阻塞解析器。一旦一个异步 <code>script</code> 被下载，它就变成了阻断解析器的 <code>script</code>。然而，所有的 <code>defer</code> 脚本都是非阻断解析器型的脚本，因为它们不阻断解析器，并且在 DOM 树完全构建完成后执行。<br><img src="https://ae01.alicdn.com/kf/U798f6fa385254155a4e7105fbc84894a9.jpg" alt=""></p><p>在上面的例子中，parser-blocking.html 文件在 30 个元素后包含了一个阻塞解析的脚本，这就是为什么浏览器一开始显示 30 个元素，停止 DOM 解析，并开始加载脚本文件的原因。第二个脚本文件由于有 defer 属性，所以不会阻止解析，所以一旦 DOM 树完全构建完成，它就会执行。<br><img src="https://ae01.alicdn.com/kf/Uc714a2f94cfa4ff49431509a91bcab5aY.jpg" alt=""></p><p>如果我们看一下 <strong>Performance</strong> 面板，<code>FP</code> 和 <code>FCP</code> 会尽快发生（隐藏在 <strong>Timings</strong> 标签后面），因为浏览器一有 HTML 内容就开始建立 DOM 树，因此可以在屏幕上渲染一些像素。</p><p><code>LCP</code> 发生在 5 秒后，因为阻塞解析器的脚本已经阻断了 5 秒的 DOM 解析（它的下载时间），当 DOM 解析器被阻断时，屏幕上只呈现了 30 个文本元素，这不足以被称为最大的内容绘制（根据 Google Chrome 标准）。但是一旦下载并执行该脚本，DOM 解析就恢复了，并且在屏幕上呈现了大量的内容，这导致了 LCP 事件的触发。</p><blockquote><p>Parser-blocking 也被称为 render-blocking，因为除非 DOM 树被构造出来，否则渲染是不会发生的，但这两者是完全不同的事情，我们稍后会看到</p></blockquote><p>一些浏览器可能会包含一个<a href="https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing">推测性解析</a>策略，即 HTML 解析（但不包括 DOM 树的构建）被挂载到一个单独的线程中，这样浏览器就可以读取链接（CSS）、script、img 等元素，并更早地下载这些资源。</p><p>这对于以下这种情况来说是很有用的，比如你有三个紧贴的 <code>script</code> 元素，但由于 DOM 解析器无法读取第二个 <code>script</code> 元素，所以在第一个 <code>script</code> 下载完毕之前，浏览器无法开始下载第二个 <code>script</code>。我们可以通过使用 <code>async</code> 标签轻松解决这个问题，但是异步脚本不能保证按顺序执行。</p><p>之所以叫推测性解析，是因为浏览器在做一个推测，预计未来会加载某个资源，所以最好现在就在后台加载。但是，如果某些 JavaScript 操作 DOM，或用外部资源删除/隐藏元素，那么推测就失败了，这些文件就白白加载了。</p><blockquote><p>每个浏览器都有自己的规范，所以不能保证何时或是否会发生推测性解析。不过，你可以使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 元素要求浏览器提前加载一些资源。</p></blockquote><h3 id="渲染阻塞型-CSS"><a href="#渲染阻塞型-CSS" class="headerlink" title="渲染阻塞型 CSS"></a>渲染阻塞型 CSS</h3><p>正如我们所了解到的，除了阻塞解析器的 <code>script</code> 文件外，任何外部资源请求都不会阻塞 DOM 解析过程。因此，CSS（包括嵌入式）不会直接阻塞 DOM 解析器。等等，是的，CSS 可以阻止 DOM 解析，但在此之前，我们需要了解渲染过程。</p><p>浏览器内部的浏览器引擎使用从服务器接收到的 HTML 内容作为文本文档来构建 DOM 树。同样，它也会根据外部 CSS 文件或 HTML 中嵌入（以及内联）的 CSS 样式表内容来构建 CSSOM 树。</p><p>DOM 和 CSSOM 树的构建都发生在主线程上，而且这些树的构建是<strong>同时</strong>进行的。它们共同构成了用于在屏幕上打印东西的 Render Tree，而 Render Tree 也随着 DOM 树的构建而逐步构建。</p><p>我们已经了解到，DOM 树的生成是增量的，这意味着当浏览器读取 HTML 时，它会将 DOM 元素添加到 DOM 树中。但 CSSOM 树却不是这样。与 DOM 树不同，CSSOM 树的构建不是递增的，必须以特定的方式进行。</p><p>当浏览器找到 <code>&lt;style&gt;</code> 块时，它会解析所有嵌入的 CSS，并以新的 CSS （样式）规则更新 CSSOM 树。之后，它将继续以正常方式解析 HTML。内联样式也是如此。</p><p>然而，当浏览器遇到一个外部样式表文件时，事情就会发生巨大的变化。与外部 <code>script</code> 文件不同的是，外部样式表文件不是解析器阻塞型的资源，因此浏览器可以在后台静默地下载它，DOM 解析也会继续进行。</p><p>但与 HTML 文件（用于 DOM 构建）不同，浏览器不会一个字节一个字节地处理样式表文件内容。这是因为浏览器在读取 CSS 内容时，不能增量地构建 CSSOM 树。原因是，文件最后的 CSS 规则可能会覆盖写在文件顶部的 CSS 规则。</p><p>因此，如果浏览器在解析样式表内容时开始递增地构建 CSSOM，就会导致渲染树的多次渲染，因为样式覆盖规则会使同样的 CSSOM 节点，因后面新出现的样式表文件而导致更新。当 CSS 被解析时，可以在屏幕上看到元素样式的改变，这将是一种不愉快的用户体验。由于 CSS 样式是层叠的，一个规则的改变可能会影响许多元素。</p><p>因此，浏览器不会逐步处理外部 CSS 文件，CSSOM 树更新是在样式表中所有 CSS 规则处理完毕后一次性完成的。CSSOM 树更新完成后，再更新渲染树，然后渲染到屏幕上。</p><p>CSS 是一种渲染阻塞型资源。一旦浏览器提出获取外部样式表的请求，Render Tree 的构建就会停止。因此，<strong>关键渲染路径</strong>（CRP）也被卡住了，没有任何东西被渲染到屏幕上，如下图所示。然而，在后台下载样式表时，DOM 树的构建仍在进行中。</p><p><img src="https://ae01.alicdn.com/kf/Uf2fb7434f9144281885b7b7b71cf9fe2P.jpg" alt=""></p><p>浏览器可以使用 CSSOM 树的旧状态来生成 Render Tree，因为 HTML 正在被解析，以递增的方式在屏幕上呈现事物。但这有一个巨大的缺点。在这种情况下，一旦样式表被下载和解析，CSSOM 被更新，Render Tree 就会被更新并呈现在屏幕上。现在，用旧 CSSOM 生成的 Render Tree 节点将重绘新的样式，这也可能导致 Flash of Unstyled Content (FOUC)，这对用户体验非常不利。</p><p>因此，浏览器会等到样式表被加载和解析。一旦样式表被解析，CSSOM 被更新，Render Tree 就会被更新，CRP 就会继续进行，从而使 Render Tree 绘制在屏幕上。由于这个原因，建议尽早加载所有外部样式表。</p><p>让我们想象一下这样一个场景：浏览器已经开始解析 HTML，并且遇到了一个外部样式表文件。它将在后台开始下载文件，阻塞 CRP，并继续进行 DOM 解析。但是它又遇到了一个 <code>script</code> 标签，于是它就会在后台开始下载外部脚本文件，并阻止 DOM 解析。现在浏览器是坐等样式表和脚本文件完全下载完毕。</p><p>但这次外部脚本文件已经完全下载完毕，而样式表还在后台下载。浏览器要不要执行这个脚本文件？这样做有什么危害吗？</p><p>我们知道，CSSOM 提供了一个高级的 JavaScript API 来与 DOM 元素的样式进行交互。例如，你可以使用 <code>elem.style.backgroundColor</code> 属性来读取或更新一个 DOM 元素的背景颜色。与 <code>elem</code> 元素相关联的样式对象暴露了 CSSOM 的 API，还有很多其他的 API 可以做同样的事情（请阅读这篇 <a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/">css-tricks</a> 文章）。</p><p>当一个样式表被后台下载时，JavaScript 仍然可以执行，因为主线程没有被加载的样式表所阻挡。如果我们的 JavaScript 程序访问 DOM 元素的 CSS 属性（通过 CSSOM API），我们会得到一个合适的值（根据 CSSOM 的当前状态）。</p><p>但是一旦样式表被下载和解析，导致 CSSOM 更新，我们的 JavaScript 现在有一个过时的元素的 CSS 值，因为新的 CSSOM 更新可能已经改变了该 DOM 元素的 CSS 属性。由于这个原因，在下载样式表的时候执行 JavaScript 是不安全的。</p><p>根据 <a href="https://html.spec.whatwg.org/multipage/semantics.html#interactions-of-styling-and-scripting">HTML5 规范</a>，浏览器可以下载一个脚本文件，但不会执行它，除非之前所有的样式表都被解析了。当一个样式表阻止脚本的执行时，它被称为脚本阻塞型样式表(script-blocking stylesheet)或脚本阻塞型 CSS(script-blocking CSS)。</p><p><img src="https://ae01.alicdn.com/kf/U327ac1fe038246be86df228eb65080e5r.jpg" alt=""></p><p>在上面的例子中，script-blocking.html 包含了一个<code>link</code> 标签（用于外部的样式表），后面是一个 <code>script</code> 标签（用于外部 JavaScript）。这里的 <code>script</code> 下载速度非常快，没有任何延迟，但样式表需要 6 秒才能下载完。因此，尽管我们可以从网络面板上看到，脚本已经完全下载，但浏览器并没有立即执行。只有在样式表加载后，我们看到脚本打印的 <code>Hello World</code> 消息。</p><blockquote><p>就像 <code>async</code> 或 <code>defer</code> 属性使 <code>script</code> 元素<strong>不阻塞解析</strong>一样，外部的样式表也可以通过 <code>media</code> 属性使其<strong>不阻塞渲染</strong>。使用 <code>media</code> 属性值，浏览器可以智能地决定何时去加载样式表</p></blockquote><h3 id="文档的-DOMContentLoader-事件"><a href="#文档的-DOMContentLoader-事件" class="headerlink" title="文档的 DOMContentLoader 事件"></a>文档的 DOMContentLoader 事件</h3><p><code>DOMContentLoaded</code>(DCL)事件标志着，浏览器从所有可用的 HTML 中，构建出了一个完整的DOM树的时间点。但 DCL 事件被触发时，有很多涉及到的因素会发生变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"DOM is fully parsed!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果我们的 HTML 中不包含任何脚本，DOM 解析就不会被阻塞，DCL 就会随着浏览器解析完整个 HTML 而触发。如果我们有解析器阻塞型脚本，那么 DCL 必须等待所有解析器阻塞型脚本被下载并执行。</p><p>当样式表被扔进页面时，事情就变得有点复杂了。即使你没有外部脚本，DCL 也会等到所有样式表被加载。因 DCL 标志着整个 DOM 树已经准备好的时间点，但是在 CSSOM 也被完全构建之前，访问 DOM 都是不太安全的（对于样式信息）。因此，大多数浏览器都会等到所有外部样式表被加载和解析。</p><p>脚本阻塞型样式表显然会延迟 DCL。在这种情况下，由于脚本在等待样式表的加载，DOM 树没有被构造出来。</p><p>DCL 是网站性能指标之一。我们应该优化 DCL，使其尽可能的小（发生的时间）。其中一个最好的做法是尽可能地使用 <code>defer</code> 和 <code>async</code> 标签来处理 <code>script</code> 元素，这样当脚本在后台下载时，浏览器可以执行其他事情。其次，我们应该优化脚本阻塞型和渲染阻塞型的样式表。</p><h3 id="窗口的-load-事件"><a href="#窗口的-load-事件" class="headerlink" title="窗口的 load 事件"></a>窗口的 <code>load</code> 事件</h3><p>我们知道 JavaScript 可以阻止 DOM 树的生成，但是对于外部的样式表和文件，如图片、视频等就不是这样了。</p><p><code>DOMContentLoaded</code> 事件标志着 DOM 树已经完全构造完成，可以安全访问，<code>window.onload</code> 事件标志着外部样式表和文件下载完毕，我们的Web应用已经完成下载的时间点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener( <span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'Page is fully loaded!'</span> );</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/19/Jw4bepLi73yxYqP.png" alt="1618839528167.png"></p><p>在上面的例子中，rendering.html 文件的头部有一个外部样式表，下载时间大约为5秒。由于它在头部部分，<code>FP</code> 和 <code>FCP</code> 发生在5秒之后，因为样式表会阻止它下面的任何内容的渲染（也就是它阻止了CRP）。</p><p>在这之后，我们有一个 <code>img</code> 元素，加载一个需要10秒左右下载的图片。所以浏览器会在后台一直下载这个文件，然后继续进行 DOM 的解析和渲染（因为外部图片资源既不阻挡解析器，也不阻挡渲染）。</p><p>接下来，我们有三个外部 JavaScript 文件，它们的下载时间分别为 3s、6s 和 9s，最重要的是，它们不是异步的。这意味着总的加载时间应该接近 18秒，因为在前一个脚本执行之前，后续的脚本不会开始下载。然而，从 DCL 事件来看，我们的浏览器似乎采用了推测性策略，预先下载脚本文件，所以总加载时间接近 9秒。</p><p>由于能够影响 DCL 的最后一个下载的文件是最后一个脚本文件，加载时间为9秒（因为样式表已经在 5 秒内下载完毕），所以DCL事件发生在 9.1 秒左右。</p><p>我们还有一个外部资源是图片文件，它一直在后台加载。当它完全下载完毕后（需要 10 秒），窗口的 <code>load</code> 事件在10.2秒后被启动，这标志着网页（应用程序）已经完全加载完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自 Uday Hiwarale 的 &lt;a href=&quot;https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969&quot;&gt;How the browser renders a web page? — DOM, CSSOM, and Rendering&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当你开发一个网站的时候，有些东西对于良好的用户体验来说是非常必要的。网站可能遇到的一些常见问题可能是资源加载缓慢，在初始渲染时等待不必要的文件下载，样式未应用的内容闪烁&lt;code&gt;(flash of unstyled content (FOUC))&lt;/code&gt;等。为了避免类似问题，我们需要了解浏览器渲染典型网页的生命周期。&lt;/p&gt;
&lt;p&gt;首先，我们需要了解什么是 &lt;code&gt;DOM&lt;/code&gt;。当浏览器相服务器发送请求，获取一个 &lt;code&gt;HTML&lt;/code&gt; 文档的时候，服务器会返回一个二进制流格式的 &lt;code&gt;HTML&lt;/code&gt; 页面，它基本就是一个文本文件，其响应头的 &lt;code&gt;Content-Type&lt;/code&gt; 设置为 &lt;code&gt;text/html;charset-UTF-8&lt;/code&gt;。这里的 &lt;code&gt;text/html&lt;/code&gt; ·是一个 &lt;a href=&quot;https://en.wikipedia.org/wiki/Media_type&quot;&gt;MIME 类型&lt;/a&gt;，它告诉浏览器这是一个 &lt;code&gt;HTML&lt;/code&gt; 文档，&lt;code&gt;charset=UTF-8&lt;/code&gt; 告诉浏览器它是以 &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; 字符&lt;a href=&quot;https://medium.com/jspoint/introduction-to-character-encoding-3b9735f265a6&quot;&gt;编码&lt;/a&gt;的。利用这些信息，浏览器剋将二进制格式转换为可读的文本文件。如下图所示。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/04/17/c1MpWG2FosgNrhl.png&quot; alt=&quot;1_Tm-HPhmGA0BL7HIj38H8Qw.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果该 &lt;code&gt;header&lt;/code&gt; 缺失，浏览器将无法理解如何处理该文件，它将以纯文本格式呈现。但如果一切正常，经过这次转换后，浏览器就可以开始阅读 &lt;code&gt;HTML&lt;/code&gt; 文档了。一个典型的 &lt;code&gt;HTML&lt;/code&gt; 文档大致如下:&lt;/p&gt;
    
    </summary>
    
    
      <category term="browser" scheme="https://kerbalhao.github.io/categories/browser/"/>
    
    
  </entry>
  
  <entry>
    <title>基于HTTP网络层的前端性能优化</title>
    <link href="https://kerbalhao.github.io/posts/b8c7ab12/"/>
    <id>https://kerbalhao.github.io/posts/b8c7ab12/</id>
    <published>2021-03-22T11:48:48.000Z</published>
    <updated>2022-04-06T10:48:44.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从输入-URL-地址到看到页面，HTTP-应用层都经历了什么"><a href="#从输入-URL-地址到看到页面，HTTP-应用层都经历了什么" class="headerlink" title="从输入 URL 地址到看到页面，HTTP 应用层都经历了什么"></a>从输入 URL 地址到看到页面，HTTP 应用层都经历了什么</h2><h3 id="1-url-解析"><a href="#1-url-解析" class="headerlink" title="1. url 解析"></a>1. url 解析</h3><h4 id="url-会包含这些东西："><a href="#url-会包含这些东西：" class="headerlink" title="url 会包含这些东西："></a>url 会包含这些东西：</h4><p>一个 url 会类似这种： <a href="https://asdbc.com:443/index.html?key=value#anchor">https://asdbc.com:443/index.html?key=value#anchor</a><br>对上述的 url 进行解释：协议//域名（服务器地址）：端口号/请求资源的文件路径/?查询字符(key)=值(value)#片段标识符</p><h4 id="url-编码"><a href="#url-编码" class="headerlink" title="url 编码"></a>url 编码</h4><p>根据规定，只有字母和数字 <code>[0-9a-zA-Z]</code>、一些特殊符号”$-_.+!*‘(),”<code>[不包括双引号]</code>、以及某些保留字，才可以不经过编码直接用于 URL。因此，我们需要对 url 进行编码。</p><ul><li>encodeURI(url):它着眼于对整个 URL 进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码。</li><li>encodeURIComponent(url):与 encodeURI()的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个 URL 进行编码。因此，”; / ? : @ &amp; = + $ , #”，这些在 encodeURI()中不被编码的符号，在 encodeURIComponent()中统统会被编码。 <a id="more"></a></li></ul><h3 id="2-缓存检查"><a href="#2-缓存检查" class="headerlink" title="2. 缓存检查"></a>2. 缓存检查</h3><ul><li>在解析 DNS 之前，会先判断是否存在强缓存</li><li>若命中则直接返回缓存内容，</li><li>若无则进行正常流程，进行 DNS 解析，建立 TCP 连接，发送 HTTP 请求</li><li>发送请求时回去验证协商缓存，若命中则返回 304，拿取缓存资源</li></ul><h4 id="强缓存（强缓存命中后是不会发送-http-请求的）"><a href="#强缓存（强缓存命中后是不会发送-http-请求的）" class="headerlink" title="强缓存（强缓存命中后是不会发送 http 请求的）"></a>强缓存（强缓存命中后是不会发送 http 请求的）</h4><h5 id="浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的"><a href="#浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的" class="headerlink" title="浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的"></a>浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的</h5><ul><li>Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1.0）</li><li>Cache-Control：cache-control: max-age=2592000 第一次拿到资源后的 2592000 秒内（30 天），再次发送请求，读取缓存中的信息（HTTP/1.1）</li><li>两者同时存在的话，Cache-Control 优先级高于 Expires</li></ul><p><a href="https://imgtu.com/i/6oQLE6"><img src="https://z3.ax1x.com/2021/03/22/6oQLE6.png" alt="强缓存.png"></a></p><h5 id="强缓存问题："><a href="#强缓存问题：" class="headerlink" title="强缓存问题："></a>强缓存问题：</h5><ol><li>服务器文件更新，但本地有缓存，则无法拿到最新文件</li><li>HTML 文件一般不做强缓存</li></ol><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><ol><li>服务器更新资源后，让资源名称变更，这样页面将导入全新的资源（webpack 打包文件带 hash 值）</li><li>当文件更新后，在 Html 导入时，设置一个后缀（时间戳）</li></ol><h4 id="协商缓存-Last-Modified-ETag"><a href="#协商缓存-Last-Modified-ETag" class="headerlink" title="协商缓存 Last-Modified / ETag"></a>协商缓存 Last-Modified / ETag</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</p><p><a href="https://imgtu.com/i/6olhZt"><img src="https://z3.ax1x.com/2021/03/22/6olhZt.png" alt="协商缓存.png"></a></p><h5 id="协商缓存流程："><a href="#协商缓存流程：" class="headerlink" title="协商缓存流程："></a>协商缓存流程：</h5><ol><li><p>第一次向服务器发送请求</p><ol><li>没有协商缓存，向服务器发送请求（未传递任何标识）<ul><li>服务请收到请求准备内容</li><li>Last-Modified：资源文件最后更新的时间</li><li>ETag：记录的是一个标识（即根据资源文件更新生成的，每次资源更新都会重新生成一个）</li></ul></li><li>客户端拿到信息后渲染，将信息和标识缓存到本地</li></ol></li><li><p>第二次发请求</p><ol><li>客户端发送 If-Modified-Since 与 If-None-Match<ul><li>If-Modified-Since 对应 Last-Modified 值</li><li>If-None-Match 对应 ETag 值</li></ul></li><li>发送给服务器</li><li>服务器根据标识判断文件是否更新</li></ol></li></ol><h5 id="Last-Modified-与-ETag-区别"><a href="#Last-Modified-与-ETag-区别" class="headerlink" title="Last-Modified 与 ETag 区别"></a>Last-Modified 与 ETag 区别</h5><p>Last-Modified 只能精确到秒，而 ETag 只要有改变就会重新生成</p><h5 id="强缓存和协商好缓存一般只应用于静态资源文件"><a href="#强缓存和协商好缓存一般只应用于静态资源文件" class="headerlink" title="强缓存和协商好缓存一般只应用于静态资源文件"></a>强缓存和协商好缓存一般只应用于静态资源文件</h5><h5 id="数据的缓存，一般由我们自己保存到客户端存储中，根据自己设置的过期时间判断是否需要更新"><a href="#数据的缓存，一般由我们自己保存到客户端存储中，根据自己设置的过期时间判断是否需要更新" class="headerlink" title="数据的缓存，一般由我们自己保存到客户端存储中，根据自己设置的过期时间判断是否需要更新"></a>数据的缓存，一般由我们自己保存到客户端存储中，根据自己设置的过期时间判断是否需要更新</h5><h5 id="协商缓存与强缓存区别："><a href="#协商缓存与强缓存区别：" class="headerlink" title="协商缓存与强缓存区别："></a>协商缓存与强缓存区别：</h5><ul><li>协商缓存总会和服务器协商，所以一定会发 http 请求</li></ul><h3 id="3-DNS-解析"><a href="#3-DNS-解析" class="headerlink" title="3. DNS 解析"></a>3. DNS 解析</h3><p>我们需要对 dns 进行解析才能找到域名对应的 ip 地址，但是 dns 解析也是一个耗时的操作，好在我们也存在 dns 缓存</p><p>对 DNS 缓存进行查询的时候，我们会按照 客户端 =&gt; 浏览器缓存 =&gt; 本地的 hosts 文件 =&gt; 本地 DNS 解析器缓存 =&gt; 本地 DNS 服务器 的方式进行迭代查询</p><p>若无法命中对应的 DNS 缓存，我们就需要对 DNS 服务器进行递归查询了</p><h4 id="优化-DNS-解析过程："><a href="#优化-DNS-解析过程：" class="headerlink" title="优化 DNS 解析过程："></a>优化 DNS 解析过程：</h4><ol><li><p>减少 DNS 请求，一个页面尽可能少用不同的域名，资源都放在相同的服务器中（很少用，因为资源存放的服务器很多，不同服务器压力不同）</p></li><li><p>使用 link 标签实现 dns 预解析：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"&lt;url&gt;"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="服务器拆分优势："><a href="#服务器拆分优势：" class="headerlink" title="服务器拆分优势："></a>服务器拆分优势：</h4><ul><li>资源的合理利用</li><li>抗压能力加强</li><li>提高 HTTP 并发、</li></ul><h3 id="4-TCP-三次握手"><a href="#4-TCP-三次握手" class="headerlink" title="4. TCP 三次握手"></a>4. TCP 三次握手</h3><h4 id="TCP-名词介绍："><a href="#TCP-名词介绍：" class="headerlink" title="TCP 名词介绍："></a>TCP 名词介绍：</h4><ul><li>seq 序号，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记</li><li>ack 确认序号，只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1</li><li>标志位<ul><li>ACK：确认序号有效</li><li>RST：重置连接</li><li>SYN：发起一个新连接</li><li>FIN：释放一个连接</li></ul></li></ul><p><a href="https://imgtu.com/i/6oGQlF"><img src="https://z3.ax1x.com/2021/03/22/6oGQlF.png" alt="三次握手.png"></a></p><h4 id="三次握手为什么不用两次，或者四次"><a href="#三次握手为什么不用两次，或者四次" class="headerlink" title="三次握手为什么不用两次，或者四次?"></a>三次握手为什么不用两次，或者四次?</h4><ul><li>TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率！</li><li>我们可以模拟一下三次握手客户端和服务端的应答：<ul><li>客户端：你好（发送后等待服务端应答，确定服务端可以接收和发送数据）</li><li>服务端：你好（发送后等待客户端应答，确定客户端可以接受到数据）</li><li>客户端： 我要发信息了（发送后，双方已经确定对方能够正常收发数据，连接成功建立）</li></ul></li><li>因此，两次握手无法判断客户端可以正常接收到数据，而四次握手则会浪费资源</li></ul><h3 id="5-数据传输"><a href="#5-数据传输" class="headerlink" title="5. 数据传输"></a>5. 数据传输</h3><h4 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h4><p>发送请求报文</p><h4 id="HTTP-请求返回"><a href="#HTTP-请求返回" class="headerlink" title="HTTP 请求返回"></a>HTTP 请求返回</h4><p>返回 HTTP 响应</p><h4 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h4><ul><li>200 OK</li><li>202 Accepted ：服务器已接受请求，但尚未处理（异步）</li><li>204 No Content：服务器成功处理了请求，但不需要返回任何实体内容</li><li>206 Partial Content：服务器已经成功处理了部分 GET 请求（断点续传 Range/If-Range/Content-Range/Content-Type:”multipart/byteranges”/Content-Length….）</li><li>301 Moved Permanently</li><li>302 Move Temporarily</li><li>304 Not Modified</li><li>305 Use Proxy</li><li>400 Bad Request : 请求参数有误</li><li>401 Unauthorized：权限（Authorization）</li><li>404 Not Found</li><li>405 Method Not Allowed</li><li>408 Request Timeout</li><li>500 Internal Server Error</li><li>503 Service Unavailable</li><li>505 HTTP Version Not Supported</li></ul><h3 id="6-TCP-四次挥手"><a href="#6-TCP-四次挥手" class="headerlink" title="6. TCP 四次挥手"></a>6. TCP 四次挥手</h3><p><a href="https://imgtu.com/i/6oUeRP"><img src="https://z3.ax1x.com/2021/03/22/6oUeRP.png" alt="四次挥手.png"></a></p><h4 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4><ul><li>服务器端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文</li><li>但关闭连接时，当服务器端收到 FIN 报文时，很可能并不会立即关闭链接，所以只能先回复一个 ACK 报文，告诉客户端：“你发的 FIN 报文我收到了”，只有等到服务器端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要四步握手。</li></ul><h2 id="HTTP1-0-1-1-2-区别"><a href="#HTTP1-0-1-1-2-区别" class="headerlink" title="HTTP1.0/1.1/2 区别"></a>HTTP1.0/1.1/2 区别</h2><h3 id="HTTP-1-0-与-1-1-的一些区别"><a href="#HTTP-1-0-与-1-1-的一些区别" class="headerlink" title="HTTP 1.0 与 1.1 的一些区别"></a>HTTP 1.0 与 1.1 的一些区别</h3><ul><li>缓存处理，HTTP1.0 中主要使用 Last-Modified，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略：ETag，Cache-Control…</li><li>带宽优化及网络连接的使用，HTTP1.1 支持断点续传，即返回码是 206（Partial Content）</li><li>错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除…</li><li>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）</li><li>长连接，HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点</li></ul><h3 id="HTTP2-0和HTTP1-X相比的新特性"><a href="#HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="HTTP2.0和HTTP1.X相比的新特性"></a>HTTP2.0和HTTP1.X相比的新特性</h3><ul><li>新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合，基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮</li><li>header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小</li><li>服务端推送（server push），例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过在应用生成HTTP响应头信息中设置Link命令</span></span><br><span class="line">Link: &lt;<span class="regexp">/styles.css&gt;; rel=preload; as=style, &lt;/</span>example.png&gt;; rel=preload; <span class="keyword">as</span>=image</span><br></pre></td></tr></table></figure></li><li>多路复用（MultiPlexing）<ul><li>HTTP/1.0  每次请求响应，建立一个TCP连接，用完关闭</li><li>HTTP/1.1 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li><li>HTTP/2.0 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li></ul></li></ul><ol><li>利用缓存<ul><li>对于静态资源文件实现强缓存和协商缓存（扩展：文件有更新，如何保证及时刷新？）</li><li>对于不经常更新的接口数据采用本地存储做数据缓存（扩展：cookie / localStorage / vuex|redux 区别？）</li></ul></li><li>DNS 优化<ul><li>分服务器部署，增加 HTTP 并发性（导致 DNS 解析变慢）</li><li>DNS Prefetch</li></ul></li><li>TCP 的三次握手和四次挥手</li></ol><ul><li>利用 Connection:keep-alive 来避免频繁开关 TCP 连接</li></ul><ol start="4"><li>数据传输 - 减少数据传输的大小 - 内容或者数据压缩（webpack 等） - 服务器端一定要开启 GZIP 压缩（一般能压缩 60%左右） - 大批量数据分批次请求（例如：下拉刷新或者分页，保证首次加载请求数据少） - 减少 HTTP 请求的次数 - 资源文件合并处理 - 字体图标 - 雪碧图 CSS-Sprit - 图片的 BASE64<br>……</li><li>CDN 服务器“地域分布式”</li><li>采用 HTTP2.0</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从输入-URL-地址到看到页面，HTTP-应用层都经历了什么&quot;&gt;&lt;a href=&quot;#从输入-URL-地址到看到页面，HTTP-应用层都经历了什么&quot; class=&quot;headerlink&quot; title=&quot;从输入 URL 地址到看到页面，HTTP 应用层都经历了什么&quot;&gt;&lt;/a&gt;从输入 URL 地址到看到页面，HTTP 应用层都经历了什么&lt;/h2&gt;&lt;h3 id=&quot;1-url-解析&quot;&gt;&lt;a href=&quot;#1-url-解析&quot; class=&quot;headerlink&quot; title=&quot;1. url 解析&quot;&gt;&lt;/a&gt;1. url 解析&lt;/h3&gt;&lt;h4 id=&quot;url-会包含这些东西：&quot;&gt;&lt;a href=&quot;#url-会包含这些东西：&quot; class=&quot;headerlink&quot; title=&quot;url 会包含这些东西：&quot;&gt;&lt;/a&gt;url 会包含这些东西：&lt;/h4&gt;&lt;p&gt;一个 url 会类似这种： &lt;a href=&quot;https://asdbc.com:443/index.html?key=value#anchor&quot;&gt;https://asdbc.com:443/index.html?key=value#anchor&lt;/a&gt;&lt;br&gt;对上述的 url 进行解释：协议//域名（服务器地址）：端口号/请求资源的文件路径/?查询字符(key)=值(value)#片段标识符&lt;/p&gt;
&lt;h4 id=&quot;url-编码&quot;&gt;&lt;a href=&quot;#url-编码&quot; class=&quot;headerlink&quot; title=&quot;url 编码&quot;&gt;&lt;/a&gt;url 编码&lt;/h4&gt;&lt;p&gt;根据规定，只有字母和数字 &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;、一些特殊符号”$-_.+!*‘(),”&lt;code&gt;[不包括双引号]&lt;/code&gt;、以及某些保留字，才可以不经过编码直接用于 URL。因此，我们需要对 url 进行编码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;encodeURI(url):它着眼于对整个 URL 进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp;amp; = + $ , #”，也不进行编码。&lt;/li&gt;
&lt;li&gt;encodeURIComponent(url):与 encodeURI()的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个 URL 进行编码。因此，”; / ? : @ &amp;amp; = + $ , #”，这些在 encodeURI()中不被编码的符号，在 encodeURIComponent()中统统会被编码。
    
    </summary>
    
    
      <category term="HTTP" scheme="https://kerbalhao.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://kerbalhao.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>手写 promise</title>
    <link href="https://kerbalhao.github.io/posts/3424aad5/"/>
    <id>https://kerbalhao.github.io/posts/3424aad5/</id>
    <published>2021-01-09T11:48:48.000Z</published>
    <updated>2022-04-06T10:48:44.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="极简版"><a href="#极简版" class="headerlink" title="极简版"></a>极简版</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>, <span class="comment">// 待定</span></span><br><span class="line">  FULFILLED = <span class="string">"fulfilled"</span>, <span class="comment">// 成功</span></span><br><span class="line">  REJECTED = <span class="string">"rejected"</span>; <span class="comment">// 失败</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING; <span class="comment">// promise 的初始状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>; <span class="comment">// resolve后获得的值</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span>; <span class="comment">// reject 后获得的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// executor 的函数参数，将 state 转为 fulfilled</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = FULFILLED;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// executor 的函数参数，将 state 转为 rejected</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = REJECTED;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 executor</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 报错则直接将 promise 置为 rejected</span></span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重头戏</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === FULFILLED) &#123;</span><br><span class="line">      onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>以上代码实现了同步情况下的 promise 我们可以看一下以下的测试代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果 : 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// setTimeout 异步执行，执行到 then 的时候， promise 中的 value 尚未得到</span></span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"didResolve"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise1.then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果： undefined -&gt; didResolve</span></span><br></pre></td></tr></table></figure><p>通过以上测试代码，我们可以知道，我们定义的 <code>MyPromise</code> 目前只能处理同步的情况。当遇到异步(上述的 <code>setTimeout</code> 宏任务)的时候，会先执行同步代码，即先执行 <code>then()</code> 方法，此时的 <code>val</code> 为 <code>undefined</code>。 因此返回一个 undefined，而后才执行 <code>resolve</code>，因此，我们的 <code>MyPromise</code> 还需要升级。</p><h2 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.onResolveFuncs = []; <span class="comment">// *1</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectedFuncs = []; <span class="comment">// *2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">        <span class="keyword">this</span>.onResolveFuncs.forEach(<span class="function">(<span class="params">onResolveFunc</span>) =&gt;</span> onResolveFunc()); <span class="comment">// *3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">        <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">        <span class="keyword">this</span>.onRejectedFuncs.forEach(<span class="function">(<span class="params">onRejectedFunc</span>) =&gt;</span> onRejectedFunc()); <span class="comment">// *4</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 返回一个 promise</span></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.onResolveFuncs.push(<span class="function"><span class="params">()</span> =&gt;</span> onFulfilled(<span class="keyword">this</span>.value)); <span class="comment">// *5</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedFuncs.push(<span class="function"><span class="params">()</span> =&gt;</span> onRejected(<span class="keyword">this</span>.reason)); <span class="comment">// *6</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"didResolve"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise1.then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 100 -&gt; didResolve</span></span><br></pre></td></tr></table></figure><p>如上，我们新增加了 6 段代码，让我们一一来说明一下：</p><ol><li>*1 和 *2： 新建了 <code>MyPromise</code> 的两个原型属性 <code>onResolveFuncs</code> 和 <code>onRejectedFuncs</code>；</li><li>*5 和 *6： 当我们执行到 <code>then</code> 方法，而 <code>MyPromise</code> 的状态还是 <code>pending</code> 时（即当 <code>MyPromise</code> 是异步的时候），将 <code>then</code> 方法中的回调函数（参数）都注册到 <code>onResolveFuncs</code> 和 <code>onRejectedFuncs</code> 中，来接收将来 <code>resolve</code> 或者 <code>reject</code> 掉的 <code>value</code> 或者 <code>reason</code>；</li><li>*3 和 *4： 当 <code>MyPromise</code> 实例执行了 <code>resolve</code> 或 <code>reject</code> 方法时，遍历执行注册（储存）在 <code>onResolveFuncs</code> 和 <code>onRejectedFuncs</code> 的所有函数</li></ol><p>以上可以解决 <code>MyPromise</code> 异步导致的 <code>then</code> 方法的函数参数无法顺利执行问题。</p><p><strong>我们可以知道，<code>resolve</code> 和 <code>reject</code> 方法其实很简单，只是用于改变 <code>promise</code> 的状态，获得 <code>executor</code> 赋予的 <code>value</code> 或者 <code>reason</code>，并最终调用注册在 <code>onResolveFuncs</code> 和 <code>onRejectedFuncs</code> 的所有函数。</strong></p><p>但是，问题它又来了，因为仅按照上面的代码，无法实现 <code>then</code> 方法的链式调用，而链式调用时怎么做的呢？</p><p>根据 <code>Promises/A+</code> 规范，<code>then</code> 方法必须返回一个新的 <code>promise</code>，接下来我们可以看一下升级版是如何实现的</p><h2 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h2><p>简单来说，要实现 <code>promise</code> 的链式调用，则在 <code>then</code> 方法中需要返回一个新的 <code>Promise</code> 实例，在触发 <code>then</code> 方法的回调函数时，根据函数返回的结果，分情况将结果 <code>resolve</code> 或者 <code>reject</code> 出去，从而返回一个 <code>settled</code> 的 <code>Promise</code> 用于继续调用 <code>then</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* promise: then 方法返回的新的 Promise 实例</span></span><br><span class="line"><span class="comment">* x: then 方法的函数参数调用后返回的结果</span></span><br><span class="line"><span class="comment">* resolve, reject：Promise 内声明的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// then 方法调用就会调用此方法</span></span><br><span class="line"><span class="comment">// 此方法用于将 then 返回的 新的 promise 进行 resolve 或者 reject</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, x, resolve, reject</span>) </span>&#123; <span class="comment">// *1</span></span><br><span class="line">  <span class="keyword">if</span> (x === promise) &#123; <span class="comment">// 阻止 promise 的循环引用</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Chaining cycle detected for promise"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明一个变量用于防止重复 resolve 或者 reject</span></span><br><span class="line">  <span class="keyword">let</span> called;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 规范规定，带有 then 方法的对象或者函数都是 promise</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || <span class="keyword">typeof</span> x === <span class="string">"function"</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="comment">// 若原始实例的 then 方法的函数参数返回了一个 promise，则将继续调用此方法， 将该 promise 状态变为 settled，并将获得的值 resolve 或 reject 掉</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">"function"</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          (y) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            resolvePromise(promise, y, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          (err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        ) <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">if</span>(called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若是普通值，则直接 resolve 出去</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// ... 同上</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 返回一个 新的promise</span></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">// resolvePromise 中的 promise 是由 MyPromise 创建的</span></span><br><span class="line">        <span class="comment">// setTimeout 用于保证可以获取到 MyPromise 的实例 promise</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123; <span class="comment">// *2</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            resolvePromise(promise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            resolvePromise(promise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.onResolveFuncs.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">              resolvePromise(promise, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.onRejectedFuncs.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">              resolvePromise(promise, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onReject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onReject)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-的静态方法"><a href="#Promise-的静态方法" class="headerlink" title="Promise 的静态方法"></a>Promise 的静态方法</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>我们知道， <code>Promise.all</code> 接受一个 <code>promise</code> 数组作为参数（从技术上讲，它可以是任何可迭代的，但通常是一个数组）并返回一个新的 <code>promise</code>。</p><p>当所有给定的 <code>promise</code> 都被 <code>settled</code> 时，新的 <code>promise</code> 才会 <code>resolve</code>，并且其结果数组将成为新的 <code>promise</code> 的结果。</p><p>如果任意一个 <code>promise</code> 被 <code>reject</code>，由 <code>Promise.all</code> 返回的 <code>promise</code> 就会立即 <code>reject</code>，并且带有的就是这个 <code>error</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断参数是否为 promise 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> obj === <span class="string">"object"</span> &amp;&amp; obj !== <span class="literal">null</span>) || <span class="keyword">typeof</span> obj === <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj.then === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 promise.all</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> results = [];</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>; <span class="comment">// 计数器，判断何时 resolve 整个结果</span></span><br><span class="line"></span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">value, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将数组内的元素都 promise 化，以拥有 then 方法</span></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(value).then(</span><br><span class="line">        (v) =&gt; &#123;</span><br><span class="line">          results[i] = v;</span><br><span class="line">          <span class="keyword">if</span> (++length === arr.length) &#123;</span><br><span class="line">            resolve(results);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (e) =&gt; &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled 与 Promise.all 类似，也接收一个 Promise 数组，但其返回一个数组，包括 fulfilled 和 rejected 的值，返回值格式：</p><figure class="highlight plain"><figcaption><span>'fulfilled', value: ...&#125;, &#123;status:'rejected', reason: ...&#125;]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>手写如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>, <span class="comment">// 成功</span></span><br><span class="line">  REJECTED = <span class="string">"rejected"</span>; <span class="comment">// 失败</span></span><br><span class="line"></span><br><span class="line">MyPromise.allSettled = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> results = [];</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个函数用于处理数据，根据状态 status 将数据包装成对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolveData</span>(<span class="params">state, item, index</span>) </span>&#123;</span><br><span class="line">      results[index] = &#123; <span class="attr">status</span>: state, <span class="attr">value</span>: item &#125;;</span><br><span class="line">      <span class="keyword">if</span> (++length === array.length) &#123;</span><br><span class="line">        resolve(results);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPromise(item)) &#123;</span><br><span class="line">        item.then(</span><br><span class="line">          (v) =&gt; &#123;</span><br><span class="line">            resolveData(FULFILLED, v, i);</span><br><span class="line">          &#125;,</span><br><span class="line">          (e) =&gt; &#123;</span><br><span class="line">            resolveData(REJECTED, e, i);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolveData(FULFILLED, item, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据大佬的 Polyfill， 发现可以写成这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolveHandler = <span class="function"><span class="params">val</span> =&gt;</span> &#123;<span class="attr">status</span>: <span class="string">'fulfilled'</span>, <span class="attr">value</span>: val&#125;,</span><br><span class="line">  rejectHandler = <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: err&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.allSettled = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> toSettled = arr.map(<span class="function"><span class="params">promise</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(promise).then(resolveHandler, rejectHandler)) <span class="comment">// *1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(toSettled)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 *1 中先将 arr v 中的所有元素转变为 promise 对象，从而可以使用 then 方法。而后使用 Promise.all 方法等待结果返回。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>与 Promise.all 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。</p><p>当第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 给所有元素都注册 then 方法，then 方法调用回调函数，则立刻resolve 或 reject</span></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(item).then(resolve, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve-Promise-reject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve / Promise.reject"></a>Promise.resolve / Promise.reject</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(promise);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(promise);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://www.cnblogs.com/sugar-tomato/p/11353546.html">史上最最最详细的手写Promise教程</a><br><a href="https://zh.javascript.info/promise-api">现代JavaScript教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;极简版&quot;&gt;&lt;a href=&quot;#极简版&quot; class=&quot;headerlink&quot; title=&quot;极简版&quot;&gt;&lt;/a&gt;极简版&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 常量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; PENDING = &lt;span class=&quot;string&quot;&gt;&quot;pending&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 待定&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  FULFILLED = &lt;span class=&quot;string&quot;&gt;&quot;fulfilled&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 成功&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  REJECTED = &lt;span class=&quot;string&quot;&gt;&quot;rejected&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyPromise&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(executor) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state = PENDING; &lt;span class=&quot;comment&quot;&gt;// promise 的初始状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// resolve后获得的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.reason = &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// reject 后获得的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// executor 的函数参数，将 state 转为 fulfilled&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; resolve = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state === PENDING) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state = FULFILLED;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// executor 的函数参数，将 state 转为 rejected&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; reject = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;reason&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state === PENDING) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state = REJECTED;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.reason = reason;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 执行 executor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      executor(resolve, reject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 报错则直接将 promise 置为 rejected&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      reject(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 重头戏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  then(onFulfilled, onRejected) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state === FULFILLED) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      onFulfilled(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state === REJECTED) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      onRejected(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.reason);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="JS" scheme="https://kerbalhao.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React 思维导图</title>
    <link href="https://kerbalhao.github.io/posts/70af37a7/"/>
    <id>https://kerbalhao.github.io/posts/70af37a7/</id>
    <published>2020-04-27T11:01:49.000Z</published>
    <updated>2022-04-06T10:48:44.280Z</updated>
    
    <content type="html"><![CDATA[<p>React 学习，思维导图</p><a id="more"></a><!-- more --><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_c74b777a975efd137587e0ec2c5c96f8.jpeg" alt="React.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 学习，思维导图&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="https://kerbalhao.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://kerbalhao.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>个人 dota2 项目</title>
    <link href="https://kerbalhao.github.io/posts/f4f838c8/"/>
    <id>https://kerbalhao.github.io/posts/f4f838c8/</id>
    <published>2020-04-23T14:02:46.000Z</published>
    <updated>2022-04-06T10:48:44.284Z</updated>
    
    <content type="html"><![CDATA[<p>此文档用于备份，防止 Github 仓库无法访问<br><a href="https://github.com/KerbalHao/personal_dota2_data">Github仓库地址</a></p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><ul><li>本项目是基于 dota2 中文官网以及 17173 网站中关于 dota2 的数据创建的全栈项目，仅用于个人练习。</li><li>项目使用了 flex 布局，主要支持使用移动端浏览。</li><li>项目支持登录和注销操作，大部分功能需要登录使用，账号密码为 admin。<a id="more"></a></li><li>英雄页面可以点击查看英雄具体内容，包括背景故事、昵称、阵营、技能（技能详情需要进一步的数据）等，支持筛选过滤，可在详情页面收藏该英雄</li><li>物品界面模拟网上商城，可以进行购物、结算等操作，有点击加入购物车的动画（小球抛物线）。</li><li>用户界面处理登录和注册事宜，且可查看已购买和已收藏。</li><li>后端使用 jwt 校验用户是否登录</li><li>用户数据保存在 server\routes\data 中</li></ul><p><img src="https://i.loli.net/2020/04/20/YjzpNb5FMLyrwAu.gif" alt="index.gif"></p><ul><li><p>物品界面</p><p><img src="https://i.loli.net/2020/04/20/rBauZ5bTOE6K8vJ.gif" alt="item.gif"></p></li><li><p>个人中心界面</p></li></ul><p><img src="https://i.loli.net/2020/04/20/oeNlvTGgrnPVfbA.gif" alt="mine.gif"></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>使用了 Vue 全家桶(Vue，Vue-Router，Vuex)，cube-ui 组件库以及 CSS 预处理器 stylus 进行前端的开发以及样式的书写。</li><li>使用 axios 进行进行数据的请求</li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li>使用 express 框架构建了基础的后台服务，通过前端发出请求进行数据的交流</li><li>使用 JSON Web Token 进行跨域认证，校验用户是否登录</li></ul><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="修改原始配置"><a href="#修改原始配置" class="headerlink" title="修改原始配置"></a>修改原始配置</h3><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>因为在使用 cube-ui 是使用了 amfe-flexibale，文档字体大小 rem 被固定，修改需要到找到 <code>node_modules\amfe-flexible\index.js</code> 文件，修改函数 <code>setRemUnit</code>，重新设置其 rem 的单位大小，本人修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">20</span></span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">'px'</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="启用后台服务"><a href="#启用后台服务" class="headerlink" title="启用后台服务"></a>启用后台服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h3 id="启用开发环境"><a href="#启用开发环境" class="headerlink" title="启用开发环境"></a>启用开发环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h3 id="启用生产环境"><a href="#启用生产环境" class="headerlink" title="启用生产环境"></a>启用生产环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文档用于备份，防止 Github 仓库无法访问&lt;br&gt;&lt;a href=&quot;https://github.com/KerbalHao/personal_dota2_data&quot;&gt;Github仓库地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本项目是基于 dota2 中文官网以及 17173 网站中关于 dota2 的数据创建的全栈项目，仅用于个人练习。&lt;/li&gt;
&lt;li&gt;项目使用了 flex 布局，主要支持使用移动端浏览。&lt;/li&gt;
&lt;li&gt;项目支持登录和注销操作，大部分功能需要登录使用，账号密码为 admin。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Lua学习</title>
    <link href="https://kerbalhao.github.io/posts/f79b72d/"/>
    <id>https://kerbalhao.github.io/posts/f79b72d/</id>
    <published>2020-04-14T03:08:06.000Z</published>
    <updated>2022-04-06T10:48:44.280Z</updated>
    
    <content type="html"><![CDATA[<p>以下是我学习 lua 时做的思维导图，方便自己记忆与理解，点击详情查看。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/kerbalhao/blog_images/img/2020/Lua_learning.svg" alt="lua思维导图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是我学习 lua 时做的思维导图，方便自己记忆与理解，点击详情查看。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Lua" scheme="https://kerbalhao.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>JS 12个重要概念以及reduce方法详解</title>
    <link href="https://kerbalhao.github.io/posts/66c0dcbe/"/>
    <id>https://kerbalhao.github.io/posts/66c0dcbe/</id>
    <published>2019-12-28T11:48:48.000Z</published>
    <updated>2022-04-06T10:48:44.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript方面"><a href="#JavaScript方面" class="headerlink" title="JavaScript方面"></a><code>JavaScript</code>方面</h2><h3 id="12个-JS概念"><a href="#12个-JS概念" class="headerlink" title="12个 JS概念"></a>12个 <code>JS</code>概念</h3><p>来源: <a href="https://www.infoq.cn/article/3L*kK19KH2Ey7GIVBGsN?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com">infoQ 了解这 12 个概念，让你的 JavaScript 水平更上一层楼</a></p><h4 id="1-变量赋值（值与引用）"><a href="#1-变量赋值（值与引用）" class="headerlink" title="1. 变量赋值（值与引用）"></a>1. 变量赋值（值与引用）</h4><p><code>JavaScript</code>总是按照值来给变量赋值。当指定的值是 <code>JavaScript</code>的五种原始类型之一（即 <code>Boolean</code>、<code>null</code>、<code>undefined</code>、<code>String</code>和 <code>Number</code>）时，将为变量分配实际的值。但是，当指定的值是 <code>Array</code>、<code>Function</code>或 <code>Object</code>时，将为变量分配内存的对象引用。</p><a id="more"></a><h4 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h4><p>闭包是一种重要的 <code>JavaScript</code>模式，可用于访问私有变量。在下面的示例中，<code>createGreeter</code>返回一个匿名函数，这个函数可以访问参数 <code>greeting</code>（在这里是“<code>Hello</code>”）。在后续的调用中，<code>sayHello</code>将有权访问这个 <code>greeting</code>！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGreeter</span>(<span class="params">greeting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(greeting + <span class="string">', '</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sayHello = createGreeter(<span class="string">'Hello'</span>);</span><br><span class="line">sayHello(<span class="string">'Joe'</span>);</span><br><span class="line"><span class="comment">// Hello, Joe</span></span><br></pre></td></tr></table></figure><p>在一个更真实的场景中，你可以设想一个初始化函数 <code>apiConnect</code>(<code>apiKey</code>)，它返回一些使用 <code>API</code>密钥的方法。在这种情况下，只需要提供一次 <code>apiKey</code>即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apiConnect</span>(<span class="params">apiKey</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">route</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">`<span class="subst">$&#123;route&#125;</span>?key=<span class="subst">$&#123;apiKey&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">route, params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(route, &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(params),</span><br><span class="line">        headers: &#123;</span><br><span class="line">          <span class="string">'Authorization'</span>: <span class="string">`Bearer <span class="subst">$&#123;apiKey&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="keyword">get</span>, post &#125;</span><br><span class="line">&#125;</span><br><span class="line">const api = apiConnect('my-secret-key');</span><br><span class="line">// No need to include the apiKey anymore</span><br><span class="line">api.<span class="keyword">get</span>('http://www.example.com/<span class="keyword">get</span>-endpoint');</span><br><span class="line">api.post('http://www.example.com/post-endpoint', &#123; name: <span class="string">'Joe'</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="3-解构"><a href="#3-解构" class="headerlink" title="3. 解构"></a>3. 解构</h4><p><code>JavaScript</code>参数解构是一种从对象中提取属性的常用方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Joe'</span>,</span><br><span class="line">  food: <span class="string">'cake'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name, food &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, food);</span><br><span class="line"><span class="comment">// 'Joe' 'cake'</span></span><br></pre></td></tr></table></figure><p>如果需要以其他名称来提取属性，可以使用以下格式来指定它们。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Joe'</span>,</span><br><span class="line">  food: <span class="string">'cake'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: myName, <span class="attr">food</span>: myFood &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(myName, myFood);</span><br><span class="line"><span class="comment">// 'Joe' 'cake'</span></span><br></pre></td></tr></table></figure><p>在下面的示例中，解构被用来将 <code>person</code>对象传给 <code>introduce</code>函数。换句话说，解构可以（并且经常）直接用于提取传给函数的参数。如果你熟悉 <code>React</code>，可能已经见过这个！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Eddie'</span>,</span><br><span class="line">  age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">introduce</span>(<span class="params">&#123; name, age &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I'm <span class="subst">$&#123;name&#125;</span> and I'm <span class="subst">$&#123;age&#125;</span> years old!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(introduce(person));</span><br><span class="line"><span class="comment">// "I'm Eddie and I'm 24 years old!"</span></span><br></pre></td></tr></table></figure><p>详细可看阮一峰的 <a href="http://es6.ruanyifeng.com/#docs/destructuring">ES6 入门</a></p><h4 id="4-展开（spread）语法"><a href="#4-展开（spread）语法" class="headerlink" title="4. 展开（spread）语法"></a>4. 展开（<code>spread</code>）语法</h4><p>在下面的示例中，<code>Math.max</code>不能直接接受 <code>arr</code>数组，因为它的参数不是数组类型，但可以以数组中的各个元素作为参数。展开运算符 <code>…</code>可用于提取数组的各个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max(...arr);</span><br><span class="line"><span class="built_in">console</span>.log(max);</span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h4 id="5-变长参数-rest-语法"><a href="#5-变长参数-rest-语法" class="headerlink" title="5.变长参数 (rest) 语法"></a>5.变长参数 (<code>rest</code>) 语法</h4><p>可以用它将 传给函数的 任意数量的 参数放入数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args[<span class="number">0</span>] + args[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">myFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="6-数组方法"><a href="#6-数组方法" class="headerlink" title="6.数组方法"></a>6.数组方法</h4><p><code>JavaScript</code>数组方法通常可以为你提供令人难以置信的优雅方式来执行所需的数据转换</p><h5 id="map、filter、reduce"><a href="#map、filter、reduce" class="headerlink" title="map、filter、reduce"></a><code>map</code>、<code>filter</code>、<code>reduce</code></h5><ul><li><code>map:</code>返回一个数组，其中每个元素都是用指定函数进行过转换。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> mapped = arr.map(<span class="function"><span class="params">el</span> =&gt;</span> el + <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mapped);</span><br><span class="line"><span class="comment">// [21, 22, 23, 24, 25, 26]</span></span><br></pre></td></tr></table></figure><ul><li><code>filter:</code>返回一个数字，只有当指定函数返回 <code>true</code>时，相应的元素才会被包含在数组内。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> filtered = arr.filter(<span class="function"><span class="params">el</span> =&gt;</span> el === <span class="number">2</span> || el === <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(filtered);</span><br><span class="line"><span class="comment">// [2, 4]</span></span><br></pre></td></tr></table></figure><ul><li><code>reduce</code>：基于给定函数累加值。<br>语法： <code>arr.reduce(callback,[initialValue])</code></li><li><code>callback</code>（执行数组中每个值的函数，包含四个参数）<ul><li><code>previousValue</code>（上一次调用回调返回的值，或者是提供的初始值（<code>initialValue</code>））</li><li><code>currentValue</code>（数组中当前被处理的元素）<br><code>index</code>（当前元素在数组中的索引）</li><li><code>array</code>（调用 <code>reduce</code>的数组）</li></ul></li><li><code>initialValue</code>（作为第一次调用 <code>callback</code>的第一个参数。）</li></ul><p>基本应用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="number">10</span>, <span class="number">120</span>, <span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// our reducer function</span></span><br><span class="line"><span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">sumSoFar, item</span>) </span>&#123; <span class="keyword">return</span> sumSoFar + item; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do the job</span></span><br><span class="line"><span class="keyword">var</span> total = items.reduce(reducer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(total); <span class="comment">// 1130</span></span><br></pre></td></tr></table></figure><p><code>reduce</code>函数的返回结果类型和传入的初始值相同，上个实例中初始值为 <code>number</code>类型，同理，初始值也可为 <code>object</code>类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="number">10</span>, <span class="number">120</span>, <span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// our reducer function</span></span><br><span class="line"><span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">sumSoFar, item</span>) </span>&#123;</span><br><span class="line">  sumSoFar.sum = sumSoFar.sum + item;</span><br><span class="line">  <span class="keyword">return</span> sumSoFar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do the job</span></span><br><span class="line"><span class="keyword">var</span> total = items.reduce(reducer, &#123;<span class="attr">sum</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(total); <span class="comment">// &#123;sum:1130&#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>reduce</code>进阶应用</strong>:<br>详见<a href="https://segmentfault.com/a/1190000010731933">思否 数组reduce方法的高级技巧</a> by <a href="https://segmentfault.com/u/taotao123">风雨后见彩虹</a></p><ul><li><p>我们看下面一个例子。</p><ol><li><p><strong>某同学的期末成绩如下表示</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">  &#123;</span><br><span class="line">      subject: <span class="string">'math'</span>,</span><br><span class="line">      score: <span class="number">88</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      subject: <span class="string">'chinese'</span>,</span><br><span class="line">      score: <span class="number">95</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      subject: <span class="string">'english'</span>,</span><br><span class="line">      score: <span class="number">80</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li><p>如何求该同学的总成绩？</p></li><li><p>我们可以使用 <code>reduce</code>来搞定这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = result.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cur.score + prev;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这个时候，我们给 <code>reduce</code>参数添加了第二个参数。通过打印我发现设置了这个参数之后，<code>reduce</code>遍历便已经从第一项开始了。</p><p>这第二个参数就是设置 <code>prev</code>的初始类型和初始值，比如为0，就表示 <code>prev</code>的初始值为 <code>number</code>类型，值为0，因此，<code>reduce</code>的最终结果也会是 <code>number</code>类型。</p></li></ul></li><li><p><strong>因为第二个参数为累计结果的初始值，因此假设该同学因为违纪被处罚在总成绩总扣10分，只需要将初始值设置为-10即可。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = result.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cur.score + prev;</span><br><span class="line">&#125;, <span class="number">-10</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>假如该同学的总成绩中，各科所占的比重不同，分别为50%，30%，20%，我们应该如何求出最终的权重结果呢？</strong></p><p>解决方案如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dis = &#123;</span><br><span class="line">  math: <span class="number">0.5</span>,</span><br><span class="line">  chinese: <span class="number">0.3</span>,</span><br><span class="line">  english: <span class="number">0.2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = result.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev);</span><br><span class="line">    <span class="keyword">return</span> cur.score + prev;</span><br><span class="line">&#125;, <span class="number">-10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> qsum = result.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur.score * dis[cur.subject]</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum, qsum);</span><br></pre></td></tr></table></figure><p>为了计算出权重之后的总值，我们在回调函数内部修改了数组当前项，是使他和权重比例相关联，并重新返回一个一样的回调函数，将新修改的当前项传入，就和之前的例子是一样的了。</p></li><li><p><strong>如何知道一串字符串中每个字母出现的次数？</strong></p><p>我们同样可以使用 <code>reduce</code>来解决这个问题</p><p>我们在 <code>reduce</code>的第二个参数里面初始了回调函数第一个参数的类型和值，将字符串转化为数组，那么迭代的结果将是一个对象，对象的每一项 <code>key</code>值就是字符串的字母。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrString = <span class="string">'abcdaabc'</span>;</span><br><span class="line"></span><br><span class="line">arrString.split(<span class="string">''</span>).reduce(<span class="function"><span class="keyword">function</span>(<span class="params">res, cur</span>) </span>&#123;</span><br><span class="line">    res[cur] ? res[cur] ++ : res[cur] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>由于可以通过第二参数设置叠加结果的类型初始值，因此这个时候 <code>reduce</code>就不再仅仅只是做一个加法了，我们可以灵活的运用它来进行各种各样的类型转换，比如将数组按照一定规则转换为对象，也可以将一种形式的数组转换为另一种形式的数组，大家可以动手去尝试一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">res, cur</span>) </span>&#123;</span><br><span class="line">  res.push(cur + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p>这种特性使得 <code>reduce</code>在实际开发中大有可为！但是需要注意点，在 <code>ie9</code>一下的浏览器中，并不支持该方法 ！</p></li></ol></li><li><p>此外，使用 <code>reduce</code>方法可以完成多维度的数据叠加。如上例中的初始值{<code>sum: 0</code>}，这仅仅是一个维度的操作，如果涉及到了多个属性的叠加，如{<code>sum: 0</code>,<code>totalInEuros: 0</code>,<code>totalInYen: 0</code>}，则需要相应的逻辑进行处理。</p><ol><li><p>在下面的方法中，采用分而治之的方法，即将 <code>reduce</code>函数第一个参数 <code>callback</code>封装为一个数组，由数组中的每一个函数单独进行叠加并完成 <code>reduce</code>操作。所有的一切通过一个 <code>manager</code>函数来管理流程和传递初始参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> manageReducers = <span class="function"><span class="keyword">function</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">state, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(reducers).reduce(</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">nextState, key</span>) </span>&#123;</span><br><span class="line">        reducers[key](state, item);</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面就是 <code>manager</code>函数的实现，它需要 <code>reducers</code>对象作为参数，并返回一个 <code>callback</code>类型的函数，作为 <code>reduce</code>的第一个参数。在该函数内部，则执行多维的叠加工作（<code>Object.keys</code>（））。</p></li><li><p>通过这种分治的思想，可以完成目标对象多个属性的同时叠加，完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reducers = &#123;  </span><br><span class="line">  totalInEuros : <span class="function"><span class="keyword">function</span>(<span class="params">state, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state.euros += item.price * <span class="number">0.897424392</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  totalInYen : <span class="function"><span class="keyword">function</span>(<span class="params">state, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state.yens += item.price * <span class="number">113.852</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manageReducers = <span class="function"><span class="keyword">function</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">state, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(reducers).reduce(</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">nextState, key</span>) </span>&#123;</span><br><span class="line">        reducers[key](state, item);</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bigTotalPriceReducer = manageReducers(reducers);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initialState = &#123;<span class="attr">euros</span>:<span class="number">0</span>, <span class="attr">yens</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = [&#123;<span class="attr">price</span>: <span class="number">10</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">120</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">1000</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> totals = items.reduce(bigTotalPriceReducer, initialState);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(totals);</span><br></pre></td></tr></table></figure></li></ol></li></ul><h5 id="find、findIndex、indexOf"><a href="#find、findIndex、indexOf" class="headerlink" title="find、findIndex、indexOf"></a><code>find</code>、<code>findIndex</code>、<code>indexOf</code></h5><ul><li><p><code>find</code>：返回与指定条件匹配的第一个实例，不会继续查找其他匹配的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> found = arr.find(<span class="function"><span class="params">el</span> =&gt;</span> el &gt; <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(found);</span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li></ul><p>虽然 5 之后的元素都符合条件，但只返回第一个匹配的元素。</p><ul><li><p><code>findIndex</code>：这与 <code>find</code>几乎完全相同，但不返回第一个匹配的元素，而是返回第一个匹配元素的索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Nick'</span>, <span class="string">'Frank'</span>, <span class="string">'Joe'</span>, <span class="string">'Frank'</span>];</span><br><span class="line"><span class="keyword">const</span> foundIndex = arr.findIndex(<span class="function"><span class="params">el</span> =&gt;</span> el === <span class="string">'Frank'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foundIndex);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>indexOf</code>：与 <code>findIndex</code>几乎完全相同，但它的参数不是一个函数，而是一个简单的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Nick'</span>, <span class="string">'Frank'</span>, <span class="string">'Joe'</span>, <span class="string">'Frank'</span>];</span><br><span class="line"><span class="keyword">const</span> foundIndex = arr.indexOf(<span class="string">'Frank'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foundIndex);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="push、pop、shift、unshift"><a href="#push、pop、shift、unshift" class="headerlink" title="push、pop、shift、unshift"></a><code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code></h5><ul><li><p>push：这是一个相对简单的方法，它将一个项添加到数组的末尾。它就地修改数组，函数本身会返回数组的新长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> pushed = arr.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(pushed);</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p><code>pop</code>：从数组中删除最后一项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> popped = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(popped);</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li><p><code>shift</code>：从数组中删除第一个项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> shifted = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(shifted);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>unshift</code>：将一个或多个元素添加到数组的开头。同样，它也是就地修改数组。与其他方法不同的是，函数本身返回数组最新的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> unshifted = arr.unshift(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [5, 6, 7, 1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(unshifted);</span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="splice、slice、sort"><a href="#splice、slice、sort" class="headerlink" title="splice、slice、sort"></a><code>splice</code>、<code>slice</code>、<code>sort</code></h5><ul><li><p><code>splice</code>：通过删除或替换现有元素或者添加新元素来修改数组的内容。这个方法也是就地修改数组。<br>下面的代码示例的意思是：在数组的位置 1 上删除 0 个元素，并插入 b。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'b'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>slice</code>：从指定的起始位置和结束位置之前返回数组的浅拷贝。如果未指定结束位置，则返回数组的其余部分。这个方法不会修改数组，只是返回所需的子集。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"><span class="keyword">const</span> sliced = arr.slice(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sliced);</span><br><span class="line"><span class="comment">// ['c', 'd']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure></li><li><p><code>sort</code>：根据提供的函数对数组进行排序。这个方法就地修改数组。如果函数返回负数或 0，则顺序保持不变。如果返回正数，则交换元素顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> sorter = <span class="function">(<span class="params">firstEl, secondEl</span>) =&gt;</span> firstEl - secondEl;</span><br><span class="line">arr.sort(sorter);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [-1, 1, 2, 3, 5, 7, 7]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="7-生成器"><a href="#7-生成器" class="headerlink" title="7. 生成器"></a>7. 生成器</h4><p>详看阮一峰<a href="http://es6.ruanyifeng.com/#docs/generator">es6 入门</a><br>生成器函数指定下一次调用 <code>next</code>() 时会生成什么 <code>value</code>。既可以生成有限数量的 <code>value</code>（最后调用 <code>next</code>() 会返回 <code>undefined</code>），也可以使用循环生成无限数量的 value。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">greeter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Hi'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'How are you?'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Bye'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> greet = greeter();</span><br><span class="line"><span class="built_in">console</span>.log(greet.next().value);</span><br><span class="line"><span class="comment">// 'Hi'</span></span><br><span class="line"><span class="built_in">console</span>.log(greet.next().value);</span><br><span class="line"><span class="comment">// 'How are you?'</span></span><br><span class="line"><span class="built_in">console</span>.log(greet.next().value);</span><br><span class="line"><span class="comment">// 'Bye'</span></span><br><span class="line"><span class="built_in">console</span>.log(greet.next().value);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>使用生成器生成无限个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idCreator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">yield</span> i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ids = idCreator();</span><br><span class="line"><span class="built_in">console</span>.log(ids.next().value);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(ids.next().value);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(ids.next().value);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// etc...</span></span><br></pre></td></tr></table></figure><h4 id="与"><a href="#与" class="headerlink" title="=== 与 =="></a><code>===</code> 与 <code>==</code></h4><p>一定要知道 <code>JavaScript</code>中 === 运算符和 == 运算符之间的区别！== 运算符在比较之前会进行类型转换，而 === 运算符在比较之前不会进行类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="string">'0'</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> === <span class="string">'0'</span>);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="9-对象比较"><a href="#9-对象比较" class="headerlink" title="9. 对象比较"></a>9. 对象比较</h4><p><code>JavaScript</code>新手容易犯的一个错误是直接比较对象。变量一般是指向内存中对象的引用，而不是对象本身！比较对象的一种方法是将它们转换成 <code>JSON</code>字符串。但这样做有一个缺点：无法保证对象属性的顺序！一种更安全的方法是使用专门进行深度对象比较的库（例如 <code>lodash</code>的 <code>isEqual</code>，<a href="https://lodash.com/docs#isEqual）。">https://lodash.com/docs#isEqual）。</a><br>下面的对象看起来相同，但它们实际上指向不同的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joe1 = &#123; <span class="attr">name</span>: <span class="string">'Joe'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> joe2 = &#123; <span class="attr">name</span>: <span class="string">'Joe'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(joe1 === joe2);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>相反，下面的结果为 <code>true</code>，因为使用其中一个对象为另一个对象赋值，它们都指向相同的引用（内存中只有一个对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joe1 = &#123; <span class="attr">name</span>: <span class="string">'Joe'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> joe2 = joe1;</span><br><span class="line"><span class="built_in">console</span>.log(joe1 === joe2);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="10-回调函数"><a href="#10-回调函数" class="headerlink" title="10. 回调函数"></a>10. 回调函数</h4><p>很多人都被 <code>JavaScript</code>回调函数吓倒了！它们其实很简单，请看下面的例子。<code>console.log</code>函数作为回调传给 <code>myFunc</code>，并在 <code>setTimeout</code>完成时执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">text, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(text);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line">myFunc(<span class="string">'Hello world!'</span>, <span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 'Hello world!'</span></span><br></pre></td></tr></table></figure><h4 id="11-promise"><a href="#11-promise" class="headerlink" title="11. promise"></a>11. <code>promise</code></h4><p>详看阮一峰的<a href="http://es6.ruanyifeng.com/#docs/promise">es6 入门</a><br>一旦你理解了 <code>JavaScript</code>回调，很快就会发现自己陷入了“回调地狱”中。这个时候可以使用 <code>promise</code>！将异步逻辑包装在 <code>promise</code>中，使用“<code>then</code>”来处理成功的情况，使用“<code>catch</code>”来处理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">res, rej</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res(<span class="string">'Hooray!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rej(<span class="string">'Oh no!'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myPromise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Success: '</span> + data);</span><br><span class="line">   &#125;)</span><br><span class="line">   .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// If Math.random() returns less than 0.9 the following is logged:</span></span><br><span class="line"><span class="comment">// "Success: Hooray!"</span></span><br><span class="line"><span class="comment">// If Math.random() returns 0.9 or greater the following is logged:</span></span><br><span class="line"><span class="comment">// "Error: On no!"</span></span><br></pre></td></tr></table></figure><h4 id="12-Async-Await"><a href="#12-Async-Await" class="headerlink" title="12. Async/Await"></a>12. <code>Async</code>/<code>Await</code></h4><p>详看阮一峰的<a href="http://es6.ruanyifeng.com/#docs/async">es6 入门</a><br>在掌握了 <code>promise</code>的用法后，你可能也会喜欢 <code>async await</code>，它只是一种基于 <code>promise</code>的“语法糖”。在下面的示例中，我们创建了一个 <code>async</code>函数，并 <code>await greeter promise</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greeter = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> res(<span class="string">'Hello world!'</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> greeting = <span class="keyword">await</span> greeter;</span><br><span class="line">  <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line">myFunc();</span><br><span class="line"><span class="comment">// 'Hello world!'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript方面&quot;&gt;&lt;a href=&quot;#JavaScript方面&quot; class=&quot;headerlink&quot; title=&quot;JavaScript方面&quot;&gt;&lt;/a&gt;&lt;code&gt;JavaScript&lt;/code&gt;方面&lt;/h2&gt;&lt;h3 id=&quot;12个-JS概念&quot;&gt;&lt;a href=&quot;#12个-JS概念&quot; class=&quot;headerlink&quot; title=&quot;12个 JS概念&quot;&gt;&lt;/a&gt;12个 &lt;code&gt;JS&lt;/code&gt;概念&lt;/h3&gt;&lt;p&gt;来源: &lt;a href=&quot;https://www.infoq.cn/article/3L*kK19KH2Ey7GIVBGsN?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com&quot;&gt;infoQ 了解这 12 个概念，让你的 JavaScript 水平更上一层楼
&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-变量赋值（值与引用）&quot;&gt;&lt;a href=&quot;#1-变量赋值（值与引用）&quot; class=&quot;headerlink&quot; title=&quot;1. 变量赋值（值与引用）&quot;&gt;&lt;/a&gt;1. 变量赋值（值与引用）&lt;/h4&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;总是按照值来给变量赋值。当指定的值是 &lt;code&gt;JavaScript&lt;/code&gt;的五种原始类型之一（即 &lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;和 &lt;code&gt;Number&lt;/code&gt;）时，将为变量分配实际的值。但是，当指定的值是 &lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Function&lt;/code&gt;或 &lt;code&gt;Object&lt;/code&gt;时，将为变量分配内存的对象引用。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JS" scheme="https://kerbalhao.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>异步迭代器与生成器</title>
    <link href="https://kerbalhao.github.io/posts/3346a9db/"/>
    <id>https://kerbalhao.github.io/posts/3346a9db/</id>
    <published>2019-09-12T10:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Async-iterator-and-generators"><a href="#Async-iterator-and-generators" class="headerlink" title="Async iterator and generators"></a>Async iterator and generators</h1><p><strong>翻译自<a href="https://javascript.info/async-iterators-generators">Morden Javascript Tutorial-Async Iterators and Generators</a></strong></p><p>异步 <code>iterator</code> 可以迭代异步请求得到的数据。例如，我们从网络分段下载的数据。异步 <code>generators</code> 使这一步骤更加方便。</p><p>首先，让我们来看一个简单的示例来掌握句法，然后再去看一看现实生活中的例子。</p><h2 id="Async-iterator"><a href="#Async-iterator" class="headerlink" title="Async iterator"></a>Async iterator</h2><p><code>Async iterator</code> 与常规的 <code>iterator</code> 类似，不过有一点语法上的区别。</p><p>一个“常规的” <code>iterables</code> 对象，即我们在 <a href="info:iterable">info:iterable</a> 章节中提到的，是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 for..of 语句的时候就会调用一次这个方法</span></span><br><span class="line">*!*</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ... 它返回一个 iterator 对象：</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 进一步说, for..of 只能作用于可迭代对象,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 使用 next() 方法访问下一个 values</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      current: this.from,</span></span><br><span class="line"><span class="regexp">      last: this.to,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ next() 被 for..of 循环在每一次迭代过程中调用 </span></span><br><span class="line"><span class="regexp">*!*</span></span><br><span class="line"><span class="regexp">      next() &#123; /</span><span class="regexp">/ (2)</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 它应该返回一个类似  &#123;done:.., value :...&#125; 的对象</span></span><br><span class="line"><span class="regexp">*/</span>!*</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.current &lt;= <span class="keyword">this</span>.last) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="keyword">this</span>.current++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> range) &#123;</span><br><span class="line">  alert(value); <span class="comment">// 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有需要的话，您可以返回关于 <a href="info:iterable">info:iterable</a> 的章节查看常规的 <code>iterators</code> 的详细内容。</p><a id="more"></a><p>为了使对象可以异步地迭代：</p><ol><li>我们需要使用 <code>Symbol.asyncIterator</code> 取代 <code>Symbol.iterator</code>。</li><li><code>next()</code> 方法应该返回一个 <code>promise</code>。</li><li>我们应该使用 <code>for await (let item of iterable)</code> 循环来迭代这样的对象</li></ol><p>接下来，让我们创建一个类似于之前的，可迭代的 <code>range</code> 对象，不过现在它会按照每秒一个的速度，异步地返回 values：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 for await..of 语句的时候就会调用一次这个方法</span></span><br><span class="line">*!*</span><br><span class="line">  [<span class="built_in">Symbol</span>.asyncIterator]() &#123; <span class="comment">// (1)</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ... 它返回一个 iterator 对象：</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 进一步说, for await..of 只能作用于可迭代对象,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 使用 next() 方法访问下一个 values</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      current: this.from,</span></span><br><span class="line"><span class="regexp">      last: this.to,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ next() 被 for await..of 循环在每一次迭代过程中调用 </span></span><br><span class="line"><span class="regexp">*!*</span></span><br><span class="line"><span class="regexp">      async next() &#123; /</span><span class="regexp">/ (2)</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 它应该返回一个类似  &#123;done:.., value :...&#125; 的对象</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ (会被 async 关键字自动包装成一个 promise)</span></span><br><span class="line"><span class="regexp">*/</span>!*</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line">        <span class="comment">// 可以在内部使用 await 关键字来执行异步任务:</span></span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">1000</span>)); <span class="comment">// (3)</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">        if (this.current &lt;= this.last) &#123;</span></span><br><span class="line"><span class="regexp">          return &#123; done: false, value: this.current++ &#125;;</span></span><br><span class="line"><span class="regexp">        &#125; else &#123;</span></span><br><span class="line"><span class="regexp">          return &#123; done: true &#125;;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">(async () =&gt; &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">*!*</span></span><br><span class="line"><span class="regexp">  for await (let value of range) &#123; /</span><span class="regexp">/ (4)</span></span><br><span class="line"><span class="regexp">    alert(value); /</span><span class="regexp">/ 1,2,3,4,5</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">*/</span>!*</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>正如我们看到的，其结构类似于常规的 iterators:</p><ol><li>为了异步地迭代一个对象，这个对象必须有 <code>Symbol.asyncIterator</code> 方法 <code>(1)</code></li><li>这个方法必须返回一个带有 <code>next()</code> 方法的对象，该方法会返回一个 <code>promise</code>。<code>(2)</code></li><li>这个 <code>next()</code> 方法可以不使用 <code>async</code> 关键字，它可以是一个常规的方法返回一个 <code>promise</code>，但是使用 <code>async</code> 关键字允许在方法内部使用 <code>await</code>，所以会更加方便。这里我们只是用来延迟 1 秒操作。<code>(3)</code></li><li>我们使用 <code>for await(let value of range)</code> <code>(4)</code>，也就是在 <code>for</code> 后面增加 <code>await</code>。它会调用一次 <code>range[Symbol.asyncIterator]()</code> 方法一次然后调用它的 <code>next()</code> 方法访问 <code>values</code></li></ol><p>这里有一个备忘单表示：</p><table><thead><tr><th></th><th>Iterators</th><th>Async iterators</th></tr></thead><tbody><tr><td>提供 <code>iterator</code> 的对象方法</td><td><code>Symbol.iterator</code></td><td><code>Symbol.asyncIterator</code></td></tr><tr><td><code>next()</code> 返回的值是</td><td>任意值</td><td><code>Promise</code></td></tr><tr><td>使用的循环语法是</td><td><code>for..of</code></td><td><code>for await..of</code></td></tr></tbody></table><figure class="highlight plain"><figcaption><span>header</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">展开运算符要求常规的，同步的 &#96;iterators&#96;，无法工作于异步的 &#96;iterators&#96;。</span><br><span class="line"></span><br><span class="line">例如，展开运算符在以下代码无法执行：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">alert( [...range] ); &#x2F;&#x2F; 错误，没有 Symbol.iterator</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">这很正常，因为它要找到 &#96;Symbol.iterator&#96;，正如 &#96;for..of&#96; 没有 &#96;await&#96;，而非 &#96;Symbol.asyncIterator&#96;。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Async generators</span><br><span class="line"></span><br><span class="line">正如我们所知，JavaScript 也支持 &#96;generators&#96;，并且他们也是可迭代的。</span><br><span class="line"></span><br><span class="line">让我们来回顾一下 &#96;generators&#96; 所在的章节 [info:generators](info:generators)。它从 &#96;start&#96; 到 &#96;end&#96; 生成了一系列的值：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">function* generateSequence(start, end) &#123;</span><br><span class="line">  for (let i &#x3D; start; i &lt;&#x3D; end; i++) &#123;</span><br><span class="line">    yield i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let value of generateSequence(1, 5)) &#123;</span><br><span class="line">  alert(value); &#x2F;&#x2F; 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在常规的 <code>generators</code> 中，我们无法使用 <code>await</code>， 所有的值都必须同步获得：无法在 <code>for..of</code> 循环中延迟执行，这是一个同步的结构。</p><p>但如果我们在 <code>generator</code> 内使用 <code>await</code> 呢？我们可以以网络请求为例子。</p><p>很简单，只需要在前面加上 <code>async</code>，就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">*!*<span class="keyword">async</span>*<span class="regexp">/!* function* generateSequence(start, end) &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  for (let i = start; i &lt;= end; i++) &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">*!*</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 很好，可以使用 await!</span></span><br><span class="line"><span class="regexp">    await new Promise(resolve =&gt; setTimeout(resolve, 1000));</span></span><br><span class="line"><span class="regexp">*/</span>!*</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> generator = generateSequence(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> *!*<span class="keyword">await</span>*<span class="regexp">/!* (let value of generator) &#123;</span></span><br><span class="line"><span class="regexp">    alert(value); /</span><span class="regexp">/ 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;)();</span></span><br></pre></td></tr></table></figure><p>现在，我们有了 <code>async generator</code>，可以使用 <code>for await...of</code> 迭代。</p><p>这实际上非常简单。我们加了 <code>async</code> 关键字，然后我们就能在 <code>generator</code> 内部使用 <code>await</code>，来执行 <code>promise</code> 和其他异步函数。</p><p>从技术上来讲，<code>async generator</code> 的另一个不同之处在于，它的 <code>generatr.next()</code> 方法现在也是异步地，它返回一个 <code>promise</code></p><p>在一个常规的 <code>generator</code> 中，我们使用 <code>result = generator.next()</code> 来获得值。但在一个 <code>async generator</code> 中，我们应该添加 <code>await</code> 关键字，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="keyword">await</span> generator.next(); <span class="comment">// result = &#123;value: ..., done: true/false&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Async-iterables"><a href="#Async-iterables" class="headerlink" title="Async iterables"></a>Async iterables</h2><p>如我们所知道的，要是一个对象可迭代，我们需要给它添加 <code>Symbol.iterator</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line">*!*</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">object</span> <span class="attr">with</span> <span class="attr">next</span> <span class="attr">to</span> <span class="attr">make</span> <span class="attr">range</span> <span class="attr">iterable</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">*/!*</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>对于 <code>Symbol.iterator</code> 来说，一个通常的做法是返回一个 <code>generator</code>，这好过返回一个带有 <code>next()</code> 方法的简单对象。</p><p>让我们来回想一下之前<a href="info:generators"></a>章节中的一个示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123; <span class="comment">// 是 [Symbol.iterator]: function*() 的简写</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value = <span class="keyword">this</span>.from; value &lt;= <span class="keyword">this</span>.to; value++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> range) &#123;</span><br><span class="line">  alert(value); <span class="comment">// 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有一个可迭代的对象 <code>range</code>，并且它的 <code>generator</code> <code>*[Symbol.iterator]</code> 实现了列出 <code>value</code> 的逻辑</p><p>如果们想要给 <code>generator</code> 加上异步操作，那么我们应该将 <code>Symbol.iterator</code> 带换成异步的 <code>Symbol.asyncIterator</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123; <span class="comment">// 等价于 [Symbol.asyncIterator]: async function*()</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">    for(let value = this.from; value &lt;= this.to; value++) &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 在获得 value 之间暂停，执行其他任务 </span></span><br><span class="line"><span class="regexp">      await new Promise(resolve =&gt; setTimeout(resolve, 1000));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      yield value;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">(async () =&gt; &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  for *!*await*/</span>!* (<span class="keyword">let</span> value <span class="keyword">of</span> range) &#123;</span><br><span class="line">    alert(value); <span class="comment">// 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在 <code>value</code> 都是延迟 1 秒后才弹出</p><h2 id="真实例子"><a href="#真实例子" class="headerlink" title="真实例子"></a>真实例子</h2><p>到目前为止，我们为了获得基础的了解，看到的都是简单的例子。接下来，我们就看一下真实应用的例子。</p><p>目前，有很多网络服务都是传递分页的数据。例如，当我们需要一个用户的清单，一个请求只返回了一个预定义数量的用户（例如：100 个用户） - “一页”，并且提供了一个前往下一页的 <code>URL</code>。</p><p>这种模式非常常见。不只是用户，基本所有数据都是。例如， GitHub 允许使用相同的，分页的方式找回提交记录：</p><ul><li>我们应该提交一个请求到这种格式的 <code>URL</code>： <code>https://api.github.com/repos/&lt;repo&gt;/commits</code>。</li><li>它返回一个包含 30 条提交记录的 <code>JSON</code> 对象，并且在返回头的 <code>Link</code> 中提供了一个前往下一页的链接</li><li>然后我们可以使用那个链接作为下一个请求地址，获得更多的提交记录。</li></ul><p>但是我们可以有一个更简单的 API：一个带有提交记录的可迭代对象，然后我们可以像这样来访问它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> repo = <span class="string">'javascript-tutorial/en.javascript.info'</span>; <span class="comment">// 获得提交记录的 GitHub 仓库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> commit <span class="keyword">of</span> fetchCommits(repo)) &#123;</span><br><span class="line">  <span class="comment">// 处理提交记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用一个函数 <code>fetchCommits(repo)</code> ，用来在任何需要的时候，为我们获取提交记录，发送请求等。并且让它关注于所有分页的数据。对于我们来说，它就是一个简单的 <code>for await..of</code>。</p><p>通过使用 <code>async generator</code>，我们可以很简单的实现它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">fetchCommits</span>(<span class="params">repo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">`https://api.github.com/repos/<span class="subst">$&#123;repo&#125;</span>/commits`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (url) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url, &#123; <span class="comment">// (1)</span></span><br><span class="line">      headers: &#123;<span class="string">'User-Agent'</span>: <span class="string">'Our script'</span>&#125;, <span class="comment">// github 要求 user-agent 头部</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> body = <span class="keyword">await</span> response.json(); <span class="comment">// (2) 返回的数据是一个 JSON (提交记录的列表)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3) 前往下一页的 URL 在头部，需要将其提取出来</span></span><br><span class="line">    <span class="keyword">let</span> nextPage = response.headers.get(<span class="string">'Link'</span>).match(<span class="regexp">/&lt;(.*?)&gt;; rel="next"/</span>);</span><br><span class="line">    nextPage = nextPage &amp;&amp; nextPage[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    url = nextPage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> commit <span class="keyword">of</span> body) &#123; <span class="comment">// (4) 一个接一个地 yield 提交记录，直到最后一页</span></span><br><span class="line">      <span class="keyword">yield</span> commit;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们使用浏览器的 <a href="info:fetch">info:fetch</a> 方法从 <code>URL</code> 下载数据。它允许我们提供授权和其他需要的头部，这里 GitHub 需要的是 <code>User-Agent</code></li><li><code>fetch</code> 的结果作为 <code>JSON</code> 被解析，那也是一个 <code>fetch</code> 的特殊方法</li><li>我们应该从返回头的 <code>Link</code> 中获得前往下一页的 <code>URL</code>。它有一个特殊的格式，所以我们可以使用正则表达式得到它。前往下一页的 <code>URL</code> 看起来像：<code>https://api.github.com/repositories/93253246/commits?page=2</code>，这是由 GitHub 自己生成的。</li><li>然后我们将接收的提交记录 <code>yield</code> 出来，当它结束的时候 – 下一个 <code>while(url)</code> 迭代将会触发，从而发送下一个请求</li></ol><p>这是一个使用的例子（将会在用户的控制台显示）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> commit <span class="keyword">of</span> fetchCommits(<span class="string">'javascript-tutorial/en.javascript.info'</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(commit.author.login);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++count == <span class="number">100</span>) &#123; <span class="comment">// let's stop at 100 commits</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这就是我们想要的。从外面无法看到内部的是如何处理分页数据的请求的。对我们来说，那只是一个返回提交记录的 <code>async generator</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于无需花费很长时间生成的数据，常规的 <code>iterators</code> 和 <code>generators</code> 工作良好。</p><p>当我们需要异步获得数据的时候，它们的异步的同行则有了发挥的机会，<code>for await..of</code> 会去替代 <code>for..of</code>。</p><p>异步与常规 <code>iterator</code> 的语法区别：</p><table><thead><tr><th></th><th>Iterable</th><th>Async Iterable</th></tr></thead><tbody><tr><td>提供 <code>iterator</code> 的方法</td><td><code>Symbol.iterator</code></td><td><code>Symbol.asyncIterator</code></td></tr><tr><td><code>next()</code> 返回的值是</td><td><code>{value:…, done: true/false}</code></td><td>被 <code>resolves</code> 成 <code>{value:…, done: true/false}</code> 的 <code>Promise</code></td></tr></tbody></table><p>异步与常规 <code>generator</code> 的语法区别：</p><table><thead><tr><th></th><th>Generators</th><th>Async generators</th></tr></thead><tbody><tr><td>声明方式</td><td><code>function*</code></td><td><code>async function*</code></td></tr><tr><td><code>next()</code> 返回的值是</td><td><code>{value:…, done: true/false}</code></td><td>被 <code>resolves</code> 成 <code>{value:…, done: true/false}</code> 的 <code>Promise</code></td></tr></tbody></table><p>在网络开发中，我们经常会遇到数据流，例如下载或者上传大文件。</p><p>我们可以使用 <code>async generator</code> 来处理类似的数据。值得注意的是，在一些环境，例如浏览器环境下，还有另外一个 API 被叫做 <code>Streams</code>，它提供一些特殊的接口来操作类似的数据流，来传输数据或将其从一个数据流传递到另一个数据流（例如，从一个地方下载后立刻将其发送到其他地方）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Async-iterator-and-generators&quot;&gt;&lt;a href=&quot;#Async-iterator-and-generators&quot; class=&quot;headerlink&quot; title=&quot;Async iterator and generators&quot;&gt;&lt;/a&gt;Async iterator and generators&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;翻译自&lt;a href=&quot;https://javascript.info/async-iterators-generators&quot;&gt;Morden Javascript Tutorial-Async Iterators and Generators&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异步 &lt;code&gt;iterator&lt;/code&gt; 可以迭代异步请求得到的数据。例如，我们从网络分段下载的数据。异步 &lt;code&gt;generators&lt;/code&gt; 使这一步骤更加方便。&lt;/p&gt;
&lt;p&gt;首先，让我们来看一个简单的示例来掌握句法，然后再去看一看现实生活中的例子。&lt;/p&gt;
&lt;h2 id=&quot;Async-iterator&quot;&gt;&lt;a href=&quot;#Async-iterator&quot; class=&quot;headerlink&quot; title=&quot;Async iterator&quot;&gt;&lt;/a&gt;Async iterator&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Async iterator&lt;/code&gt; 与常规的 &lt;code&gt;iterator&lt;/code&gt; 类似，不过有一点语法上的区别。&lt;/p&gt;
&lt;p&gt;一个“常规的” &lt;code&gt;iterables&lt;/code&gt; 对象，即我们在 &lt;a href=&quot;info:iterable&quot;&gt;info:iterable&lt;/a&gt; 章节中提到的，是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; range = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  to: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 使用 for..of 语句的时候就会调用一次这个方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*!*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;.iterator]() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;span class=&quot;regexp&quot;&gt;/!*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ ... 它返回一个 iterator 对象：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ 进一步说, for..of 只能作用于可迭代对象,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ 使用 next() 方法访问下一个 values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    return &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;      current: this.from,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;      last: this.to,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;      /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ next() 被 for..of 循环在每一次迭代过程中调用 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;*!*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;      next() &amp;#123; /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ (2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;        /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ 它应该返回一个类似  &amp;#123;done:.., value :...&amp;#125; 的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;*/&lt;/span&gt;!*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.current &amp;lt;= &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.last) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; &lt;span class=&quot;attr&quot;&gt;done&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.current++ &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; &lt;span class=&quot;attr&quot;&gt;done&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; value &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; range) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  alert(value); &lt;span class=&quot;comment&quot;&gt;// 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;有需要的话，您可以返回关于 &lt;a href=&quot;info:iterable&quot;&gt;info:iterable&lt;/a&gt; 的章节查看常规的 &lt;code&gt;iterators&lt;/code&gt; 的详细内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6, JS, Morden JavaScript Tutorial" scheme="https://kerbalhao.github.io/categories/ES6-JS-Morden-JavaScript-Tutorial/"/>
    
    
      <category term="ES6 迭代器与生成器 JS MJT" scheme="https://kerbalhao.github.io/tags/ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8-JS-MJT/"/>
    
  </entry>
  
  <entry>
    <title>ES6-迭代器与生成器</title>
    <link href="https://kerbalhao.github.io/posts/31d9c0d4/"/>
    <id>https://kerbalhao.github.io/posts/31d9c0d4/</id>
    <published>2019-08-19T10:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-迭代器与生成器"><a href="#ES6-迭代器与生成器" class="headerlink" title="ES6 迭代器与生成器"></a>ES6 迭代器与生成器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是一种特殊的对象，具有专为 迭代过程 设计的撰有接口，迭代器对象都有一个 <code>next()</code> 方法，该方法调用后会返回一个结果对象。</p><p>该结果对象有两个属性：</p><ol><li><code>value</code>，表示下一个将要返回的值</li><li><code>done</code>，是一个布尔值，表示是否迭代完数据集</li></ol><p>迭代其中有一个内部指针，用来指向当前集合中 值 的位置，每调用一次 <code>next()</code> 方法，都会返回下一个可用的 值。</p><p>当最后一个值返回后再调用 <code>next()</code> 方法，返回的对象中 属性 <code>done</code> 的值为 <code>true</code>， 属性 <code>value</code> 则包含迭代器最终返回的 值（这个返回值不是 数据集 中的一部分，它与函数的返回值类似，是函数调用过程中最后一次给 调用者 传递信息 的方法，如果没有相关数据则返回 <code>undefined</code>）</p><a id="more"></a><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是一中返回 迭代器 的函数，通过 <code>function</code> 关键字后的星号(<code>*</code>)来表示，函数中会用到新的关键字 <code>yield</code>，如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span> <span class="comment">// yield 关键字可以返回任何值或者表达式，每当执行完一句 yield 语句后，函数会自动停止执行，知道再次调用迭代器的 next() 方法</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器的调用方式与普通函数一致，不过 返回一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><strong>注意，<code>yield</code> 关键字只能在生成器内部使用，在其他地方，即使是生成器内部的函数内使用，都会抛出错误</strong></p><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>生成器可以用表达式的方式来创建，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">item</span>) </span>&#123;<span class="comment">//code...&#125;</span></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br></pre></td></tr></table></figure><h3 id="生成器对象的方法"><a href="#生成器对象的方法" class="headerlink" title="生成器对象的方法"></a>生成器对象的方法</h3><p>生成器本身就是函数，所以可以将它们添加到对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  *creeateIterator() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator()</span><br></pre></td></tr></table></figure><h3 id="可迭代对象和-for-of-循环"><a href="#可迭代对象和-for-of-循环" class="headerlink" title="可迭代对象和 for-of 循环"></a>可迭代对象和 <code>for-of</code> 循环</h3><p>可迭代对象都具有 <code>Symbol.iterator</code> 属性，是一种与迭代器密切相关的对象。</p><p><code>Symbol.iterator</code> （默认被作为生成器）通过指定的函数可以返回一个作用于附属对象的迭代器</p><p>在 ES6 中，所有的集合对象和字符串都是可迭代对象，都有默认的迭代器</p><p>生成器默认会为 <code>Symbol.iterator</code> 属性赋值，所有通过生成器创建的迭代器都是可迭代对象</p><p><code>for-of</code> 循环每执行一次都会调用可迭代对象的 <code>next()</code> 方法，并将迭代器返回的结果对象 的 <code>value</code> 属性存储在一个变量值，循环将持续执行这一过程，知道对象的 <code>done</code> 属性的 值 为 <code>true</code>,如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> values)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">//被依次输出 1; 2; 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码调用 数组 <code>values</code> 的 <code>Symbol.iterator</code> 方法来获取迭代器，随后迭代器的 <code>next()</code> 方法被多次调用，从它的 返回对象的 <code>value</code> 属性 堆区值 并存储在变量 <code>num</code> 中，当结果对象的 <code>done</code> 属性值为 <code>true</code> 时退出循环，所以 <code>num</code> 不会被赋值为 undefined。</p><h4 id="for-of-与-for-in-区别"><a href="#for-of-与-for-in-区别" class="headerlink" title="for-of 与 for-in 区别"></a><code>for-of</code> 与 <code>for-in</code> 区别</h4><ul><li><code>for-of</code> 循环只可用于可迭代对象，否则会报错。</li><li><code>for-in</code> 循环可枚举对象的属性键，<code>for-of</code> 循环可迭代对象的值</li></ul><h3 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h3><p>我们可以通过访问对象的 <code>Symbol.iterator</code> 来获得对象的 默认迭代器，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 values 的迭代器赋值给 iterator</span></span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// '&#123;value: 1, done: false&#125;'...</span></span><br></pre></td></tr></table></figure><p>因为具有 <code>Symbol.iterator</code> 属性的对象都有默认的迭代器，因此可以使用 <code>typeof obj[Symbol.iterator === &#39;function</code> 来检测对象是否为可迭代对象</p><h3 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h3><p>默认情况下，开发者定义的对象都是不可迭代对象，如果给 <code>Symbol.iterator</code> 属性添加一个生成器，则可以将其变为可迭代对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  items: [],</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">      <span class="keyword">yield</span> item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.items.push(<span class="number">1</span>)</span><br><span class="line">obj.items.push(<span class="number">2</span>)</span><br><span class="line">obj.items.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h2><h3 id="集合对象迭代器"><a href="#集合对象迭代器" class="headerlink" title="集合对象迭代器"></a>集合对象迭代器</h3><p>ES6 中的集合对象有三种： 数组、<code>Map</code> 集合与 <code>Set</code> 集合，这三种对象都内建了以下三种迭代器</p><ul><li><code>enteries()</code> 返回一个迭代器，其值为多个 键值对。每次调用 <code>next()</code> 方法时，<code>entries()</code> 迭代器都会返回一个数组，数组中的两个元素分别表示 集合中 每个元素的键与值。<code>Map</code> 集合的默认迭代器就是 <code>entries()</code> 方法</li><li><code>values()</code> 返回一个迭代器，其值为集合中的所有值，<code>values()</code> 方法是 数组与 <code>Set</code>集合的默认迭代器方法</li><li><code>keys()</code> 返回一个迭代器，其值为集合中的所有键名</li></ul><h4 id="字符串迭代器"><a href="#字符串迭代器" class="headerlink" title="字符串迭代器"></a>字符串迭代器</h4><p>字符串的默认迭代器与数组的默认迭代器一致，都是 <code>values()</code> 方法。</p><h4 id="NodeList-迭代器"><a href="#NodeList-迭代器" class="headerlink" title="NodeList 迭代器"></a><code>NodeList</code> 迭代器</h4><p><code>NodeList</code> 的默认迭代器与数组的默认迭代器一致，都是 <code>values()</code> 方法。</p><h2 id="展开运算符-与-非数组可迭代对象"><a href="#展开运算符-与-非数组可迭代对象" class="headerlink" title="展开运算符 与 非数组可迭代对象"></a>展开运算符 与 非数组可迭代对象</h2><p>通过展开运算符，可以将任何 非数组可迭代对象 转换为 数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>,<span class="string">'Nich'</span>], [<span class="string">'age'</span>: <span class="number">25</span>]]),</span><br><span class="line">    array = [...map]</span><br><span class="line"><span class="built_in">console</span>.log(array) <span class="comment">// [['name','Nich'], ['age': 25]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> small = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    big = [<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>]</span><br><span class="line">    all = [<span class="number">0</span>, ...small, ...big]</span><br><span class="line"><span class="built_in">console</span>.log(all) <span class="comment">// [0, 1, 2, 3, 100, 101, 102]</span></span><br></pre></td></tr></table></figure><h2 id="高级迭代器功能"><a href="#高级迭代器功能" class="headerlink" title="高级迭代器功能"></a>高级迭代器功能</h2><h3 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h3><p>迭代器的 <code>next()</code> 方法可以接受参数，这个参数的值会替代生成器内部，<strong>上一条</strong> <code>yield</code> 语句的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> second = <span class="keyword">yield</span> first  + <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用 next() 方法时，传入的参数会被丢弃 </span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// '&#123;value: 1, done: false&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)) <span class="comment">// '&#123;value: 6, done: false&#125;'</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>)) <span class="comment">// '&#123;value: 8, done: false&#125;'</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// '&#123;value: undefined, done: true&#125;'</span></span><br></pre></td></tr></table></figure><p>在含参的 <code>yield</code> 语句中，<code>yield</code> 关键字后面的计算结果 即为 当前 <code>next()</code> 方法调用后的返回值；<code>next()</code> 方法中传递的参数，是作为 上一次 <code>next()</code> 方法调用后的返回值，用于计算此次 <code>next()</code> 调用后的返回值</p><h3 id="生成器返回语句"><a href="#生成器返回语句" class="headerlink" title="生成器返回语句"></a>生成器返回语句</h3><p>由于生成其实函数，因此可以通过 <code>return</code> 语句提前退出函数执行，对于最后一次 <code>next()</code> 方法调用，可以主动为其指定一个返回值。在生成其中， <code>return</code> 表示所有操作已经完成，属性 <code>done</code> 被设置为 <code>true</code>，如果提供了相应的值，则属性 <code>value</code> 会被设置成这个值。 <code>return</code> 语句指定的返回值，只会在返回对象中出现一次，在后续调用返回的对象中， <code>value</code> 属性会被重置为 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 3 将不会出现</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h3><p>我们可以创建一个生成器，再给 <code>yield</code> 语句添加一个星号，就可以将生成数据的过程委托给其他生成器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">funtion *createNumber() &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'red'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'green'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombined</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> *createNumber()</span><br><span class="line">  <span class="keyword">yield</span> *createColor()</span><br><span class="line">  <span class="keyword">yield</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createCombined()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 'red, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 'green', done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: true, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h2 id="异步迭代器与生成器"><a href="#异步迭代器与生成器" class="headerlink" title="异步迭代器与生成器"></a>异步迭代器与生成器</h2><p>可以查看我翻译自 《现代JavaScript教程》 的文章 <a href="https://zh.javascript.info/async-iterators-generators">异步迭代器与生成器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-迭代器与生成器&quot;&gt;&lt;a href=&quot;#ES6-迭代器与生成器&quot; class=&quot;headerlink&quot; title=&quot;ES6 迭代器与生成器&quot;&gt;&lt;/a&gt;ES6 迭代器与生成器&lt;/h1&gt;&lt;h2 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h2&gt;&lt;p&gt;迭代器是一种特殊的对象，具有专为 迭代过程 设计的撰有接口，迭代器对象都有一个 &lt;code&gt;next()&lt;/code&gt; 方法，该方法调用后会返回一个结果对象。&lt;/p&gt;
&lt;p&gt;该结果对象有两个属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;，表示下一个将要返回的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;done&lt;/code&gt;，是一个布尔值，表示是否迭代完数据集&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;迭代其中有一个内部指针，用来指向当前集合中 值 的位置，每调用一次 &lt;code&gt;next()&lt;/code&gt; 方法，都会返回下一个可用的 值。&lt;/p&gt;
&lt;p&gt;当最后一个值返回后再调用 &lt;code&gt;next()&lt;/code&gt; 方法，返回的对象中 属性 &lt;code&gt;done&lt;/code&gt; 的值为 &lt;code&gt;true&lt;/code&gt;， 属性 &lt;code&gt;value&lt;/code&gt; 则包含迭代器最终返回的 值（这个返回值不是 数据集 中的一部分，它与函数的返回值类似，是函数调用过程中最后一次给 调用者 传递信息 的方法，如果没有相关数据则返回 &lt;code&gt;undefined&lt;/code&gt;）&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6 JS" scheme="https://kerbalhao.github.io/categories/ES6-JS/"/>
    
    
      <category term="ES6 迭代器与生成器 JS" scheme="https://kerbalhao.github.io/tags/ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8-JS/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Set Map</title>
    <link href="https://kerbalhao.github.io/posts/1326466e/"/>
    <id>https://kerbalhao.github.io/posts/1326466e/</id>
    <published>2019-08-09T10:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-Set-集合与-Map-集合"><a href="#ES6-Set-集合与-Map-集合" class="headerlink" title="ES6- Set 集合与 Map 集合"></a>ES6- <code>Set</code> 集合与 <code>Map</code> 集合</h1><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a><code>Set</code> 集合</h2><p>ES6 新增的 <code>Set</code> 类型是一种有序列表，其中含有一些相互独立的 非重复值，通过 <code>Set</code> 集合可以快速访问其中的数据，更有效的追踪各种离散值</p><h3 id="创建-Set-集合并添加元素"><a href="#创建-Set-集合并添加元素" class="headerlink" title="创建 Set 集合并添加元素"></a>创建 <code>Set</code> 集合并添加元素</h3><p>使用 <code>new Set()</code> 创建 <code>Set</code> 集合，调用 <code>add()</code> 方法 可以添加元素，访问 <code>Set</code> 集合的 <code>size</code> 属性 可以获取集合中目前的元素数量。</p><p>调用 <code>add()</code> 方法 将元素添加到 <code>Set</code> 集合中时，不会对所存的值进行强制的类型转换，所以数字 ·<code>5</code> 与 字符串 <code>&#39;5&#39;</code> 可以作为两个独立的存在， <code>Set</code> 中的对象相互之间也保持独立。添加重复元素时，其不会被添加到集合中， <code>Set</code> 集合中的 <code>size</code> 属性 会保持不变。</p><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>调用 <code>delete()</code> 方法 可以移除 <code>Set</code> 集合中的指定元素，调用 <code>clear()</code> 方法 会移除集合中的所有元素</p><a id="more"></a><h3 id="Set-集合的-forEach-方法"><a href="#Set-集合的-forEach-方法" class="headerlink" title="Set 集合的 forEach() 方法"></a><code>Set</code> 集合的 <code>forEach()</code> 方法</h3><p><code>Set</code> 集合 的 <code>forEach</code> 方法与 数组的 <code>forEach</code> 方法类似，但其 <code>回调函数</code> 接受3个参数：</p><ol><li><code>Set</code> 集合中下一次索引的位置</li><li>与第一个参数一样的值</li><li>北边里的 <code>Set</code> 集合本身</li></ol><p>其第一个参数与第二个参数一致很奇怪是吧？我们可以联想一下 数组的 <code>forEach</code> 与 <code>Map</code> 集合的 <code>forEach</code> 方法，这两个集合的 <code>forEach</code> 方法都接受三个参数，与 <code>Set</code> 集合不同的是，它们的前两个参数分别是 值 和 键名(对于数组来说，是 数值型索引值)，而 <code>Set</code> 集合是没有键名也没有数值型索引值的，为了使 <code>forEach</code> 方法的使用便捷，决定将 <code>Set</code> 集合的每个元素也按照键名和值的形式储存(值与键同值)</p><p><code>forEach</code> 方法接受将 <code>this</code> 作为第二个参数，从而可以在回调函数中使用 <code>this</code> 引用</p><p><strong>注意，<code>Set</code> 集合无法通过访问索引访问集合中的元素，不过我们可以将 <code>Set</code> 集合转换为数组</strong></p><h3 id="将-Set-集合转换为数组"><a href="#将-Set-集合转换为数组" class="headerlink" title="将 Set 集合转换为数组"></a>将 <code>Set</code> 集合转换为数组</h3><ul><li>将数组转换为 <code>Set</code> 集合： 给 <code>Set</code> 构造函数传入数组即可，转换为 <code>Set</code> 集合后，<code>Set</code> 集合中不会有重复的元素</li><li>使用展开运算符 <code>...</code> 将 <code>Set</code> 集合转换回数组, 新数组中保存的是 <code>Set</code> 集合中的元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 转换为 Set 集合</span></span><br><span class="line"><span class="keyword">let</span> setG = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(setG) <span class="comment">// Set(5) &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// Set 集合转换为 数组</span></span><br><span class="line"><span class="keyword">let</span>  arr = [...setG]</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (5) [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Weak-Set-集合"><a href="#Weak-Set-集合" class="headerlink" title="Weak Set 集合"></a><code>Weak Set</code> 集合</h3><p><code>Set</code> 集合是强引用的 <code>Set</code> 集合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setG = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">    key = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 对象 key 添加进 Set 中</span></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line">console.log(setG.size) // 1</span><br><span class="line"></span><br><span class="line">// 移除原始引用</span><br><span class="line">key = null</span><br><span class="line"></span><br><span class="line">console.log(setG.size) // 1</span><br><span class="line">// Set 集合保留了对原始对象的引用，仍然可以访问 引用的值，导致垃圾回收机制不能释放原始引用对象的内存空间，可能会造成内存泄漏</span><br><span class="line">key = [...setG][0]</span><br></pre></td></tr></table></figure><p><code>Weak Set</code> 集合是弱引用的 <code>Set</code> 集合，只存储对象的弱引用，并且 <strong>不可以存储原始值</strong>，如果集合中包含任何非对象值，会抛出错误；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存</p><h4 id="创建-Weak-Set-集合"><a href="#创建-Weak-Set-集合" class="headerlink" title="创建 Weak Set 集合"></a>创建 <code>Weak Set</code> 集合</h4><p>用 <code>WeakSet</code> 构造函数可以创建 <code>Weak Set</code> 集合，集合支持3个方法：</p><ol><li><code>add()</code> 方法，向集合中添加元素、</li><li><code>has()</code>方法 检查集合中是否存在指定对象的引用、</li><li><code>delete()</code> 移除指定对象的引用</li></ol><h4 id="两种-Set-类型的区别"><a href="#两种-Set-类型的区别" class="headerlink" title="两种 Set 类型的区别"></a>两种 <code>Set</code> 类型的区别</h4><ol><li>在 <code>WeakSet</code> 实例中，如果向 <code>add(), has(). delete()</code> 这三个方法传入非对象参数都会导致程序报错</li><li><code>Weak Set</code> 集合不可迭代，不能被用于 <code>for-of</code> 循环</li><li><code>Weak Set</code> 集合不暴露任何迭代器方法，所以无法通关程序本身来检测其中的内容</li><li><code>Weak Set</code> 集合不支持 <code>forEach()</code> 方法</li><li><code>Weak Set</code> 集合不支持 <code>size</code> 属性</li></ol><h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a><code>Map</code> 集合</h2><p><code>Map</code> 类型是一种储存着许多 键值对 的 有序列表，其中的 键名 和 值 支持所有的数据属性。</p><p><code>Map</code> 类型的 键名 不会被强制类型转换，所以数字 <code>5</code> 与 字符串 <code>&#39;5&#39;</code> 可以作为两个独立的键</p><p>可以访问 <code>Map</code> 集合的 <code>size</code> 属性，获得集合中元素的数量</p><p><code>Map</code> 类型还能以 对象 作为键值，并将其储存在集合中</p><h3 id="Map-集合支持的方法"><a href="#Map-集合支持的方法" class="headerlink" title="Map 集合支持的方法"></a><code>Map</code> 集合支持的方法</h3><ul><li><code>set()</code> 方法: 分别传入 键名 和 对应的值 作为两个参数，向 <code>Map</code> 集合中添加新的元素</li><li><code>get()</code> 方法： 传入要访问的 键名， 用于访问 <code>Map</code> 集合中的对应键名的值，如果 传入的键名 在集合中不存在，则返回 <code>undefined</code></li><li><code>has()</code> 方法，传入一个指定的键名， 检测指定的键名在 <code>Map</code> 集合中是否已存在</li><li><code>delete()</code> 方法 从 <code>Map</code> 集合中移除指定的键名及其对应的值</li><li><code>clear()</code> 移除 <code>Map</code> 集合中的所有键值对</li></ul><h3 id="Map-集合的初始化方法"><a href="#Map-集合的初始化方法" class="headerlink" title="Map 集合的初始化方法"></a><code>Map</code> 集合的初始化方法</h3><p>可以向 <code>Map</code> 构造函数传入一个数组来初始化一个 <code>Map</code> 集合。数组中的每个元素 都是一个 子数组，子数组中包含一个 键值对的 键名 与 值 两个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>, obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'a'</span>], [<span class="string">'age'</span>, age], [obj, obj]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'name'</span>)) <span class="comment">// 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'age'</span>)) <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(obj)) <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Map-集合的-forEach-方法"><a href="#Map-集合的-forEach-方法" class="headerlink" title="Map 集合的 forEach() 方法"></a><code>Map</code> 集合的 <code>forEach()</code> 方法</h3><p><code>Map</code> 集合 的 <code>forEach</code> 方法与 数组的 <code>forEach</code> 方法类似，其 <code>回调函数</code> 接受3个参数：</p><ol><li><code>Set</code> 集合中下一次索引的位置</li><li>值对应的键名</li><li>北边里的 <code>Set</code> 集合本身</li></ol><p>遍历过程中，会按照 键值对 插入 <code>Map</code> 集合中的顺序，将相应信息传入 <code>forEach()</code> 方法的回调函数</p><h3 id="Weak-Map-集合"><a href="#Weak-Map-集合" class="headerlink" title="Weak Map 集合"></a><code>Weak Map</code> 集合</h3><p><code>Weak Map</code> 是弱引用的 <code>Map</code> 集合，用域存储对象的弱引用。 <code>Weak Map</code> 集合中的键名必须是一个对象，使用非对象键名会报错；集合中的键名保存的是这些对象的弱引用，如果在弱引用之外不存在其他的强引用，引擎的垃圾回收机制会自动回收这个对象，同时也会移除 <code>Weak Map</code> 集合中的 <strong>键值对</strong>。</p><p>**注意，只有集合的键名遵守这个规则，键名对应的 值 如果是一个对象，则保存的是对象的 强引用，不会触发垃圾回收机制。</p><h4 id="Weak-Map-集合支持的方法"><a href="#Weak-Map-集合支持的方法" class="headerlink" title="Weak Map 集合支持的方法"></a><code>Weak Map</code> 集合支持的方法</h4><p><code>Weak Map</code> 类型是一种存储着许多键值对的 无序 列表，列表的键名 必须是非 <code>null</code> 类型的对象，键名对应的值可以是任意类型。</p><ul><li><code>WeakMap</code> 集合通过 <code>set()</code> 方法添加数据，通过 <code>get()</code> 方法获取数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    element = &#123;&#125;</span><br><span class="line">map1.set(element, <span class="string">'Original'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value = map1.get(element)</span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 'Original'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 element 元素</span></span><br><span class="line">element.parentNode.removeChild(element)</span><br><span class="line">element = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于没有键对应的引用，无法通过 get() 方法获取到对应的值，Weak Map 集合自动切断了访问这个值的途径，当垃圾回收程序运行时，被这个值占用的内存将会被释放</span></span><br><span class="line">map1.get(element) <span class="comment">// undefined</span></span><br><span class="line">map1.has(element) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><code>has()</code> 方法可以检测指定的 键 在集合中是否存在</li><li><code>delete()</code> 方法可以根据给定的键名，移除指定的键值对</li></ul><h4 id="Weak-Map-集合的初始化方法"><a href="#Weak-Map-集合的初始化方法" class="headerlink" title="Weak Map 集合的初始化方法"></a><code>Weak Map</code> 集合的初始化方法</h4><p>调用 <code>WeakMap</code> 构造函数并传入一个数组容器，容器内包含其他数组，每一个数组由两个元素够撑，第一个元素是一个键名，传入的值必须是非 <code>null</code> 的对象，第二个元素是这个键对应的值，可以实任意类型</p><h4 id="创建对象私有数据"><a href="#创建对象私有数据" class="headerlink" title="创建对象私有数据"></a>创建对象私有数据</h4><p>我们可以使用 <code>Weak Map</code> 集合来存放私有数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> PrivateData = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person1</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Person 对象的实例被直接作为集合的键使用，用于跟踪数据，值是对象包含的私有数据(name)</span></span><br><span class="line">    privateData.set(<span class="keyword">this</span>, &#123;<span class="attr">name</span>: name&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 getName 是可以获得私有数据</span></span><br><span class="line">  Person1.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> privateData.get(<span class="keyword">this</span>).name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person1</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象实例被销毁时，相关的信息也会被销毁</span></span><br></pre></td></tr></table></figure><h3 id="Weak-Map-与-Map-区别"><a href="#Weak-Map-与-Map-区别" class="headerlink" title="Weak Map 与 Map 区别"></a><code>Weak Map</code> 与 <code>Map</code> 区别</h3><ol><li><code>Weak Map</code> 只能使用 对象 作为集合的键名</li><li><code>Map</code> 的键名是强引用，<code>Weak Map</code> 的键名是弱引用</li><li><code>Weak Map</code> 集合不支持 <code>forEach()</code>, <code>clear()</code> 方法和 <code>size</code> 属性。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-Set-集合与-Map-集合&quot;&gt;&lt;a href=&quot;#ES6-Set-集合与-Map-集合&quot; class=&quot;headerlink&quot; title=&quot;ES6- Set 集合与 Map 集合&quot;&gt;&lt;/a&gt;ES6- &lt;code&gt;Set&lt;/code&gt; 集合与 &lt;code&gt;Map&lt;/code&gt; 集合&lt;/h1&gt;&lt;h2 id=&quot;Set-集合&quot;&gt;&lt;a href=&quot;#Set-集合&quot; class=&quot;headerlink&quot; title=&quot;Set 集合&quot;&gt;&lt;/a&gt;&lt;code&gt;Set&lt;/code&gt; 集合&lt;/h2&gt;&lt;p&gt;ES6 新增的 &lt;code&gt;Set&lt;/code&gt; 类型是一种有序列表，其中含有一些相互独立的 非重复值，通过 &lt;code&gt;Set&lt;/code&gt; 集合可以快速访问其中的数据，更有效的追踪各种离散值&lt;/p&gt;
&lt;h3 id=&quot;创建-Set-集合并添加元素&quot;&gt;&lt;a href=&quot;#创建-Set-集合并添加元素&quot; class=&quot;headerlink&quot; title=&quot;创建 Set 集合并添加元素&quot;&gt;&lt;/a&gt;创建 &lt;code&gt;Set&lt;/code&gt; 集合并添加元素&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;new Set()&lt;/code&gt; 创建 &lt;code&gt;Set&lt;/code&gt; 集合，调用 &lt;code&gt;add()&lt;/code&gt; 方法 可以添加元素，访问 &lt;code&gt;Set&lt;/code&gt; 集合的 &lt;code&gt;size&lt;/code&gt; 属性 可以获取集合中目前的元素数量。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;add()&lt;/code&gt; 方法 将元素添加到 &lt;code&gt;Set&lt;/code&gt; 集合中时，不会对所存的值进行强制的类型转换，所以数字 ·&lt;code&gt;5&lt;/code&gt; 与 字符串 &lt;code&gt;&amp;#39;5&amp;#39;&lt;/code&gt; 可以作为两个独立的存在， &lt;code&gt;Set&lt;/code&gt; 中的对象相互之间也保持独立。添加重复元素时，其不会被添加到集合中， &lt;code&gt;Set&lt;/code&gt; 集合中的 &lt;code&gt;size&lt;/code&gt; 属性 会保持不变。&lt;/p&gt;
&lt;h3 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h3&gt;&lt;p&gt;调用 &lt;code&gt;delete()&lt;/code&gt; 方法 可以移除 &lt;code&gt;Set&lt;/code&gt; 集合中的指定元素，调用 &lt;code&gt;clear()&lt;/code&gt; 方法 会移除集合中的所有元素&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6 JS" scheme="https://kerbalhao.github.io/categories/ES6-JS/"/>
    
    
      <category term="ES6 Set Map JS" scheme="https://kerbalhao.github.io/tags/ES6-Set-Map-JS/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Symbol</title>
    <link href="https://kerbalhao.github.io/posts/67a849eb/"/>
    <id>https://kerbalhao.github.io/posts/67a849eb/</id>
    <published>2019-07-20T07:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-Symbol"><a href="#ES6-Symbol" class="headerlink" title="ES6-Symbol"></a>ES6-<code>Symbol</code></h1><p>主要用于与创建对象的 私有成员</p><h2 id="创建-Symbol"><a href="#创建-Symbol" class="headerlink" title="创建 Symbol"></a>创建 <code>Symbol</code></h2><p><code>Symbol</code> 使基本数据类型之一，但没有字面形式，无法通过 <code>new</code> 关键字创建，只能通过 <code>Symbol</code> 全局函数创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol 接受一个可选参数，用于添加一段文本描述该 Symbol，该描述不可用于属性访问</span></span><br><span class="line"><span class="keyword">let</span> firstSymbol = <span class="built_in">Symbol</span>(<span class="string">'first symbol'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line">person[firstSymbol] = <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'first symbol'</span> <span class="keyword">in</span> person) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(person[firstSymbol]) <span class="comment">// 'a'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//`Symbol` 的描述被存储在内部的 `[[Description]]` 属性中，只有调用 `Symbol` 的 `toString()` 方法才能读取该属性</span></span><br><span class="line"><span class="built_in">console</span>.log(firstSymbol) <span class="comment">// "Symbol(first symbol)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用 typeof 来检测变量是否为 Symbol 类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> firstSymbol) <span class="comment">// 'symbol</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-共享体系"><a href="#Symbol-共享体系" class="headerlink" title="Symbol 共享体系"></a><code>Symbol</code> 共享体系</h2><a id="more"></a><p>在所有使用 可计算属性名 的地方，都可以使用 <code>Symbol</code> 来代替，但是为了在不同代码片段间有效的共享这些 <code>Symbol</code> ，需要建立一个体系。</p><p>如果要创建一个可共享的 <code>Symbol</code> ，需要使用 <code>Symbol.for()</code> 方法，它只接受一个参数，就是将要创建的 <code>Symbol</code> 的字符串标识符，这个参数也被用作 <code>Symbol</code> 的描述文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line">letobject = &#123;[uid]:<span class="string">'12345'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object[uid]) <span class="comment">// '12345'</span></span><br><span class="line"><span class="built_in">console</span>.log(uid) <span class="comment">// 'Symbol(uid)'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// uid 与 uid2 包含相同的 Symbol 并且可以互换使用</span></span><br><span class="line"><span class="built_in">console</span>.log(uid === uid2) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(object[uid2]) <span class="comment">// '12345'</span></span><br><span class="line"><span class="built_in">console</span>.log(uid2) <span class="comment">// 'Symbol(uid)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol.keyFor 方法在 Symbol 全局注册表中检索与 Symbol 有关的键</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid)) <span class="comment">// 'uid'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid2)) <span class="comment">// 'uid'</span></span><br><span class="line"><span class="comment">// Symbol 全局注册表中不粗在 uid3 这个 Symbol， 因而返回 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid3)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如上,<code>Symbol.for()</code> 方法首先在全局 <code>Symbol</code> 注册表中搜索键为 <code>uid</code> 的 <code>Symbol</code> 是否存在，如果存在，直接返回已有的 <code>Symbol</code>；否则，创建一个以 <code>uid</code> 为描述文本的新的 <code>Symbol</code>, 并使用这个键在 <code>Symbol</code> 全局注册表中注册，随即返回新创建的 <code>Symbol</code></p><h2 id="Symbol-与类型强制转换"><a href="#Symbol-与类型强制转换" class="headerlink" title="Symbol 与类型强制转换"></a><code>Symbol</code> 与类型强制转换</h2><p><code>Symbol</code> 无法被强制转换为其他类型，无法进行字符串拼接，也无法与任何一个数学运算符混合使用。</p><p><code>Symbol</code> 只能使用 <code>String(Symbol)</code> 或者 <code>Symbol.toString()</code> 方法，返回字符串类型的 <code>Symbol</code> 描述里的内容</p><h2 id="Symbol-属性检索"><a href="#Symbol-属性检索" class="headerlink" title="Symbol 属性检索"></a><code>Symbol</code> 属性检索</h2><p><code>Object.getOwnProperty-Symbols()</code> 方法，用域检索对象中的 <code>Symbol</code> 属性。该方法的返回值是一个包含所有 <code>Symbol</code> 自有属性的数组</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-Symbol&quot;&gt;&lt;a href=&quot;#ES6-Symbol&quot; class=&quot;headerlink&quot; title=&quot;ES6-Symbol&quot;&gt;&lt;/a&gt;ES6-&lt;code&gt;Symbol&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;主要用于与创建对象的 私有成员&lt;/p&gt;
&lt;h2 id=&quot;创建-Symbol&quot;&gt;&lt;a href=&quot;#创建-Symbol&quot; class=&quot;headerlink&quot; title=&quot;创建 Symbol&quot;&gt;&lt;/a&gt;创建 &lt;code&gt;Symbol&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Symbol&lt;/code&gt; 使基本数据类型之一，但没有字面形式，无法通过 &lt;code&gt;new&lt;/code&gt; 关键字创建，只能通过 &lt;code&gt;Symbol&lt;/code&gt; 全局函数创建：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Symbol 接受一个可选参数，用于添加一段文本描述该 Symbol，该描述不可用于属性访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; firstSymbol = &lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;first symbol&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; person = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person[firstSymbol] = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;first symbol&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; person) &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person[firstSymbol]) &lt;span class=&quot;comment&quot;&gt;// &#39;a&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//`Symbol` 的描述被存储在内部的 `[[Description]]` 属性中，只有调用 `Symbol` 的 `toString()` 方法才能读取该属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(firstSymbol) &lt;span class=&quot;comment&quot;&gt;// &quot;Symbol(first symbol)&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 可以使用 typeof 来检测变量是否为 Symbol 类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; firstSymbol) &lt;span class=&quot;comment&quot;&gt;// &#39;symbol&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;Symbol-共享体系&quot;&gt;&lt;a href=&quot;#Symbol-共享体系&quot; class=&quot;headerlink&quot; title=&quot;Symbol 共享体系&quot;&gt;&lt;/a&gt;&lt;code&gt;Symbol&lt;/code&gt; 共享体系&lt;/h2&gt;
    
    </summary>
    
    
      <category term="ES6 JS" scheme="https://kerbalhao.github.io/categories/ES6-JS/"/>
    
    
      <category term="ES6 Symbol JS" scheme="https://kerbalhao.github.io/tags/ES6-Symbol-JS/"/>
    
  </entry>
  
  <entry>
    <title>ES6-解构</title>
    <link href="https://kerbalhao.github.io/posts/f2b8fbba/"/>
    <id>https://kerbalhao.github.io/posts/f2b8fbba/</id>
    <published>2019-07-10T07:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-解构"><a href="#ES6-解构" class="headerlink" title="ES6-解构"></a>ES6-解构</h1><p>解构赋值表达式(也就是 <code>=</code> 号右边的表达式)如果为 <code>null</code> 或者 <code>undefined</code> 会导致程序抛出错误</p><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象字面量语法形式的解构： 在一个赋值操作符左边放置一个对象字面量，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;<span class="attr">type</span>: <span class="string">'Identifier'</span>, <span class="attr">name</span>: <span class="string">'foo'</span>&#125;</span><br><span class="line"><span class="comment">// 变量声明解构时，必须要提供初始化程序（即必须要赋值（有等号右边的值），否则会报错）</span></span><br><span class="line"><span class="keyword">let</span> &#123;type, name&#125; = node <span class="comment">// 变量声明解构</span></span><br><span class="line"><span class="built_in">console</span>.log(type) <span class="comment">// 'Identifier'</span></span><br><span class="line"><span class="built_in">console</span>.log(name)<span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>可以给 已赋值 的变量进行 解构赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;<span class="attr">type</span>: <span class="string">'Identifier'</span>, <span class="attr">name</span>: <span class="string">'foo'</span>&#125;,</span><br><span class="line">    type=<span class="string">'Literal'</span>,</span><br><span class="line">    name: <span class="number">5</span></span><br><span class="line"><span class="comment">// 解构赋值, 注意,JS引擎将一堆开放的花括号视为一个代码块，语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式</span></span><br><span class="line">(&#123;type, name&#125; = node)</span><br><span class="line"><span class="built_in">console</span>.log(type)<span class="comment">// 'Identifier'</span></span><br><span class="line"><span class="built_in">console</span>.log(name)<span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><a id="more"></a><p>使用解构赋值表达式时，如果指定的 局部变量名称 在对象中不存在，这个局部变量会被赋值为 ‘undefined’:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;<span class="attr">type</span>: <span class="string">'Identifier'</span>, <span class="attr">name</span>: <span class="string">'foo'</span>&#125;</span><br><span class="line"><span class="comment">// value 在 node 中无同名属性, 因此被赋值为 undefined</span></span><br><span class="line"><span class="keyword">let</span> &#123;type, name, value&#125; = node </span><br><span class="line"><span class="built_in">console</span>.log(type) <span class="comment">// 'Identifier'</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// 'foo'</span></span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>当指定属性不存在时，可以给局部变量定义一个默认值，在局部变量后添加一个等号(=)和相应的默认值即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;<span class="attr">type</span>: <span class="string">'Identifier'</span>, <span class="attr">name</span>: <span class="string">'foo'</span>&#125;</span><br><span class="line"><span class="comment">// value 被赋予了一个默认值 true,该默认值只在 node 无同名属性或该属性为 'undefined' 是生效。</span></span><br><span class="line"><span class="keyword">let</span> &#123;type, name, value=<span class="literal">true</span>&#125; = node </span><br><span class="line"><span class="built_in">console</span>.log(type) <span class="comment">// 'Identifier'</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// 'foo'</span></span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="为-非同名局部变量-赋值"><a href="#为-非同名局部变量-赋值" class="headerlink" title="为 非同名局部变量 赋值"></a>为 非同名局部变量 赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;<span class="attr">type</span>: <span class="string">'Identifier'</span>, <span class="attr">name</span>: <span class="string">'foo'</span>&#125;</span><br><span class="line"><span class="comment">// type: localType 语法的含义是 读取都名为 type 的属性，并将其值存储在变量 localType 中</span></span><br><span class="line"><span class="comment">// 这种情况下也可以添加默认值，以下为 localValue 添加了默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">type</span>: localType, <span class="attr">name</span>: localName, <span class="attr">value</span>: localValue = <span class="number">5</span>&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(localType) <span class="comment">// 'Identifier'</span></span><br><span class="line"><span class="built_in">console</span>.log(localName) <span class="comment">//'bar'</span></span><br><span class="line"><span class="built_in">console</span>.log(localValue) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="嵌套对象解构"><a href="#嵌套对象解构" class="headerlink" title="嵌套对象解构"></a>嵌套对象解构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">'Identifier'</span>, </span><br><span class="line">  name: <span class="string">'foo'</span>,</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在解构模式中使用了花括号，含义为在找到 node 对象的 loc 属性后，应当深入一层继续查找 start 属性</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123;start&#125;&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(start.line) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 冒号前的标识符 都代表在对象中的 检索位置，其右侧为 被赋值的变量名；如果冒号后是花括号，则意味着要赋予的最终值被嵌套在对象内部更深的层级中</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123;<span class="attr">start</span>: localStart&#125;&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(localStart.line) <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h2 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h2><p>数组解构使用的是数组字面量，且解构操作全部在数组内完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="comment">// 在数组解构语法中，我们通过 值 在数组中的位置进行选取，且可将其存储在任意变量中，未显示声明的元素都会被直接忽略，在此过程中，数组本身不会发生任何变化</span></span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor] = colors</span><br><span class="line"><span class="built_in">console</span>.log(firstColor) <span class="comment">// 'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor) <span class="comment">// 'green'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组解构语法中，可以直接忽略元素，职位感兴趣的元素提供变量名</span></span><br><span class="line"><span class="keyword">let</span> [, , thirdColor] = colors</span><br><span class="line"><span class="built_in">console</span>.log(thirdColor) <span class="comment">// 'blue'</span></span><br></pre></td></tr></table></figure><h3 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>数组解构也可用于赋值上下文，但不需要用小括号包裹表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">    firstColor = <span class="string">'black'</span></span><br><span class="line">    secondColor = <span class="string">'purple'</span></span><br><span class="line">[firstColor, secondColor] = colors</span><br><span class="line"><span class="built_in">console</span>.log(firstColor) <span class="comment">// 'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor) <span class="comment">// 'green'</span></span><br></pre></td></tr></table></figure><h4 id="交换两个变量的值"><a href="#交换两个变量的值" class="headerlink" title="交换两个变量的值"></a>交换两个变量的值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="comment">// 左侧是一个解构模式，右侧是一个为交换过程创建的 临时数组字面量。在代码执行过程中，先解构临时数组，将 b 和 a 的值复制到左侧数组的前两个位置，最终结果是变量互换了它们的值</span></span><br><span class="line">[a, b] = [b, a]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>可以在数组解构表达式中为数组中的任意位置添加默认值，当指定位置的属性不存在或值为 <code>undefined</code> 时使用默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>]</span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor = <span class="string">'green'</span>] = colors</span><br><span class="line"><span class="built_in">console</span>.log(firstColor) <span class="comment">//'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor) <span class="comment">//'green'</span></span><br></pre></td></tr></table></figure><h3 id="嵌套数组解构"><a href="#嵌套数组解构" class="headerlink" title="嵌套数组解构"></a>嵌套数组解构</h3><p>在原有的 数组解构模式 中插入另一个 数组解构模式，即可将结构过程深入到下一个层级</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, [<span class="string">'green'</span>, <span class="string">'lightgreem'</span>], <span class="string">'blue'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [firstColor, [secondColor]] = colors</span><br><span class="line"><span class="built_in">console</span>.log(firstColor) <span class="comment">//'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor) <span class="comment">//'green'</span></span><br></pre></td></tr></table></figure><h3 id="不定元素"><a href="#不定元素" class="headerlink" title="不定元素"></a>不定元素</h3><p>在数组中，可以通过 <code>...</code> 语法将数组中的其余元素赋值给一个特定的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [firstColor, ...restColor] = colors</span><br><span class="line"><span class="built_in">console</span>.log(firstColor) <span class="comment">// 'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(restColor.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(restColor[<span class="number">0</span>]) <span class="comment">// 'green'</span></span><br><span class="line"><span class="built_in">console</span>.log(restColor[<span class="number">1</span>]) <span class="comment">// 'blue'</span></span><br></pre></td></tr></table></figure><p>不定元素可以实现 数组复制 功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> [...cloneColors] = colors</span><br><span class="line"><span class="built_in">console</span>.log(cloneColors) <span class="comment">// ['red', 'green', 'blue']</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-解构&quot;&gt;&lt;a href=&quot;#ES6-解构&quot; class=&quot;headerlink&quot; title=&quot;ES6-解构&quot;&gt;&lt;/a&gt;ES6-解构&lt;/h1&gt;&lt;p&gt;解构赋值表达式(也就是 &lt;code&gt;=&lt;/code&gt; 号右边的表达式)如果为 &lt;code&gt;null&lt;/code&gt; 或者 &lt;code&gt;undefined&lt;/code&gt; 会导致程序抛出错误&lt;/p&gt;
&lt;h2 id=&quot;对象解构&quot;&gt;&lt;a href=&quot;#对象解构&quot; class=&quot;headerlink&quot; title=&quot;对象解构&quot;&gt;&lt;/a&gt;对象解构&lt;/h2&gt;&lt;p&gt;对象字面量语法形式的解构： 在一个赋值操作符左边放置一个对象字面量，如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; node = &amp;#123;&lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Identifier&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 变量声明解构时，必须要提供初始化程序（即必须要赋值（有等号右边的值），否则会报错）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &amp;#123;type, name&amp;#125; = node &lt;span class=&quot;comment&quot;&gt;// 变量声明解构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(type) &lt;span class=&quot;comment&quot;&gt;// &#39;Identifier&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(name)&lt;span class=&quot;comment&quot;&gt;// &#39;foo&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;解构赋值&quot;&gt;&lt;a href=&quot;#解构赋值&quot; class=&quot;headerlink&quot; title=&quot;解构赋值&quot;&gt;&lt;/a&gt;解构赋值&lt;/h3&gt;&lt;p&gt;可以给 已赋值 的变量进行 解构赋值：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; node = &amp;#123;&lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Identifier&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    type=&lt;span class=&quot;string&quot;&gt;&#39;Literal&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 解构赋值, 注意,JS引擎将一堆开放的花括号视为一个代码块，语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&amp;#123;type, name&amp;#125; = node)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(type)&lt;span class=&quot;comment&quot;&gt;// &#39;Identifier&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(name)&lt;span class=&quot;comment&quot;&gt;// &#39;foo&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;默认值&quot;&gt;&lt;a href=&quot;#默认值&quot; class=&quot;headerlink&quot; title=&quot;默认值&quot;&gt;&lt;/a&gt;默认值&lt;/h3&gt;
    
    </summary>
    
    
      <category term="ES6 JS" scheme="https://kerbalhao.github.io/categories/ES6-JS/"/>
    
    
      <category term="ES6 解构 JS" scheme="https://kerbalhao.github.io/tags/ES6-%E8%A7%A3%E6%9E%84-JS/"/>
    
  </entry>
  
  <entry>
    <title>ES6-对象</title>
    <link href="https://kerbalhao.github.io/posts/1274d57e/"/>
    <id>https://kerbalhao.github.io/posts/1274d57e/</id>
    <published>2019-07-06T01:52:58.000Z</published>
    <updated>2022-04-06T10:48:44.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-对象"><a href="#ES6-对象" class="headerlink" title="ES6 对象"></a>ES6 对象</h1><h2 id="对象字面量-语法扩展"><a href="#对象字面量-语法扩展" class="headerlink" title="对象字面量 语法扩展"></a>对象字面量 语法扩展</h2><h3 id="对象-属性与方法-的简写"><a href="#对象-属性与方法-的简写" class="headerlink" title="对象 属性与方法 的简写"></a>对象 属性与方法 的简写</h3><ul><li>在 ES6 中，如果一个对象的属性与本地变量同名时，可以使用简写的语法，即简单地只写属性名。如<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: name, <span class="attr">age</span>: age&#125;</span><br><span class="line"><span class="comment">//以上代码等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;name, age&#125;</span><br></pre></td></tr></table></figure></li><li>在 ES6 中，对象的方法可以省略 <code>function</code> 关键字与冒号，简写成 <code>&lt;functionName&gt;(){}</code> 的方式，如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">'a'</span>, sayName()&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h3><p>在 ES6 中，对象的属性可以使用 <code>[]</code> 包裹。在对象字面量中，使用方括号表示的该属性名称是可计算的，它的内容将被求值并被转化为一个字符串，如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> end = <span class="string">' name'</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  [<span class="string">'first'</span> + end]: <span class="string">'a'</span>,</span><br><span class="line">  [<span class="string">'last'</span> + end]: <span class="string">'b'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>]) <span class="comment">// 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'last name'</span>]) <span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure><h3 id="重复的-对象字面量-属性"><a href="#重复的-对象字面量-属性" class="headerlink" title="重复的 对象字面量 属性"></a>重复的 对象字面量 属性</h3><p>在 ES6 中，对象的重复属性不会报错，但是同名属性的值 会采用 位于最后的一个属性的取值</p><a id="more"></a><h2 id="Object-新增方法"><a href="#Object-新增方法" class="headerlink" title="Object 新增方法"></a><code>Object</code> 新增方法</h2><h3 id="Object-is-a-b"><a href="#Object-is-a-b" class="headerlink" title="Object.is(a, b)"></a><code>Object.is(a, b)</code></h3><p>该方法用于比较两个值是否相等，其运行结果大部分情况下与 <code>===</code> 元素运算符一致，区别在于 <code>+0</code> 与 <code>-0</code> 被识别为不相等，<code>NaN</code> 与  <code>NaN</code> 等价</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a><code>Object.assign()</code></h3><p>该方法接受一个接收对象 和任意数量的 源对象，并按指定的顺序将属性 复制到接收对象中，最终返回接收对象。</p><p>如果多个源对象具有同名属性，排名靠后的属性会覆盖排名靠前的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver, &#123;<span class="attr">type</span>: <span class="string">'js'</span>, <span class="attr">name</span>:<span class="string">'file.js'</span>&#125;, &#123;<span class="attr">type</span>: <span class="string">'css'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type) <span class="comment">//'css'</span></span><br></pre></td></tr></table></figure><p><strong>注意，<code>Object.assign()</code> 不能将源对象的 访问器属性 复制到接收对象中。因为 <code>Objcet.assign()</code> 执行了赋值操作(即查询 -&gt; 赋值)，因此访问器属性 会被转化为 接收对象的一个数据属性</strong></p><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a><code>Object.getOwnPropertyDescriptors()</code></h3><p>接收一个对象作为参数，返回一个对象，包含指定对象 所有自身属性（非继承属性）和属性描述符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> bar() &#123; <span class="keyword">return</span> <span class="string">'abc'</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)) <span class="comment">//&#123;foo: &#123;value: 123, writable: true, enumerable: true, configurable: true&#125;, bar: &#123;set: undefined, enumerable: true, configurable: true, get: ƒ&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-getPropertypeOf-target"><a href="#Object-getPropertypeOf-target" class="headerlink" title="Object.getPropertypeOf(target)"></a><code>Object.getPropertypeOf(target)</code></h3><p>接收一个对象，返回该对象的原型</p><h3 id="Object-setPropertypeOf-target-source"><a href="#Object-setPropertypeOf-target-source" class="headerlink" title="Object.setPropertypeOf(target, source)"></a><code>Object.setPropertypeOf(target, source)</code></h3><p>接收两个对象，将 <code>source</code> 对象设置为 <code>target</code> 对象的原型</p><h3 id="Object-遍历方法"><a href="#Object-遍历方法" class="headerlink" title="Object 遍历方法"></a><code>Object</code> 遍历方法</h3><ul><li><code>Object.keys()</code> 返回一个包含对象自身所有的 可枚举的 属性键 的的数组</li><li><code>Object.values()</code> 返回一个包含自身所有的 可枚举 属性值 的数组</li><li><code>Object.entries()</code> 返回一个包含对象自身所有的 可枚举 键值对 的数组</li><li><code>Object.fromEntries()</code> 把键值对列表转换为一个对象。</li></ul><h2 id="自有属性枚举顺序"><a href="#自有属性枚举顺序" class="headerlink" title="自有属性枚举顺序"></a>自有属性枚举顺序</h2><p>ES6 中，严格规定了对象的自有属性被枚举时的返回顺序，者将会影响到 <code>Object.getOwnPropertyNames()</code> 方法 及 <code>Reflect.ownKeys</code> 返回属性的方式， <code>Objcet.assign()</code> 方法处理属性的顺序也将随之改变。</p><p>自有属性枚举顺序的基本规则：</p><ol><li>所有数字键按升序排序</li><li>所有字符串键按照他们被加入对象的顺序排序</li><li>所有 <code>symbol</code> 键按照他们被加入对象的顺序排序</li></ol><p><strong>注意，for-in 循环的枚举顺序未被统一，Object.keys() 和 JSON.Stringify() 方法采用与 for-in 相同的枚举顺序，因此他们的枚举顺序目前也不清晰</strong></p><h2 id="增强对象原型"><a href="#增强对象原型" class="headerlink" title="增强对象原型"></a>增强对象原型</h2><h3 id="改变对象的原型"><a href="#改变对象的原型" class="headerlink" title="改变对象的原型"></a>改变对象的原型</h3><p><code>Object.setPropertypeOf()</code> 方法用于改变任意指定对象的原型，接受两个参数： 被改变原型的对象 及 替代第一个参数原型 的对象</p><p><code>Object.create()</code> 方法用于创建一个对象，接收一个参数 <code>null</code> 或 一个对象：</p><ul><li>如果这个参数值为 <code>null</code> 则会创建一个没有原型链的对象，彻底的空对象这个参数会被设置为。</li><li>如果这个参数值是一个对象，那么这个对象会成为 被创建对象的原型。</li></ul><h3 id="简化原型访问的-super-引用"><a href="#简化原型访问的-super-引用" class="headerlink" title="简化原型访问的 super 引用"></a>简化原型访问的 <code>super</code> 引用</h3><p><code>super</code> 引用相当于 指向对象原型 的指针：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;getGreeting() &#123;<span class="keyword">return</span> <span class="string">'Hello'</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> dor = &#123;getGreeting() &#123;<span class="keyword">return</span> <span class="string">'Woof'</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="comment">//相当于 Object.getPropertypeOf(this).getGreeting.call(this)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">'hi!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPropertypeOf(friend, person)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// 'Hello hi!'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPropertypeOf(friend, dog)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// 'Woof hi!'</span></span><br></pre></td></tr></table></figure><p>可以通过 <code>super</code> 引用调用对象原型上所有方法。</p><p><strong>必须要在使用简写方法的对象中使用 <code>super</code> 引用，在其它方法声明中使用会导致语法错误</strong></p><p><strong><code>super</code> 引用不是动态变化的</strong></p><h3 id="正式的方法定义"><a href="#正式的方法定义" class="headerlink" title="正式的方法定义"></a>正式的方法定义</h3><p>在 ES6 中，方法 被正式定义为一个 函数。它会有一个内部的 <code>[[HomeObject]]</code> 属性，来容纳这个方法 从属的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">// 直接将函数赋值给了 person 对象，因而 gerGreeting 方法的 [[HomeObject]] 属性为 person.</span></span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是方法</span></span><br><span class="line"><span class="comment">// 为被赋值给一个对象，因而没有明确定义 [[HomeObject]] 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hi'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>super</code>的所有引用都通过 <code>[[HomeObject]]</code> 来确定后续的运行过程。首先在 <code>[[HomeObject]]</code> 属性上调用 <code>Object.getPropertypeOf()</code> 方法来检索原型的引用，然后搜寻原型找到同名函数；最后，设置 <code>this</code> 绑定并调用相应的方法</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-对象&quot;&gt;&lt;a href=&quot;#ES6-对象&quot; class=&quot;headerlink&quot; title=&quot;ES6 对象&quot;&gt;&lt;/a&gt;ES6 对象&lt;/h1&gt;&lt;h2 id=&quot;对象字面量-语法扩展&quot;&gt;&lt;a href=&quot;#对象字面量-语法扩展&quot; class=&quot;headerlink&quot; title=&quot;对象字面量 语法扩展&quot;&gt;&lt;/a&gt;对象字面量 语法扩展&lt;/h2&gt;&lt;h3 id=&quot;对象-属性与方法-的简写&quot;&gt;&lt;a href=&quot;#对象-属性与方法-的简写&quot; class=&quot;headerlink&quot; title=&quot;对象 属性与方法 的简写&quot;&gt;&lt;/a&gt;对象 属性与方法 的简写&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在 ES6 中，如果一个对象的属性与本地变量同名时，可以使用简写的语法，即简单地只写属性名。如&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &amp;#123;&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: name, &lt;span class=&quot;attr&quot;&gt;age&lt;/span&gt;: age&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//以上代码等同于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &amp;#123;name, age&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;在 ES6 中，对象的方法可以省略 &lt;code&gt;function&lt;/code&gt; 关键字与冒号，简写成 &lt;code&gt;&amp;lt;functionName&amp;gt;(){}&lt;/code&gt; 的方式，如：&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, sayName()&amp;#123;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name)&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;可计算属性名&quot;&gt;&lt;a href=&quot;#可计算属性名&quot; class=&quot;headerlink&quot; title=&quot;可计算属性名&quot;&gt;&lt;/a&gt;可计算属性名&lt;/h3&gt;&lt;p&gt;在 ES6 中，对象的属性可以使用 &lt;code&gt;[]&lt;/code&gt; 包裹。在对象字面量中，使用方括号表示的该属性名称是可计算的，它的内容将被求值并被转化为一个字符串，如&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; end = &lt;span class=&quot;string&quot;&gt;&#39; name&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;string&quot;&gt;&#39;first&#39;&lt;/span&gt; + end]: &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;string&quot;&gt;&#39;last&#39;&lt;/span&gt; + end]: &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person[&lt;span class=&quot;string&quot;&gt;&#39;first name&#39;&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;// &#39;a&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person[&lt;span class=&quot;string&quot;&gt;&#39;last name&#39;&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;// &#39;b&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;重复的-对象字面量-属性&quot;&gt;&lt;a href=&quot;#重复的-对象字面量-属性&quot; class=&quot;headerlink&quot; title=&quot;重复的 对象字面量 属性&quot;&gt;&lt;/a&gt;重复的 对象字面量 属性&lt;/h3&gt;&lt;p&gt;在 ES6 中，对象的重复属性不会报错，但是同名属性的值 会采用 位于最后的一个属性的取值&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ES6 对象 JS" scheme="https://kerbalhao.github.io/tags/ES6-%E5%AF%B9%E8%B1%A1-JS/"/>
    
  </entry>
  
  <entry>
    <title>ES6-函数</title>
    <link href="https://kerbalhao.github.io/posts/fd61cab2/"/>
    <id>https://kerbalhao.github.io/posts/fd61cab2/</id>
    <published>2019-06-28T10:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-函数"><a href="#ES6-函数" class="headerlink" title="ES6 函数"></a>ES6 函数</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul><li>在定义函数时，可以直接给函数参数提供一个默认值：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下，该函数的参数 `timeout`被赋予了一个2000的默认值，`callback`被赋予了一个空函数作为默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout=<span class="number">2000</span>, callback = function(</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>在 ES6 中，默认参数值会影响 <code>arguments</code> 对象，默认参数值的存在会使 <code>arguments</code> 对象与命名参数分离：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下所示，first 与 arguments[0]全等，但是改变形参 first 与 second 的值并不会影响 arguments 对象。所以我们总是可以利用 arguments 对象将形参恢复为初始值 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">first, second=<span class="string">'b'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length) <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]) <span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">//false</span></span><br><span class="line">  first = <span class="string">'c'</span></span><br><span class="line">  second = <span class="string">'d'</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]) <span class="comment">//false</span></span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">//false</span></span><br><span class="line">  first = argumetns[<span class="number">0</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(first)</span><br><span class="line">&#125;(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><ul><li>默认参数的值可以通过函数表达式得到：</li></ul><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处如果默认参数未调用函数，那么传入的只是对函数的引用，而不是函数调用的结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second=getValue(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>))<span class="comment">//6</span></span><br></pre></td></tr></table></figure><ul><li>引用参数默认值的时候，只能引用前面的参数，即先定义的参数不能访问后定义的参数(TDZ)：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当初此执行函数add()时，绑定first和second被添加到一个专属于函数参数的临时性死区，因为当first初始化时second尚未初始化，first试图访问仍在TDZ的second，因此会抛出错误。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first=second, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>))<span class="comment">// err</span></span><br></pre></td></tr></table></figure><p><strong>注意，函数参数有自己的作用域和临时死区，其与函数体的作用域是各自独立的，也就是说函数的默认值不可访问函数体内声明的变量</strong></p><h3 id="无命名参数与不定参数"><a href="#无命名参数与不定参数" class="headerlink" title="无命名参数与不定参数"></a>无命名参数与不定参数</h3><ul><li>无命名参数：调用函数时，提供的参数 超出 声明函数时 提供的参数数量 意外的 参数</li><li>不定参数： 在函数的命名参数前添加三个点(<code>...</code>)就表明这是一个不定参数，该参数为一个数组，包含着自他之后传入的所有参数，通过这个数组名轲注意访问里面的参数</li></ul><p><strong>函数的 length 属性统计的是函数命名参数的数量，不定参数的加入不会影响 length 属性的值</strong></p><h4 id="不定参数的使用限制"><a href="#不定参数的使用限制" class="headerlink" title="不定参数的使用限制"></a>不定参数的使用限制</h4><ul><li>每个函数的最多只能声明一个不定参数，且只能放在所有参数的末尾</li><li>不定参数不能用于对象字面量 setter 中：因为对象字面量 setter 的参数有且只能有一个，而不定参数的定义中，参数可以有无限多个。</li></ul><h4 id="不定参数对-arguments-对象的影响"><a href="#不定参数对-arguments-对象的影响" class="headerlink" title="不定参数对 arguments 对象的影响"></a>不定参数对 arguments 对象的影响</h4><p>无论是否适用不定参数，arguments 对象总是包含了所有传入函数的参数</p><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>展开运算符可以让你指定一个数组，将他们打散后作为各自独立的参数传入函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values)) <span class="comment">//100</span></span><br><span class="line"><span class="comment">//example 2： 此处实现的效果完全等同于 example 1</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values))</span><br></pre></td></tr></table></figure><p>展开运算符适用于函数调用中</p><p>不定参数适用于函数的声明中</p><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>ES6中，所有的函数的 name 属性都有一个合适的值，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="keyword">get</span> firstName() &#123; <span class="keyword">return</span> <span class="string">'a'</span>&#125;,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名函数的 name 的权重高于函数表达式的 name </span></span><br><span class="line"><span class="built_in">console</span>.log(doSomethingElse.name) <span class="comment">// 'doSomethingElse'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name) <span class="comment">//'sayname'</span></span><br><span class="line"><span class="comment">// getter 和 setter 函数的 name 属性有 'get' 'set' 前缀</span></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName.name) <span class="comment">//'get firstName'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAnotherThing() &#123;&#125;</span><br><span class="line"><span class="comment">// bind() 函数创建的函数的 name 属性带有 'bound' 前缀</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.bind().name) <span class="comment">// 'bound doAnotherThing'</span></span><br><span class="line"><span class="comment">// 通过 Function 构造函数创建的函数，其 name 属性带有 'anonymous' 前缀</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name) <span class="comment">//'anonymous'</span></span><br></pre></td></tr></table></figure><p><strong>注意，函数的 <code>name</code> 属性不一定引用同名变量，他只是协助调试用的额外信息，所以不能使用 <code>name</code> 属性的值来获取对于函数的引用</strong></p><h2 id="判断函数如何被调用-的方法"><a href="#判断函数如何被调用-的方法" class="headerlink" title="判断函数如何被调用 的方法"></a>判断函数如何被调用 的方法</h2><p><code>JavaScript</code> 函数有两个内部方法: <code>[[Call]]</code> 和 <code>[[Construct]]</code>：</p><ul><li>当通过 <code>new</code> 关键字调用函数时，执行的时 <code>[[Construct]]</code> 函数，他负责创建一个被称作实例的新对象，然后再执行函数体，将 <code>this</code> 绑定到实例上；</li><li>如果不是通过 <code>new</code> 来调用，则执行 <code>[[Call]]</code> 函数，从而直接执行代码中的函数体，具有 <code>[[Construct]]</code> 方法的函数被统称为构造函数</li></ul><h3 id="元属性-new-target"><a href="#元属性-new-target" class="headerlink" title="元属性 new.target"></a>元属性 <code>new.target</code></h3><p>元属性 <code>new.target</code> 是 ES6 新引入的，指非对象的属性，其可以提供非目标对象的补充信息，主要用于判断函数是否通过 <code>new</code> 关键字调用。</p><p>当调用函数的 <code>[[Construct]]</code> 时， <code>new.target</code> 被赋值为 <code>new</code> 操作为的目标，通常是新创建对象实例，也就是函数体内 <code>this</code> 的构造函数</p><p>如果调用的时 <code>[[Call]]</code> 方法，则 <code>new.target</code> 的值为 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 new 关键字，typeof new.target 指向 构造函数本身</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用 new 关键字来调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AntherPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 未使用 new 关键字，抛出错误</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'a'</span>) <span class="comment">// work</span></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="keyword">new</span> AnotherPerson(<span class="string">'a'</span>) <span class="comment">// err</span></span><br></pre></td></tr></table></figure><h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><p>块级函数是指在块级作用域中声明的函数，ES6中对于严格模式和非严格模式的块级函数的表现有不同：</p><ul><li>严格模式下，块级函数的声明将会被提升到块级作用域的顶部</li><li>非严格模式下，块级作用域的声明将会被提升到外围函数或全局作用域的顶部，因此可以在本块级作用域之外调用。</li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>特性：</p><ul><li>没有 <code>this, super, arguments, new.target</code> 绑定，箭头函数的 <code>this, super, arguments, new.target</code> 这些值由外围最近一层非箭头函数决定</li><li>不能通过 <code>new</code> 关键字调用： 箭头函数没有 <code>[[Construct]]</code> 方法，所以不能被用作构造函数</li><li>没有原型，不存在 <code>prototype</code> 属性</li><li>不可以改变 <code>this</code> 的绑定 函数内部的 <code>this</code> 值不可被改编</li><li>不支持 <code>arguments</code> 对象，但始终可以访问外围函数的 <code>arguments</code> 对象</li><li>不支持重复的命名参数</li></ul><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用是指： 函数作为另一个函数的 最后一条语句被调用</p><p>尾调用的实现： 创建一个新的栈帧，将其推入调用栈来表示函数调用，也就是说， 在循环调用中，每一个未用完的栈帧都会被保存在内存中，当调用栈变得过大时会造成程序问题</p><h3 id="ES6的尾调用优化"><a href="#ES6的尾调用优化" class="headerlink" title="ES6的尾调用优化"></a>ES6的尾调用优化</h3><p>在ES6中严格模式下，如果满足以下条件，尾调用不在创建新的栈帧，而是清楚冰虫蛹当前栈帧：</p><ul><li>尾调用不访问当前栈帧的变量(也就是说函数不是一个闭包)</li><li>在函数内部，尾调用是最后一条语句</li><li>尾调用的结果作为函数值返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 未访问当前栈帧的变更了，尾调用是最后一条语句，尾调用的结果作为函数值返回</span></span><br><span class="line">  <span class="keyword">return</span> doSomethingElse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-函数&quot;&gt;&lt;a href=&quot;#ES6-函数&quot; class=&quot;headerlink&quot; title=&quot;ES6 函数&quot;&gt;&lt;/a&gt;ES6 函数&lt;/h1&gt;&lt;h2 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;h3 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在定义函数时，可以直接给函数参数提供一个默认值：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//如下，该函数的参数 `timeout`被赋予了一个2000的默认值，`callback`被赋予了一个空函数作为默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeRequest&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;url, timeout=&lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;, callback = function(&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;在 ES6 中，默认参数值会影响 &lt;code&gt;arguments&lt;/code&gt; 对象，默认参数值的存在会使 &lt;code&gt;arguments&lt;/code&gt; 对象与命名参数分离：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如下所示，first 与 arguments[0]全等，但是改变形参 first 与 second 的值并不会影响 arguments 对象。所以我们总是可以利用 arguments 对象将形参恢复为初始值 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;first, second=&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length) &lt;span class=&quot;comment&quot;&gt;//1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(first === &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(second === &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  first = &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  second = &lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(first === &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(second === &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  first = argumetns[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(first)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;默认参数的值可以通过函数表达式得到：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ES6 JS" scheme="https://kerbalhao.github.io/categories/ES6-JS/"/>
    
    
      <category term="ES6 函数 JS" scheme="https://kerbalhao.github.io/tags/ES6-%E5%87%BD%E6%95%B0-JS/"/>
    
  </entry>
  
  <entry>
    <title>ES6-块级作用域与字符串</title>
    <link href="https://kerbalhao.github.io/posts/51925e1/"/>
    <id>https://kerbalhao.github.io/posts/51925e1/</id>
    <published>2019-06-18T10:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-块级作用域与字符串"><a href="#ES6-块级作用域与字符串" class="headerlink" title="ES6 块级作用域与字符串"></a>ES6 块级作用域与字符串</h1><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="var-声明及变量提升"><a href="#var-声明及变量提升" class="headerlink" title="var 声明及变量提升"></a><code>var</code> 声明及变量提升</h3><p>在 <strong>函数作用域</strong> 或 <strong>全局作用域</strong> 中通过关键字 <code>var</code> 声明的变量，无论实际上是在那里声明的，都会被当成在当前作用域顶部声明的变量，这就是 <code>var</code> 的变量提升机制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，变量提升机制只是提升对变量的声明，赋值操作未被提升，例如：</span></span><br><span class="line"><span class="comment">// 此时对于变量 a 的声明被提升到顶部，但是 a 未被赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 变量 a 此时才被赋值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>以上代码块可以解释使用 <code>var</code> 声明赋值的变量可以被看成是分成两步走的，</p><ol><li>声明一个变量，并将其提升到作用域顶部</li><li>当代码执行到变量赋值那一行时，才进行变量的赋值操作</li></ol><a id="more"></a><h4 id="块级声明-词法作用域"><a href="#块级声明-词法作用域" class="headerlink" title="块级声明(词法作用域)"></a>块级声明(词法作用域)</h4><p>块级作用域存在于:</p><ul><li>函数内部</li><li>块中(字符 <code>{</code>和 <code>}</code>之间的区域)</li></ul><h5 id="let-声明的变量"><a href="#let-声明的变量" class="headerlink" title="let 声明的变量"></a><code>let</code> 声明的变量</h5><ul><li><p>拥有块级作用域</p></li><li><p>不存在提升机制</p></li><li><p>不允许重复声明同一变量：</p><p>如果作用域中已经存在某个变量标识符，如使用 let 再次声明该变量标识符，则会抛出语法错误，若处于内嵌的作用域中，则无影响。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 内嵌中,work</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'let:'</span> + a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同一作用域中 SyntaxError</span></span><br><span class="line"><span class="keyword">let</span> a =<span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="const-声明的是常量："><a href="#const-声明的是常量：" class="headerlink" title="const 声明的是常量："></a><code>const</code> 声明的是<strong>常量</strong>：</h3><ul><li>在被声明时必须进行初始化(赋值)</li><li>不允许修改绑定，但允许修改值(不可以对基本数据类型的常数进行修改，可以对引用数据类型的常数的属性进行修改)</li><li>不允许重复声明同一变量</li></ul><h2 id="暂时死区-TDZ"><a href="#暂时死区-TDZ" class="headerlink" title="暂时死区(TDZ)"></a>暂时死区(TDZ)</h2><p><code>JavaScript</code> 引擎再扫描代码发现变量时，要么将它们的声明提升到作用于顶部(<code>var</code> 声明)， 要么将声明放到TDZ中(<code>let</code> 和 <code>const</code> 声明)。访问 <code>TDZ</code> 中的标量会触发运行时错误，只有执行过变量声明语句后，变量才会从 <code>TDZ</code> 中移出，然后放可正常访问</p><h3 id="var-let-const-区别"><a href="#var-let-const-区别" class="headerlink" title="var, let, const 区别"></a><code>var</code>, <code>let</code>, <code>const</code> 区别</h3><table><thead><tr><th>区别</th><th>var声明</th><th>let声明</th><th>const声明</th></tr></thead><tbody><tr><td>块级作用域</td><td>x</td><td>o</td><td>o</td></tr><tr><td>提升</td><td>o</td><td>x</td><td>x</td></tr><tr><td>重复声明同一标识符</td><td>o</td><td>x</td><td>x</td></tr><tr><td>标识符再赋值</td><td>o</td><td>o</td><td>x</td></tr><tr><td>声明时必须初始化</td><td>x</td><td>x</td><td>o</td></tr><tr><td>存在 <code>TDZ</code></td><td>x</td><td>o</td><td>o</td></tr><tr><td>在全局作用域中声明时的行为</td><td>会创建一个新的全局变量作为全局对象的属性</td><td>会创建一个全局变量，但不会作为全局对象的属性</td><td>会创建一个全局变量，但不会作为全局对象的属性</td></tr></tbody></table><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串的子串识别"><a href="#字符串的子串识别" class="headerlink" title="字符串的子串识别"></a>字符串的子串识别</h3><ul><li><code>str.includes(string[, index])</code>: 如果在字符串中检测到指定文本则返回true</li><li><code>str.stratsWith(string[, index])</code>: 如果在字符串的起始部分检测到指定的文本则返回true</li><li><code>str.endsWith(string[, index])</code>: 如果在字符串的结束部分检测到指定的文本则返回true</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-块级作用域与字符串&quot;&gt;&lt;a href=&quot;#ES6-块级作用域与字符串&quot; class=&quot;headerlink&quot; title=&quot;ES6 块级作用域与字符串&quot;&gt;&lt;/a&gt;ES6 块级作用域与字符串&lt;/h1&gt;&lt;h2 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h2&gt;&lt;h3 id=&quot;var-声明及变量提升&quot;&gt;&lt;a href=&quot;#var-声明及变量提升&quot; class=&quot;headerlink&quot; title=&quot;var 声明及变量提升&quot;&gt;&lt;/a&gt;&lt;code&gt;var&lt;/code&gt; 声明及变量提升&lt;/h3&gt;&lt;p&gt;在 &lt;strong&gt;函数作用域&lt;/strong&gt; 或 &lt;strong&gt;全局作用域&lt;/strong&gt; 中通过关键字 &lt;code&gt;var&lt;/code&gt; 声明的变量，无论实际上是在那里声明的，都会被当成在当前作用域顶部声明的变量，这就是 &lt;code&gt;var&lt;/code&gt; 的变量提升机制&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 注意，变量提升机制只是提升对变量的声明，赋值操作未被提升，例如：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 此时对于变量 a 的声明被提升到顶部，但是 a 未被赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a) &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 变量 a 此时才被赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a) &lt;span class=&quot;comment&quot;&gt;//1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以上代码块可以解释使用 &lt;code&gt;var&lt;/code&gt; 声明赋值的变量可以被看成是分成两步走的，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明一个变量，并将其提升到作用域顶部&lt;/li&gt;
&lt;li&gt;当代码执行到变量赋值那一行时，才进行变量的赋值操作&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="https://kerbalhao.github.io/categories/ES6/"/>
    
    
      <category term="ES6 JS 块级" scheme="https://kerbalhao.github.io/tags/ES6-JS-%E5%9D%97%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Js现代教程笔记 -- Class</title>
    <link href="https://kerbalhao.github.io/posts/6f845446/"/>
    <id>https://kerbalhao.github.io/posts/6f845446/</id>
    <published>2019-05-10T10:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a><code>Class</code></h1><p><code>ES6</code>提供了一个新的 <code>class</code> 关键字用于更创建基于原型继承的类。</p><h2 id="class-基础语法"><a href="#class-基础语法" class="headerlink" title="class 基础语法"></a><code>class</code> 基础语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  prop = value; <span class="comment">// field</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(...) &#123; <span class="comment">// constructor</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  method(...) &#123;&#125; <span class="comment">// method</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> something(...) &#123;&#125; <span class="comment">// getter method</span></span><br><span class="line">  <span class="keyword">set</span> something(...) &#123;&#125; <span class="comment">// setter method</span></span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;&#125; <span class="comment">// method with computed name/symbol name</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如上，<code>new MyClass()</code> 创建一个有着上列方法的新对象，<code>constructor()</code> 方法会因为 <code>new</code> 操作符被自动调用，再此我们初始化了该对象，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">"John"</span>);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure><p>当 <code>new User(&#39;John&#39;)</code> 被调用：</p><ol><li>一个新对象被创建。</li><li><code>constructor</code> 根据给定的参数运行，并把 <code>this.name</code> 赋值给它</li></ol><h3 id="到底什么是-class-呢"><a href="#到底什么是-class-呢" class="headerlink" title="到底什么是 class 呢"></a>到底什么是 <code>class</code> 呢</h3><p><code>class</code> 的本质还是 函数(<code>Function</code>)。</p><p>上面的例子中， <code>class User{...}</code> 做了这些事情：</p><ol><li><code>class</code> 声明的结果创建了一个叫 <code>User</code> 的函数：函数代码取自 <code>construtor</code> 方法</li><li>把所有其他方法保存在 <code>User.prototype</code></li></ol><p>所以，当我们在新对象调用一个方法时，它是取自 <code>Fn.prototype</code> 的。上面的 <code>new User</code> 对象能从 <code>User.prototype</code> 获得 <code>class</code> 的方法。</p><p>因为我们可以通过不用 <code>class</code> 关键字声明一个看似一样的类，因此有人认为 <code>class</code> 只是一个语法糖，例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rewriting class User in pure functions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Create constructor function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// any function prototype has constructor property by default,</span></span><br><span class="line"><span class="comment">// so we don't need to create it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Add the method to prototype</span></span><br><span class="line">User.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">"John"</span>);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure><p>但是，这个方法和 <code>class</code> 声明有一定的区别：</p><ol><li><p>通过 <code>class</code> 创建的函数有一个隐藏的内部属性 <code>[[FunctionKind]]::&#39;classConstructor&#39;</code>, 因为这个属性，如果不通过 <code>new</code> 运算符调用 <code>class</code>，将会直接报错。而且 <code>class</code> 的字符串描述也不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(User); <span class="comment">// class User &#123; ... &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>class</code> 的方法都是不可枚举的(<code>non-enumerable</code>)。<code>class</code> 声明将 <code>prototype</code> 内的所有方法的 <code>enumerable</code> 描述符都设置为了 <code>false</code>.因此 <code>for...in</code> 将无法获取对象继承到的方法</p></li><li><p><code>class</code> 内的所有代码都是被强制使用了 <code>strict mode</code></p></li></ol><h3 id="class-表达式"><a href="#class-表达式" class="headerlink" title="class 表达式"></a><code>class</code> 表达式</h3><p>与 <code>function</code> 类似，<code>class</code> 也可以被其他表达式定义，比如赋值，<code>return</code> 等。</p><p><code>class</code> 声明也可以是匿名的或者命名的，但是命名的 <code>class</code> 只有在 <code>class</code> 内部才能调用其名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "Named Class Expression" (alas, no such term, but that's what's going on)</span></span><br><span class="line"><span class="keyword">let</span> User = <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(MyClass); <span class="comment">// MyClass is visible only inside the class</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// works, shows MyClass definition</span></span><br><span class="line"></span><br><span class="line">alert(MyClass); <span class="comment">// error, MyClass not visible outside of the class</span></span><br></pre></td></tr></table></figure><p>我们还可以动态地请求生成 <code>class</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClass</span>(<span class="params">phrase</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// declare a class and return it</span></span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">      alert(phrase);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new class</span></span><br><span class="line"><span class="keyword">let</span> User = makeClass(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><h3 id="getter-setter和其他属性"><a href="#getter-setter和其他属性" class="headerlink" title="getter/setter和其他属性"></a><code>getter</code>/<code>setter</code>和其他属性</h3><p><code>class</code> 也包含了 <code>getter</code>/<code>setter</code>,<code>generators</code>, <code>computed</code> 等属性，<br>下面是一个用 <code>get/set</code> 操作 <code>user.name</code> 的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// invokes the setter</span></span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> name(value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">      alert(<span class="string">"Name is too short."</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">"John"</span>);</span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> User(<span class="string">""</span>); <span class="comment">// Name is too short.</span></span><br></pre></td></tr></table></figure><p>实际上，<code>getter</code>和 <code>setter</code> 被创建在 <code>User.prototype</code>，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(User.prototype, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(name) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="class-属性"><a href="#class-属性" class="headerlink" title="class 属性"></a><code>class</code> 属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  name = <span class="string">"Anonymous"</span>; <span class="comment">//*</span></span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi();</span><br><span class="line"></span><br><span class="line">alert(User.prototype.sayHi); <span class="comment">// placed in User.prototype</span></span><br><span class="line">alert(User.prototype.name); <span class="comment">// undefined, not placed in User.prototype</span></span><br></pre></td></tr></table></figure><p>该属性 <code>name</code> 并没有被放在 <code>User.prototype</code>。它是属于对象 <code>User</code> 自身的属性，它会在调用 <code>constructor()</code> 之前通过 <code>new</code> 创建在每个对象内，各对象内的该属性互不影响。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>类可以继承另外一个类。这是一个非常棒的语法，在技术上是它基于原型继承实现的。</p><h3 id="extends-关键字"><a href="#extends-关键字" class="headerlink" title="extends 关键字"></a><code>extends</code> 关键字</h3><p>为了继承另外一个类，我们需要在括号 <code>{..}</code> 前指定 <code>&quot;extends&quot;</code> 和父类</p><p>这里我们写一个继承自 <code>Animal</code> 的 <code>Rabbit：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(speed) &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed += speed;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> runs with speed <span class="subst">$&#123;<span class="keyword">this</span>.speed&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop() &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> stopped.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Animal 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  hide() &#123;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">"White Rabbit"</span>);</span><br><span class="line"></span><br><span class="line">rabbit.run(<span class="number">5</span>); <span class="comment">// 白色兔子会以速度 5 奔跑。</span></span><br><span class="line">rabbit.hide(); <span class="comment">// 白色兔子藏了起来！</span></span><br></pre></td></tr></table></figure><p>例如，为了找到 <code>rabbit.run()</code> 方法，引擎的查找顺序如下：</p><ol><li><code>rabbit</code> 对象（未找到）。</li><li><code>rabbit</code> 的原型，即 <code>Rabbit.prototype</code>（有 <code>hide()</code>，但没有 <code>run</code>）</li><li><code>Rabbit.prototype</code> 的原型，因为 <code>extends</code> 关键字指向了 <code>Animal</code>，即 <code>Animal.prototype</code>，找到 <code>run()</code> 方法</li></ol><p>就如你期望的那样，也正如我们之前所见，<code>extends</code> 关键字实际上是给 <code>Rabbit.prototype</code> 添加了一个属性 <code>[[Prototype]]</code>，并且它会指向 <code>Animal.prototype。</code></p><p>所以，现在 <code>rabbit</code> 即可以访问它自己的方法，也可以访问 <code>Animal</code> 的方法。</p><p><strong>注意，类语法不仅允许在 <code>extends</code> 后指定一个类，也允许指定任何表达式。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">phrase</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">   sayHi() &#123; alert(phrase) &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User extends f("Hello") &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>上面的代码中， <code>User</code> 就是继承了 <code>f(&#39;Hello)</code> 的返回结果</p><h3 id="重写一个方法"><a href="#重写一个方法" class="headerlink" title="重写一个方法"></a>重写一个方法</h3><p>现在让我们继续前进并尝试重写一个方法。到目前为止，<code>Rabbit</code> 继承了 <code>Animal</code> 的 <code>stop</code> 方法，该方法设置了 <code>this.speed = 0。</code></p><p>如果我们在 <code>Rabbit</code> 中定义了我们自己的 <code>stop</code> 方法，那么它将被用来代替 <code>Animal</code> 的 <code>stop</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  stop() &#123;</span><br><span class="line">    <span class="comment">// ...这将用于 rabbit.stop()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…但是通常来说，我们不希望完全替换父类的方法，而是希望基于它做一些调整或者扩展。我们在我们的方法中做一些事情，但是在它之前/之后或在执行过程中调用父类的方法。</p><p>为此，类提供了 <code>&quot;super&quot;</code> 关键字。</p><p>执行 <code>super.methodName(...)</code> 来调用一个父类的方法。<br>执行 <code>super(...)</code> 调用父类的构造函数 (只能在子类的构造函数中执行)。</p><p>例如，让我们的兔子在停下时自动隐藏：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(speed) &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed += speed;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> runs with speed <span class="subst">$&#123;<span class="keyword">this</span>.speed&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop() &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> stopped.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  hide() &#123;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop() &#123;</span><br><span class="line">    <span class="keyword">super</span>.stop(); <span class="comment">// 调用父类的 stop 函数</span></span><br><span class="line">    <span class="keyword">this</span>.hide(); <span class="comment">// 并且在那之后隐藏</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">"White Rabbit"</span>);</span><br><span class="line"></span><br><span class="line">rabbit.run(<span class="number">5</span>); <span class="comment">// White Rabbit runs with speed 5.</span></span><br><span class="line">rabbit.stop(); <span class="comment">// White Rabbit stopped. White rabbit hides!</span></span><br></pre></td></tr></table></figure><p>现在，<code>Rabbit</code> 有自己的 <code>stop</code> 函数，并且在执行过程中会调用父类的 <code>super.stop()。</code></p><p><strong>注意，箭头函数中没有 <code>super</code>. 如果被访问，它将从外部函数获取</strong></p><h3 id="重写构造函数"><a href="#重写构造函数" class="headerlink" title="重写构造函数"></a>重写构造函数</h3><p>到目前为止，<code>Rabbit</code> 还没有自己的 <code>constructor。</code></p><p>根据规范，如果一个类继承了另一个类并且没有构造函数，那么将生成以下构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 为没有构造函数的继承类生成以下的构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，它调用了父类的 <code>constructor</code> 并传递了所有的参数。如果我们不写自己的构造函数，就会出现上述这种情况。</p><p>如果我们要手写子类的构造函数，那么，<strong>继承类的构造函数必须调用 <code>super(...)</code>，并且一定要在使用 <code>this</code> 之前调用。</strong></p><p>为什么呢？在 <code>JavaScript</code> 中，“派生类的构造函数”与所有其他的构造函数之间存在区别。在派生类中，相应的构造函数会被标记为特殊的内部属性 <code>[[ConstructorKind]]:&quot;derived&quot;</code>。</p><p>不同点就在于:</p><ul><li>当一个普通构造函数执行时，它会创建一个空对象作为 <code>this</code> 并继续执行。</li><li>但是当派生的构造函数执行时，它并不会做这件事。它期望父类的构造函数来完成这项工作。</li></ul><p>因此，如果我们构建了我们自己的构造函数，我们必须调用 <code>super</code>，否则的话 <code>this</code> 指向的对象不会被创建，并且我们会收到一个报错。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name, earLength) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name); <span class="comment">//如果没有这一行，下面调用将会报错 Error: this is not defined.</span></span><br><span class="line">    <span class="keyword">this</span>.earLength = earLength;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now fine</span></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">"White Rabbit"</span>, <span class="number">10</span>);</span><br><span class="line">alert(rabbit.name); <span class="comment">// White Rabbit</span></span><br><span class="line">alert(rabbit.earLength); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="Super-内部基于-HomeObject-实现"><a href="#Super-内部基于-HomeObject-实现" class="headerlink" title="Super: 内部基于 [[HomeObject]] 实现"></a><code>Super</code>: 内部基于 <code>[[HomeObject]]</code> 实现</h3><p>让我们再深入的去研究下 <code>super。</code>顺便说一句，我们会发现一些有趣的事情。</p><p>首先要说的是，从我们迄今为止学到的知识来看，<code>super</code> 是不可能运行的。</p><p>的确是这样，让我们问问自己，在技术上它是如何实现的？当一个对象方法运行时，它会将当前对象作为 <code>this。</code>如果之后我们调用 <code>super.method()，</code>那么如何检索 <code>method？</code>我们想当然地认为需要从当前对象的原型中获取 <code>method。</code>但是从技术上讲，我们（或者 <code>JavaScript</code> 的引擎）可以做到这一点吗？</p><p>也许我们可以从 <code>this</code> 的 <code>[[Prototype]]</code> 上获得方法，就像 <code>this.__proto__.method</code>？不幸的是，这样是行不通的。</p><p>让我们尝试去这么做看看。简单起见，我们不使用类，只使用普通对象。</p><p>在这里，<code>rabbit.eat()</code> 会调用父对象的 <code>animal.eat()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  name: <span class="string">"Animal"</span>,</span><br><span class="line">  eat() &#123;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  __proto__: animal,</span><br><span class="line">  name: <span class="string">"Rabbit"</span>,</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="comment">// 这是 super.eat() 可能工作的原因</span></span><br><span class="line">    <span class="keyword">this</span>.__proto__.eat.call(<span class="keyword">this</span>); <span class="comment">// (*)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rabbit.eat(); <span class="comment">// Rabbit eats.</span></span><br></pre></td></tr></table></figure><p>在 <code>(*)</code> 这一行，我们从 <code>animal</code> 的原型上获取 <code>eat，</code>并在当前对象的上下文中调用它。请注意，<code>.call(this)</code>在这里非常重要，因为简单的调用 <code>this.__proto__.eat()</code> 将在原型的上下文中执行 <code>eat，</code>而非当前对象</p><p>在上述的代码中，它按照期望运行：我们获得了正确的 <code>alert。</code></p><p>现在让我们在原型链上再添加一个额外的对象。我们将看到这件事是如何被打破的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  name: <span class="string">"Animal"</span>,</span><br><span class="line">  eat() &#123;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  __proto__: animal,</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="comment">// ...新建一个兔子并调用父类的方法</span></span><br><span class="line">    <span class="keyword">this</span>.__proto__.eat.call(<span class="keyword">this</span>); <span class="comment">// (*)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> longEar = &#123;</span><br><span class="line">  __proto__: rabbit,</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="comment">// ...用长耳朵做一些事情，并调用父类（rabbit）的方法</span></span><br><span class="line">    <span class="keyword">this</span>.__proto__.eat.call(<span class="keyword">this</span>); <span class="comment">// (**)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">longEar.eat(); <span class="comment">// Error: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><p>代码无法再运行了！我们可以看到，在试图调用 <code>longEar.eat()</code> 时抛出了错误。</p><p>原因可能不那么明显，但是如果我们跟踪 <code>longEar.eat()</code> 的调用，就可以发现原因。在 <code>(*)</code> 和 <code>(**)</code> 这两行中，<code>this</code> 的值都是当前对象 <code>longEar。</code>这是至关重要的一点：所有的对象方法都将当前对象作为 <code>this，</code>而非原型或其他什么东西。</p><p>因此，在 <code>(*)</code> 和 <code>(**)</code>这两行中，<code>this.__proto__</code> 的值是完全相同的，都是 <code>rabbit。</code>在这个无限循环中，他们都调用了 <code>rabbit.eat，</code>而不是在原型链上向上寻找方法。</p><ol><li>在 <code>longEar.eat()</code> 中，<code>(**)</code> 这一行调用 <code>rabbit.eat</code> 并且此时 <code>this=longEar</code>.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 longEar.eat() 中 this 指向 longEar</span></span><br><span class="line"><span class="keyword">this</span>.__proto__.eat.call(<span class="keyword">this</span>) <span class="comment">// (**)</span></span><br><span class="line"><span class="comment">// 变成了</span></span><br><span class="line">longEar.__proto__.eat.call(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">// 即等同于</span></span><br><span class="line">rabbit.eat.call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li><li>之后在 <code>rabbit.eat</code> 的 <code>(*)</code>行中，我们希望将函数调用在原型链上向更高层传递，但是因为 <code>this=longEar</code>，因此 <code>this.__proto__.eat</code> 又是 <code>rabbit.eat</code>！<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 rabbit.eat() 中 this 依旧等于 longEar</span></span><br><span class="line"><span class="keyword">this</span>.__proto__.eat.call(<span class="keyword">this</span>) <span class="comment">// (*)</span></span><br><span class="line"><span class="comment">// 变成了</span></span><br><span class="line">longEar.__proto__.eat.call(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">// 再次等同于</span></span><br><span class="line">rabbit.eat.call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li><li>所以 <code>rabbit.eat</code> 不停地循环调用自己，因此它无法进一步地往原型链的更高层调用</li></ol><p>这个问题没法单独使用 <code>this</code> 来解决。</p><h3 id="HomeObject"><a href="#HomeObject" class="headerlink" title="[[HomeObject]]"></a><code>[[HomeObject]]</code></h3><p>为了提供解决方法，<code>JavaScript</code> 为函数额外添加了一个特殊的内部属性 <code>：[[HomeObject]]</code>。</p><p>当一个函数被定义为类或者对象方法时，它的 <code>[[HomeObject]]</code> 属性就成为当前类或对象。</p><p>一般来说，对象中的函数是自由函数，可以改变他们的 <code>this</code> 值，可以在对象间自由地赋值，但是 <code>[[HomeObject]]</code> 违反了 “解除绑定” 功能的想法，因为函数会记录他们绑定的对象。 <code>[[HomeObject]]</code> 不能被改变，并且这个绑定是永久的。</p><p>但是这种改变是安全的。<code>[[HomeObject]]</code> 只有使用 <code>super</code> 调用父类的方法是才会被使用。所以它不会破坏兼容性。</p><p>让我们看看它是如何帮助 <code>super</code> 运行的 —— 我们再次使用普通对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  name: <span class="string">"Animal"</span>,</span><br><span class="line">  eat() &#123;         <span class="comment">// [[HomeObject]] == animal</span></span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  __proto__: animal,</span><br><span class="line">  name: <span class="string">"Rabbit"</span>,</span><br><span class="line">  eat() &#123;         <span class="comment">// [[HomeObject]] == rabbit</span></span><br><span class="line">    <span class="keyword">super</span>.eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> longEar = &#123;</span><br><span class="line">  __proto__: rabbit,</span><br><span class="line">  name: <span class="string">"Long Ear"</span>,</span><br><span class="line">  eat() &#123;         <span class="comment">// [[HomeObject]] == longEar</span></span><br><span class="line">    <span class="keyword">super</span>.eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">longEar.eat();  <span class="comment">// Long Ear eats.</span></span><br></pre></td></tr></table></figure><p>每个方法都会在内部的 <code>[[HomeObject]]</code> 属性上标记它的对象。然后 <code>super</code> 利用它来解析父级原型。</p><p><code>[[HomeObject]]</code> 是为类和简单对象中定义的方法定义的。但是对于对象，方法必须按照给定的方式定义：使用简写的 <code>methodName()</code>，而不是完整 <code>methodName: function()</code>。</p><p>在下面的例子中，使用非方法语法来进行对比 <code>。[[HomeObject]]</code> 属性没有被设置，并且此时继承没有生效：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 应该使用简短语法：eat() &#123;...&#125;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  __proto__: animal,</span><br><span class="line">  eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rabbit.eat();  <span class="comment">// 调用 super 报错（因为没有 [[HomeObject]]）</span></span><br></pre></td></tr></table></figure><h2 id="class的静态属性和方法"><a href="#class的静态属性和方法" class="headerlink" title="class的静态属性和方法"></a><code>class</code>的静态属性和方法</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>我们也可以给 <code>class</code> 本身赋予方法，而不是给其 <code>prototype</code> 赋予方法，这种方法被叫做 <code>静态方法</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两种方法是等价的</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> staticMethod() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span> === User);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">User.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span> === User);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>静态方法并不用于具体的实例，它不要求有实例存在，只要求一个 <code>class</code>，它是 <code>class</code> 独有的，不与实例共享。</p><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性用于存储 <code>class</code> 级的数据，同样不与实例绑定，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> property = ...;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> method() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这相当于把值赋予 <code>class</code> 本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass.property = ...</span><br><span class="line">MyClass.method = ...</span><br></pre></td></tr></table></figure><h3 id="静态属性和方法都是可继承的。"><a href="#静态属性和方法都是可继承的。" class="headerlink" title="静态属性和方法都是可继承的。"></a>静态属性和方法都是可继承的。</h3><p>技术上来讲，对于 <code>class B extends A</code>,类 <code>B</code> 的原型指向类 <code>A</code>： <code>B.[[prototype]] = A</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> planet = <span class="string">"Earth"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name, speed) &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(speed = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed += speed;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> runs with speed <span class="subst">$&#123;<span class="keyword">this</span>.speed&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> compare(animalA, animalB) &#123;</span><br><span class="line">    <span class="keyword">return</span> animalA.speed - animalB.speed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inherit from Animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  hide() &#123;</span><br><span class="line">    alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbits = [</span><br><span class="line">  <span class="keyword">new</span> Rabbit(<span class="string">"White Rabbit"</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Rabbit(<span class="string">"Black Rabbit"</span>, <span class="number">5</span>)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">rabbits.sort(Rabbit.compare);</span><br><span class="line"></span><br><span class="line">rabbits[<span class="number">0</span>].run(); <span class="comment">// Black Rabbit runs with speed 5.</span></span><br><span class="line"></span><br><span class="line">alert(Rabbit.planet); <span class="comment">// Earth</span></span><br></pre></td></tr></table></figure><p>如上述代码，当我们调用 <code>Rabbit.compare()</code> 的时候，调用的是继承自 <code>Animal</code> 的静态方法 <code>compare()</code></p><p>这是如何实现的呢？也是通过 <code>prototype</code>，正如你所想的， <code>extends</code> 将 <code>Rabbit</code> 的 <code>[[Prototype]]</code> 指向了 <code>Animal</code></p><p>所以，我们可以说， <code>Rabbit extends Animal</code> 创建了两个 <code>[[Prototype]]</code> 的引用：</p><ol><li><code>Rabbit</code> 类自身的 <code>[[Prototype]]</code> 指向 <code>Animal</code> 类自身</li><li><code>Rabbit.prototype</code> 的 <code>[[Prototype]]</code> 指向 <code>Animal.prototype</code></li></ol><p>所以，继承对于常规方法和静态方法都管用</p><p>我们可以通过代码来检测一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for statics</span></span><br><span class="line">alert(Rabbit.__proto__ === Animal); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for regular methods</span></span><br><span class="line">alert(Rabbit.prototype.__proto__ === Animal.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="内置类没有静态方法继承"><a href="#内置类没有静态方法继承" class="headerlink" title="内置类没有静态方法继承"></a>内置类没有静态方法继承</h3><p>请注意，内置类没有这种静态 <code>[[Prototype]]</code> 的引用。例如， <code>Object</code> 有 <code>Object.defineProperty，``Object.keys</code> 等等的方法，但是 <code>Array，``Date</code> 等等并不会继承他们。</p><p>请注意，<code>Date</code> 和 <code>Object</code> 之间没有关联 <code>。Object</code> 和 <code>Date</code> 都是独立存在的 <code>。Date.prototype</code> 继承自 <code>Object.prototype，</code>但也仅此而已。</p><h3 id="原生方法是可扩展的"><a href="#原生方法是可扩展的" class="headerlink" title="原生方法是可扩展的"></a>原生方法是可扩展的</h3><p><code>Array，``Map</code> 等 <code>JavaScript</code> 内置的类也是可以扩展的。</p><p>例如，这里的 <code>PowerArray</code> 继承自原生的 <code>Array：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 给 Array 增加一个新方法（可以做更多功能）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> PowerArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">alert(arr.isEmpty()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filteredArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">10</span>);</span><br><span class="line">alert(filteredArr); <span class="comment">// 10, 50</span></span><br><span class="line">alert(filteredArr.isEmpty()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>有一件非常有趣的事情需要注意。像 <code>filter</code>，<code>map</code> 或者其他原生的方法，都会根据继承的类型返回新的对象。他们都是依赖 <code>constructor</code> 属性实现的这一功能。</p><p>在上面的例子中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.constructor === PowerArray</span><br></pre></td></tr></table></figure><p>所以当调用 <code>arr.filter()</code> 时，就像 <code>new PowerArray</code> 一样，他会在内部创建新的结果数组。并且我们可以继续链式调用它的方法。</p><p>更重要的是，我们可以定制这种行为。在这种情况下，如果存在静态的 <code>getter</code> <code>Symbol.species，</code>那么就会使用它的返回值作为构造函数。</p><p>举个例子，这里因为有 <code>Symbol.species，</code>像 <code>map，``filter</code> 这样的内置方法将返回“普通”数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内置函数会使用它作为构造函数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> PowerArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">alert(arr.isEmpty()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter 使用 arr.constructor[Symbol.species] 作为构造函数创建了新数组</span></span><br><span class="line"><span class="keyword">let</span> filteredArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// filteredArr 不是 PowerArray，而是一个 普通数组</span></span><br><span class="line">alert(filteredArr.isEmpty()); <span class="comment">// Error: filteredArr.isEmpty is not a function</span></span><br></pre></td></tr></table></figure><h2 id="JavaScript-中的-Mixin-模式"><a href="#JavaScript-中的-Mixin-模式" class="headerlink" title="JavaScript 中的 Mixin 模式"></a><code>JavaScript</code> 中的 <code>Mixin</code> 模式</h2><p>根据维基百科的定义，<code>mixin</code> 是一个包含许多供其它类使用的方法的类，而且这个类不必是其它类的父类。</p><p>换句话说，一个 <code>mixin</code> 提供了许多实现具体行为的方法，但是我们不单独使用它，我们用它来将这些行为添加到其它类中。</p><p>###一个 <code>Mixin</code> 实例<br>在 <code>JavaScript</code> 中构造一个 <code>mixin</code> 最简单的方式就是构造一个拥有许多实用方法的对象，通过这个对象我们可以轻易地将这些实用方法合并到任何类的原型中。</p><p>例如，这个叫做 <code>sayHiMixin</code> 的 <code>mixin</code> 用于给 <code>User</code> 添加一些“言语”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// mixin</span></span><br><span class="line"><span class="keyword">let</span> sayHiMixin = &#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(<span class="string">`Hello <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayBye() &#123;</span><br><span class="line">    alert(<span class="string">`Bye <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 User 可以说　hi 了</span></span><br><span class="line"><span class="keyword">new</span> User(<span class="string">"Dude"</span>).sayHi(); <span class="comment">// Hello Dude!</span></span><br></pre></td></tr></table></figure><p>没有继承，只有一个简单的方法拷贝。因此 <code>User</code> 可以扩展其它类并且同样包含 <code>mixin</code> 来 <code>“mix-in”</code>其它方法，就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br></pre></td></tr></table></figure><p><code>Mixin</code> 可以在自己内部使用继承。</p><p>比如，这里的 <code>sayHiMixin</code> 继承于 <code>sayMixin</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayMixin = &#123;</span><br><span class="line">  say(phrase) &#123;</span><br><span class="line">    alert(phrase);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHiMixin = &#123;</span><br><span class="line">  __proto__: sayMixin, <span class="comment">// （或者，我们可以在这里通过 Object.create 来设置原型。）</span></span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="comment">// 调用父类中的方法</span></span><br><span class="line">    <span class="keyword">super</span>.say(<span class="string">`Hello <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayBye() &#123;</span><br><span class="line">    <span class="keyword">super</span>.say(<span class="string">`Bye <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 User 可以说 hi 了</span></span><br><span class="line"><span class="keyword">new</span> User(<span class="string">"Dude"</span>).sayHi(); <span class="comment">// Hello Dude!</span></span><br></pre></td></tr></table></figure><p>请注意在 <code>sayHiMixin</code> 内部对于父类方法 <code>super.say()</code> 的调用会在 <code>mixin</code> 的原型上查找方法而不是在 <code>class</code> 自身查找。</p><p>那是因为 <code>sayHiMixin</code> 内部的方法设置了 <code>[[HomeObject]]</code> 属性。因此 <code>super</code> 实际上就是 <code>sayHiMixin.__proto__</code> ，而不是 <code>User.__proto__</code>。</p><h3 id="EventMixin"><a href="#EventMixin" class="headerlink" title="EventMixin"></a><code>EventMixin</code></h3><p>现在让我们为了实际运用构造一个 <code>mixin</code>。</p><p>许多对象的重要特征是与事件一起工作。</p><p>也就是说：对象应该有一个方法在发生重要事件时“生成事件”，其它对象应该能够“监听”这样的事件。</p><p>一个事件必须有一个名称，并可以选择性的捆绑一些额外的数据。</p><p>比如说，一个 <code>user</code> 对象能够在访问者登录时产生“<code>login</code>”事件。另一个 <code>calendar</code> 对象可能在等待着接受一个这样的事件以便为登录后的用户加载日历。</p><p>或者，<code>menu</code> 在菜单选项被选择之后会产生 “<code>select</code>“ 事件，并且其它对象可能在等待着接受事件的信息并且对事件做出反应。</p><p>事件是一种与任何想要得到信息的人分享信息的方式。它在任何类中都可以使用，因此现在为它构造一个 <code>mixin</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> eventMixin = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 订阅事件，用法：</span></span><br><span class="line"><span class="comment">   *  menu.on('select', function(item) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  on(eventName, handler) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._eventHandlers) <span class="keyword">this</span>._eventHandlers = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._eventHandlers[eventName]) &#123;</span><br><span class="line">      <span class="keyword">this</span>._eventHandlers[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._eventHandlers[eventName].push(handler);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取消订阅，用法：</span></span><br><span class="line"><span class="comment">   *  menu.off('select', handler)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  off(eventName, handler) &#123;</span><br><span class="line">    <span class="keyword">let</span> handlers = <span class="keyword">this</span>._eventHandlers &amp;&amp; <span class="keyword">this</span>._eventHandlers[eventName];</span><br><span class="line">    <span class="keyword">if</span> (!handlers) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (handlers[i] === handler) &#123;</span><br><span class="line">        handlers.splice(i--, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 触发事件并传递参数</span></span><br><span class="line"><span class="comment">   *  this.trigger('select', data1, data2);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  trigger(eventName, ...args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._eventHandlers || !<span class="keyword">this</span>._eventHandlers[eventName]) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 对应事件名没有事件处理函数。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用事件处理函数</span></span><br><span class="line">    <span class="keyword">this</span>._eventHandlers[eventName].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler.apply(<span class="keyword">this</span>, args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有三个方法：</p><p><code>.on(eventName, handler)</code> — 指定函数 handler 在具有对应事件名的事件发生时运行。这些事件处理函数存储在 _eventHandlers 属性中。<br><code>.off(eventName, handler)</code> — 在事件处理函数列表中移除指定的函数。<br><code>.trigger(eventName, ...args)</code> — 触发事件：所有被指定到对应事件的事件处理函数都会被调用并且 args 会被作为参数传递给它们。<br>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 新建一个 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">  choose(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.trigger(<span class="string">"select"</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 mixin</span></span><br><span class="line"><span class="built_in">Object</span>.assign(Menu.prototype, eventMixin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> menu = <span class="keyword">new</span> Menu();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被选中时调用事件处理函数：</span></span><br><span class="line">menu.on(<span class="string">"select"</span>, value =&gt; alert(<span class="string">`Value selected: <span class="subst">$&#123;value&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件 =&gt; 展示被选中的值：123</span></span><br><span class="line">menu.choose(<span class="string">"123"</span>); <span class="comment">// 被选中的值</span></span><br></pre></td></tr></table></figure><p>现在如果我们已经有了针对用户选择事件做出具体反应的代码，可以将代码使用 menu.on(…) 进行绑定。</p><p>只要我们喜欢，就可以通过 eventMixin 将这些行为添加到任意个数的类中而不影响继承链。</p><p>总结<br><code>Mixin</code> — 是一个通用的面向对象编程术语：一个包含其他类的方法的类。</p><p>一些其它语言比如 <code>python</code> 允许通过多继承实现 <code>mixin``。JavaScript</code> 不支持多继承，但是可以通过拷贝多个类中的方法到某个类的原型中实现 <code>mixin</code>。</p><p>我们可以使用 <code>mixin</code> 作为一种通过多种行为来增强类的方式，就像我们上面看到的事件处理一样。</p><p>如果 <code>Mixins</code> 偶尔会重写原生类中的方法，那么 <code>Mixins</code> 可能会成为一个冲突点。因此通常情况下应该好好考虑 <code>mixin</code> 的命名，以减少这种冲突的可能性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Class&quot;&gt;&lt;a href=&quot;#Class&quot; class=&quot;headerlink&quot; title=&quot;Class&quot;&gt;&lt;/a&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt;提供了一个新的 &lt;code&gt;class&lt;/code&gt; 关键字用于更创建基于原型继承的类。&lt;/p&gt;
&lt;h2 id=&quot;class-基础语法&quot;&gt;&lt;a href=&quot;#class-基础语法&quot; class=&quot;headerlink&quot; title=&quot;class 基础语法&quot;&gt;&lt;/a&gt;&lt;code&gt;class&lt;/code&gt; 基础语法&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  prop = value; &lt;span class=&quot;comment&quot;&gt;// field&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(...) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// constructor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  method(...) &amp;#123;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// method&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; something(...) &amp;#123;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// getter method&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; something(...) &amp;#123;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// setter method&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;.iterator]() &amp;#123;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// method with computed name/symbol name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Morden JavaScript Tutorial" scheme="https://kerbalhao.github.io/categories/Morden-JavaScript-Tutorial/"/>
    
    
      <category term="JS Class" scheme="https://kerbalhao.github.io/tags/JS-Class/"/>
    
  </entry>
  
  <entry>
    <title>Js现代教程笔记 -- 原型与继承</title>
    <link href="https://kerbalhao.github.io/posts/7443f62b/"/>
    <id>https://kerbalhao.github.io/posts/7443f62b/</id>
    <published>2019-05-01T10:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型与继承"><a href="#原型与继承" class="headerlink" title="原型与继承"></a>原型与继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在 <code>JavaScript</code> 中，每个对象都有一个特殊的隐藏属性 <code>[[Prototype]]</code> ，该属性的值只能是 null 或者其他对象的引用(叫做 原型对象)。</p><p><code>[[Prototype]]</code> 有一个“神奇”的意义。当我们想要从 object 中读取一个属性时，它就丢失了。JavaScript 会自动从原型中获取它。在编程中，这样的事情称为“原型继承”。</p><h3 id="原型对象-Prototype"><a href="#原型对象-Prototype" class="headerlink" title="原型对象 [[Prototype]]"></a>原型对象 <code>[[Prototype]]</code></h3><p>原型对象 <code>[[Prototype]]</code> 是一个内部，而且隐藏的对象，我们可以用以下及中方法来设置它：</p><ol><li><p><code>__proto__</code> 方法<br><code>__proto__</code> 是历史遗留的 <code>[[Prototype]]</code>对象的 <code>getter</code>/<code>setter</code>，注意，这只是一个 <code>getter</code>/<code>setter</code>。(不推荐使用在客户端，但可以用于服务器端)</p><p>我们可以手动通过 <code>__proto__</code> 设置对象的原型，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">eats: <span class="literal">true</span>,</span><br><span class="line">walk() &#123;</span><br><span class="line">    alert(<span class="string">"Animal walk"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">jumps: <span class="literal">true</span>,</span><br><span class="line">__proto__: animal <span class="comment">//*</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> longEar = &#123;</span><br><span class="line">earLength: <span class="number">10</span>,</span><br><span class="line">__proto__: rabbit <span class="comment">//*</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// walk is taken from the prototype chain</span></span><br><span class="line">longEar.walk(); <span class="comment">// Animal walk</span></span><br><span class="line">alert(longEar.jumps); <span class="comment">// true (from rabbit)</span></span><br></pre></td></tr></table></figure><p>注意，对于 <code>__proto__</code> 有两个限制：</p><ol><li>The references can’t go in circles. JavaScript will throw an error if we try to assign <code>__proto__</code> in a circle.</li><li>The value of <code>__proto__</code> can be either an object or null, other types (like primitives) are ignored.</li></ol></li><li><p>使用 <code>Object.getPrototypeOf</code>/<code>Object.setPrototypeOf</code>方法(推荐使用，详看下方 关于原型的方法e)</p></li></ol><a id="more"></a><h3 id="原型作用于数据属性的读取"><a href="#原型作用于数据属性的读取" class="headerlink" title="原型作用于数据属性的读取"></a>原型作用于数据属性的读取</h3><p>只有对象数据属性的读取会涉及到原型，对象数据属性的写入以及删除一般与原型无关。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  eats: <span class="literal">true</span>,</span><br><span class="line">  walk() &#123;</span><br><span class="line">      alert(<span class="string">'animal'</span>)</span><br><span class="line">    <span class="comment">/* this method won't be used by rabbit */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  __proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rabbit.walk(); <span class="comment">// animal  *</span></span><br><span class="line"></span><br><span class="line">rabbit.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Rabbit! Bounce-bounce!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rabbit.walk(); <span class="comment">// Rabbit! Bounce-bounce! **</span></span><br></pre></td></tr></table></figure><p><code>*</code>处的 <code>walk()</code>方法是读取了原型中的 <code>walk()</code>方法，之后实例 <code>rabbit</code> 写入了一个新的 <code>walk()</code>方法，因而在 <code>**</code> 处不在调用原型链的 <code>walk()</code>方法</p><h3 id="原型作用于访问器属性"><a href="#原型作用于访问器属性" class="headerlink" title="原型作用于访问器属性"></a>原型作用于访问器属性</h3><p>如果一个原型对象的属性有 <code>getter</code>/<code>setter</code>， 那么我们会在原型中查找并操作它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  surname: <span class="string">"Smith"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> fullName(value) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.name, <span class="keyword">this</span>.surname] = value.split(<span class="string">" "</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  isAdmin: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(admin.fullName); <span class="comment">// John Smith (*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setter triggers!</span></span><br><span class="line">admin.fullName = <span class="string">"Alice Cooper"</span>; <span class="comment">// (**)</span></span><br></pre></td></tr></table></figure><p><code>*</code> 处的属性 <code>admin.fullName</code> 在原型对象 <code>user</code> 中有一个 <code>getter</code>,所以此处调用了该 <code>getter</code>， <code>**</code> 处的属性也有一个 <code>setter</code> 在原型对象中，也因此调用了该 <code>setter</code></p><p>上面例子中的 <code>this</code> 的值或许会有一些疑问，但是，<strong>无论在哪里找到方法：在对象或者原型中。调用方法时，this 始终是点之前的对象。</strong>，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animal has methods</span></span><br><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  walk() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isSleeping) &#123;</span><br><span class="line">      alert(<span class="string">`I walk`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  sleep() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isSleeping = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  name: <span class="string">"White Rabbit"</span>,</span><br><span class="line">  __proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// modifies rabbit.isSleeping</span></span><br><span class="line">rabbit.sleep();</span><br><span class="line"></span><br><span class="line">alert(rabbit.isSleeping); <span class="comment">// true</span></span><br><span class="line">alert(animal.isSleeping); <span class="comment">// undefined (no such property in the prototype)</span></span><br></pre></td></tr></table></figure><p>如果我们从 <code>animal</code> 继承像 <code>bird</code>、<code>snake</code> 等其他对象，他们也将获取 <code>animal</code> 的方法。但是每个方法 <code>this</code> 都是相应的对象，而不是 <code>animal</code>，在调用时（在点之前）确定。因此当我们将数据写入 <code>this</code> 时，它会被存储进这些对象中。</p><p>因此，方法是共享的，但对象状态不是。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>JavaScript 中，所有的对象都有一个隐藏的 [[Prototype]] 属性，它可以是另一个对象或者 null。</li><li>我们可以使用 obj.<strong>proto</strong> 进行访问（还有其他方法，但很快就会被覆盖）。</li><li>[[Prototype]] 引用的对象称为“原型”。</li><li>如果我们想要读取 obj 属性或者调用一个方法，而且它不存在，那么 JavaScript 就会尝试在原型中查找它。写/删除直接在对象上进行操作，它们不使用原型（除非属性实际上是一个 setter）。</li><li>如果我们调用 obj.method()，而且 method 是从原型中获取的，this 仍然会引用 obj。因此方法重视与当前对象一起工作，即使它们是继承的。</li></ul><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>每个函数都有 <code>&quot;prototype&quot;</code> 属性，即使我们不设置它。</p><p>默认的 <code>&quot;prototype&quot;</code> 是一个只有属性 constructor 的对象，它指向函数本身。</p><p>当用 <code>new Fn()</code> 创建一个新对象时，该新对象的 <code>[[Prototype]]</code> 被设置为 <code>Fn.prototype</code>。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>Fn.prototype</code> 属性与 <code>[[Prototype]]</code> 不同。<code>Fn.prototype</code> 唯一的作用是：当 <code>new Fn()</code> 被调用时，它设置新对象的 <code>[[Prototype]]</code>。</p></li><li><p><code>Fn.prototype</code> 的值应该是一个对象或 <code>null</code>：其他值将不起作用。</p></li><li><p><code>&quot;prototype&quot;</code> 属性仅在设置为构造函数时具有这种特殊效果，并且用 <code>new</code> 调用。</p></li><li><p>在常规对象上，<code>prototype</code> 没什么特别的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">name: <span class="string">"John"</span>,</span><br><span class="line">prototype: <span class="string">"Bla-bla"</span> <span class="comment">// no magic at all</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>默认情况下，所有函数都有 <code>Fn.prototype = {constructor：Fn}</code>，所以我们可以通过访问它的 <code>&quot;constructor&quot;</code> 属性来获得对象的构造函数。</p></li></ul><p><strong>注意，只有函数对象才拥有 <code>prototype</code> 属性能够直接操作 <code>[[Prototype]]</code>，其他实例对象要操作 <code>[[Prototype]]</code> 对象只能通过 <code>__proto__</code> 方法或者 <code>Object.getPrototypeOf</code>/<code>Object.setPrototypeOf</code>等其他方法。</strong></p><h2 id="原生的原型"><a href="#原生的原型" class="headerlink" title="原生的原型"></a>原生的原型</h2><p>所有的内置对象都遵循一样的模式：</p><ul><li>方法都存储在原型对象上（<code>Array.prototype</code>、<code>Object.prototype</code>、<code>Date.prototype</code> 等）。</li><li>对象本身只存储数据（数组元素、对象属性、日期）。</li><li>基本数据类型同样在包装对象的原型上存储方法：<code>Number.prototype</code>、<code>String.prototype</code> 和 <code>Boolean.prototype</code>。只有 <code>undefined</code> 和 <code>null</code> 没有包装对象。</li><li>内置对象的原型可以被修改或者被新的方法填充。但是这样做是不被推荐的。只有当添加一个还没有被 <code>JavaScript</code> 引擎支持的新方法的时候才可能允许这样做。</li></ul><p>方法借用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从数组借用 join 方法并在 arguments 的上下文中调用</span></span><br><span class="line">  alert( [].join.call(<span class="built_in">arguments</span>, <span class="string">" - "</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showArgs(<span class="string">"John"</span>, <span class="string">"Pete"</span>, <span class="string">"Alice"</span>); <span class="comment">// John - Pete - Alice</span></span><br></pre></td></tr></table></figure><p>因为 <code>join</code> 方法在 <code>Array.prototype</code> 对象上，我们可以直接调用它并且重写上面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">" - "</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是更有效率的，因为它避免了一个额外数组对象 <code>[]</code> 的创建。另一方面，这样做，需要更长的时间来编写。</p><h2 id="关于原型的方法"><a href="#关于原型的方法" class="headerlink" title="关于原型的方法"></a>关于原型的方法</h2><p>上文提到的 <code>__proto__</code> 方法已经开始被弃用，推荐使用以下方法操作 <code>[[Prototype]]</code>:</p><ul><li><p><code>Object.create(proto[, descriptors])</code> —— 利用 <code>proto</code> 作为 <code>[[Prototype]]</code> 和可选的属性描述来创建一个空对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  eats: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二个参数传递的是 属性描述符 对象，其他 flag 默认为 false</span></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="built_in">Object</span>.create(animal, &#123;</span><br><span class="line">  jumps: &#123;</span><br><span class="line">    value: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(rabbit.jumps); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们可以利用 <code>Object.create</code> 来实现比 <code>for..in</code> 循环赋值属性方式更强大的对象复制功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj 对象的浅复制</span></span><br><span class="line"><span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure><p>这样实现了 <code>obj</code> 的完整复制，包含了所有属性：可枚举的和不可枚举的，数据属性以及 <code>seeters/getters</code> —— 所有属性，以及正确的 <code>[[Prototype]]</code>。</p></li><li><p><code>Object.getPrototypeOf(obj)</code> —— 返回 <code>obj</code> 对象的 <code>[[Prototype]]</code>。</p></li><li><p><code>Object.setPrototypeOf(obj, proto)</code> —— 将 <code>obj</code> 对象的 <code>[[Prototype]]</code> 设置为 <code>proto</code>。</p></li></ul><p>从技术上来讲，我们可以在任何时候 <code>get/set</code> <code>[[Prototype]]</code>。但是通常我们只在创建对象的时候设置它一次，自那之后不再修改。对此 <code>JavaScript</code> 引擎做了高度的优化。运行中利用 <code>Object.setPrototypeOf</code> 或者 <code>obj.__proto__=</code> 来更改 <code>prototype</code> 是一个非常缓慢的操作。但是，这是可行的。</p><p><strong>注意 <code>__proto__</code>根本不是一个对象的属性，只是 Object.prototype 的访问属性，如果 <code>obj.__proto__</code> 被读取或者赋值，那么对应的 <code>getter/setter</code> 从它的原型被调用，它会获取/设置 <code>[[Prototype]]</code>。</strong></p><h3 id="极简对象"><a href="#极简对象" class="headerlink" title="极简对象"></a><code>极简</code>对象</h3><p>我们可以用 <code>Object.create(null)</code> 创建一个空对象，这个对象没有原型（<code>[[Prototype]]</code> 是 <code>null</code>）</p><p>它没有继承 <code>__proto__</code> 的 <code>getter/setter</code> 方法。现在它像正常的数据属性一样运行.我们可以叫这样的对象「极简」或者「纯字典对象」，因此它们甚至比通常的简单对象 <code>{...}</code> 还要简单。</p><p>这样的对象有一个缺点是缺少内置的对象方法，比如说 <code>toString</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">alert(obj); <span class="comment">// Error （没有 toString 方法）</span></span><br></pre></td></tr></table></figure><p>请注意，和对象关系最密切的方法是 <code>Object.something(...</code>)，比如 <code>Object.keys(obj)</code> —— 它们不在 <code>prototype</code> 中，因此在极简对象中它们还是可以继续使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chineseDictionary = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">chineseDictionary.hello = <span class="string">"ni hao"</span>;</span><br><span class="line">chineseDictionary.bye = <span class="string">"zai jian"</span>;</span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.keys(chineseDictionary)); <span class="comment">// hello,bye</span></span><br></pre></td></tr></table></figure><h3 id="获取对象所有属性"><a href="#获取对象所有属性" class="headerlink" title="获取对象所有属性"></a>获取对象所有属性</h3><p>获取一个对象的键/值有很多种方法。</p><p>我们已知的有：</p><p>-<code>Object.keys(obj)</code> / <code>Object.values(obj)</code> / <code>Object.entries(obj)</code> – 返回一个数组，包含所有可枚举字符串属性 <code>名称/值/键值对</code>。这些方法只会列出可枚举属性，而且它们键名为字符串形式。</p><ul><li><code>Object.getOwnPropertySymbols(obj)</code> —— 返回包含所有 symbol 属性名称的数组。<br>如果我们想要非可枚举属性：</li><li><code>Object.getOwnPropertyNames(obj)</code> —— 返回包含所有字符串属性名的数组。<br>如果我们想要所有属性：</li><li><code>Reflect.ownKeys(obj)</code> —— 返回包含所有属性名称的数组。<br>这些方法和它们返回的属性有些不同，但它们都是对对象本身进行操作。<code>prototype</code> 的属性没有包含在内。</li></ul><p><code>for...in</code> 循环有所不同：它会对继承得来的属性也进行循环。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  eats: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  jumps: <span class="literal">true</span>,</span><br><span class="line">  __proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只有自身的键</span></span><br><span class="line">alert(<span class="built_in">Object</span>.keys(rabbit)); <span class="comment">// jumps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里包含了继承得来的键</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> rabbit) alert(prop); <span class="comment">// jumps，然后 eats</span></span><br></pre></td></tr></table></figure><p>如果我们想要区分继承属性，有一个内置方法 <code>obj.hasOwnProperty(key)</code>：如果 <code>obj</code> 有名为 <code>key</code> 的自身属性（而非继承），返回值为 <code>true</code>。</p><p>因此我们可以找出继承属性（或者对它们进行一些操作）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  eats: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  jumps: <span class="literal">true</span>,</span><br><span class="line">  __proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> rabbit) &#123;</span><br><span class="line">  <span class="keyword">let</span> isOwn = rabbit.hasOwnProperty(prop);</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;prop&#125;</span>: <span class="subst">$&#123;isOwn&#125;</span>`</span>); <span class="comment">// jumps:true, then eats:false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中我们有以下继承链：<code>rabbit</code>，然后 <code>animal</code>，然后 <code>Object.prototype</code> （因为 <code>animal</code> 是个字面量对象 <code>{...}</code>，因此默认是这样），然后最终到达 <code>null</code></p><p>请注意：这里有一个有趣的现象。<code>rabbit.hasOwnProperty</code> 这个方法来自哪里？观察继承链我们发现这个方法由 <code>Object.prototype.hasOwnProperty</code> 提供。换句话说，它是继承得来的。</p><p>…但是如果说 <code>for...in</code> 列出了所有继承属性，为什么 <code>hasOwnProperty</code> 这个方法没有出现在其中？答案很简单：它是不可枚举的。就像所有其他在 Object.prototype 中的属性一样。这是为什么它们没有被列出的原因。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><code>Object.create(proto[, descriptors])</code> —— 利用给定的 <code>proto</code> 作为 <code>[[Prototype]]</code> 来创建一个空对象。</li><li><code>Object.getPrototypeOf(obj)</code> —— 返回 <code>obj</code> 的 [[Prototype]]（和 <code>__proto__ getter</code> 相同）。</li><li><code>Object.setPrototypeOf(obj, proto)</code> —— 将 <code>obj</code> 的 [[Prototype]] 设置为 <code>proto</code>（和 <code>__proto__ setter</code> 相同）。</li><li><code>Object.keys(obj) / Object.values(obj) / Object.entries(obj)</code> —— 返回包含自身属性的名称/值/键值对的数组。</li><li><code>Object.getOwnPropertySymbols(obj)</code> —— 返回包含所有自身 <code>symbol</code> 属性名称的数组。</li><li><code>Object.getOwnPropertyNames(obj)</code> —— 返回包含所有自身字符串属性名称的数组。</li><li><code>Reflect.ownKeys(obj)</code> —— 返回包含所有自身属性名称的数组。</li><li><code>obj.hasOwnProperty(key)</code>：如果 <code>obj</code> 拥有名为 <code>key</code> 的自身属性（非继承得来），返回 <code>true。</code></li><li>同时我们还明确了 <code>__proto__</code> 是 <code>[[Prototype]]</code> 的 <code>getter/setter</code>，位置在 <code>Object.prototype</code>，和其他方法相同。</li><li>我们可以不借助 <code>prototype</code> 创建一个对象，那就是 <code>Object.create(null)</code>。这些对象被用作是「纯字典」，对于它们而言 <code>&quot;__proto__&quot;</code>作为键没有问题。</li><li>所有返回对象属性的方法（如 <code>Object.keys</code> 以及其他）—— 都返回「自身」属性。如果我们想继承它们，我们可以使用 <code>for...in</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原型与继承&quot;&gt;&lt;a href=&quot;#原型与继承&quot; class=&quot;headerlink&quot; title=&quot;原型与继承&quot;&gt;&lt;/a&gt;原型与继承&lt;/h1&gt;&lt;h2 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;JavaScript&lt;/code&gt; 中，每个对象都有一个特殊的隐藏属性 &lt;code&gt;[[Prototype]]&lt;/code&gt; ，该属性的值只能是 null 或者其他对象的引用(叫做 原型对象)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[[Prototype]]&lt;/code&gt; 有一个“神奇”的意义。当我们想要从 object 中读取一个属性时，它就丢失了。JavaScript 会自动从原型中获取它。在编程中，这样的事情称为“原型继承”。&lt;/p&gt;
&lt;h3 id=&quot;原型对象-Prototype&quot;&gt;&lt;a href=&quot;#原型对象-Prototype&quot; class=&quot;headerlink&quot; title=&quot;原型对象 [[Prototype]]&quot;&gt;&lt;/a&gt;原型对象 &lt;code&gt;[[Prototype]]&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;原型对象 &lt;code&gt;[[Prototype]]&lt;/code&gt; 是一个内部，而且隐藏的对象，我们可以用以下及中方法来设置它：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;__proto__&lt;/code&gt; 方法&lt;br&gt;&lt;code&gt;__proto__&lt;/code&gt; 是历史遗留的 &lt;code&gt;[[Prototype]]&lt;/code&gt;对象的 &lt;code&gt;getter&lt;/code&gt;/&lt;code&gt;setter&lt;/code&gt;，注意，这只是一个 &lt;code&gt;getter&lt;/code&gt;/&lt;code&gt;setter&lt;/code&gt;。(不推荐使用在客户端，但可以用于服务器端)&lt;/p&gt;
&lt;p&gt;我们可以手动通过 &lt;code&gt;__proto__&lt;/code&gt; 设置对象的原型，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; animal = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;eats: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;walk() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;string&quot;&gt;&quot;Animal walk&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; rabbit = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jumps: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__proto__: animal &lt;span class=&quot;comment&quot;&gt;//*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; longEar = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;earLength: &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__proto__: rabbit &lt;span class=&quot;comment&quot;&gt;//*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// walk is taken from the prototype chain&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;longEar.walk(); &lt;span class=&quot;comment&quot;&gt;// Animal walk&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(longEar.jumps); &lt;span class=&quot;comment&quot;&gt;// true (from rabbit)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注意，对于 &lt;code&gt;__proto__&lt;/code&gt; 有两个限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The references can’t go in circles. JavaScript will throw an error if we try to assign &lt;code&gt;__proto__&lt;/code&gt; in a circle.&lt;/li&gt;
&lt;li&gt;The value of &lt;code&gt;__proto__&lt;/code&gt; can be either an object or null, other types (like primitives) are ignored.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;Object.getPrototypeOf&lt;/code&gt;/&lt;code&gt;Object.setPrototypeOf&lt;/code&gt;方法(推荐使用，详看下方 关于原型的方法e)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Morden JavaScript Tutorial" scheme="https://kerbalhao.github.io/categories/Morden-JavaScript-Tutorial/"/>
    
    
      <category term="JS 原型" scheme="https://kerbalhao.github.io/tags/JS-%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Js现代教程笔记 -- 对象属性</title>
    <link href="https://kerbalhao.github.io/posts/90bdcb8c/"/>
    <id>https://kerbalhao.github.io/posts/90bdcb8c/</id>
    <published>2019-04-23T10:36:09.000Z</published>
    <updated>2022-04-06T10:48:44.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h1><h2 id="1-对象属性标志和描述符"><a href="#1-对象属性标志和描述符" class="headerlink" title="1 对象属性标志和描述符"></a>1 对象属性标志和描述符</h2><h3 id="1-1-属性标志"><a href="#1-1-属性标志" class="headerlink" title="1.1 属性标志"></a>1.1 属性标志</h3><p>对象的属性除了值(value)以e外，还有通常情况下不可见的特殊属性：标志(flag)。标志的值都是布尔值</p><ul><li><code>writable：</code>为 <code>true</code> ,则该属性可被修改，否则为只读属性</li><li><code>enumerable</code>：为 <code>true</code>, 则该属性可被枚举。</li><li><code>configurable</code>： 为 <code>true</code>, 则该属性可被删除和修改。</li></ul><p>当我们为对象添加属性时，属性的标志默认为 <code>true</code>。</p><a id="more"></a><h4 id="1-1-1-writable-false-Read-only"><a href="#1-1-1-writable-false-Read-only" class="headerlink" title="1.1.1 writable: false //Read-only"></a>1.1.1 <code>writable: false //Read-only</code></h4><p>当一个属性的 <code>wrirable</code> 标志为 <code>false</code> 时, 无法改变该属性的值，除非使用 <code>defineProperty</code> <code>将writable</code> 标志改为 <code>true</code>,之后才能改变该属性的值</p><h4 id="1-1-2-enumerable-false-Non-enumerable"><a href="#1-1-2-enumerable-false-Non-enumerable" class="headerlink" title="1.1.2 enumerable: false //Non-enumerable"></a>1.1.2 <code>enumerable: false //Non-enumerable</code></h4><p>一般来说，<code>enumeable: false</code> 的属性不会出现在 <code>for-in</code> 循环中，也不会出现在 <code>Object.keys()</code> 的返回值中。</p><h4 id="1-1-3-configurable-false-Non-configurable"><a href="#1-1-3-configurable-false-Non-configurable" class="headerlink" title="1.1.3 configurable: false //Non-configurable"></a>1.1.3 <code>configurable: false //Non-configurable</code></h4><p>一个 <code>configurable: false</code> 的属性将无法被删除，也无法使用 <code>defineProperty</code> 改变其 <code>flag</code>。这意味着将 <code>configurable</code> 的值改为 <code>false</code> 后将无法重置，必须小心。</p><p><strong>注意，试图修改 <code>writable:false</code> 或者 <code>configurable:false</code> 的属性的操作只有在 <code>strict</code> 模式才会报错，在 <code>no-strict</code> 模式下，该操作无效，但错误将被忽略</strong></p><h4 id="1-1-4-读取属性标志的方法："><a href="#1-1-4-读取属性标志的方法：" class="headerlink" title="1.1.4 读取属性标志的方法："></a>1.1.4 读取属性标志的方法：</h4><p><code>Object.getOwnPropertyDescriptor(obj, propertyName)</code></p><p>该方法返回叫做 属性描述符 (<code>property descriptor</code>)对象，包含所有的 <code>flag</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(user, <span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">JSON</span>.stringify(descriptor, <span class="literal">null</span>, <span class="number">2</span> ) );</span><br><span class="line"><span class="comment">/* property descriptor:</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  "value": "John",</span></span><br><span class="line"><span class="comment">  "writable": true,</span></span><br><span class="line"><span class="comment">  "enumerable": true,</span></span><br><span class="line"><span class="comment">  "configurable": true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="1-1-5-修改属性标志的方法"><a href="#1-1-5-修改属性标志的方法" class="headerlink" title="1.1.5 修改属性标志的方法:"></a>1.1.5 修改属性标志的方法:</h4><p><code>Object.defineProperty(obj, propertyName, descriptor)</code></p><p>如果该属性存在，那么该方法会更新它的 <code>Flag</code>。否则，它会根据给定的值和 <code>flag</code> 来新建该属性，在这种情况下，如果有一个 <code>flag</code> 没有提供，那么它会默认该 <code>Flag</code> 为 <code>false</code>当我们使用 <code>描述器</code> 创建一个属性，它的标识默认是 <code>false</code> 。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">"name"</span>, &#123;</span><br><span class="line">  value: <span class="string">"John"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(user, <span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">JSON</span>.stringify(descriptor, <span class="literal">null</span>, <span class="number">2</span> ) );</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  "value": "John",</span></span><br><span class="line"><span class="comment">  "writable": false,</span></span><br><span class="line"><span class="comment">  "enumerable": false,</span></span><br><span class="line"><span class="comment">  "configurable": false</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>注意，使用其他方法创建的属性，其 flag 默认为 true,与使用 <code>defineProperty</code> 方法创建的属性的 flag 有很大不同</strong><br>另一种修改或定义属性的 <code>flag</code> 的方法： <code>Object.defineProperties(obj, {propertyName1:{flags}, propertyName2:{flag}, ...})</code><br>该方法也可以用来一次性修改多个属性的 flag,例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(user, &#123;</span><br><span class="line">  name: &#123; <span class="attr">value</span>: <span class="string">"John"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  surname: &#123; <span class="attr">value</span>: <span class="string">"Smith"</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-1-6-Object-getOwnPropertyDescriptors-obj"><a href="#1-1-6-Object-getOwnPropertyDescriptors-obj" class="headerlink" title="1.1.6 Object.getOwnPropertyDescriptors(obj)"></a>1.1.6 <code>Object.getOwnPropertyDescriptors(obj)</code></h4><p>该方法可以一次性获得属性的所有描述符</p><p>该方法可以与 <code>Object.defineProperties</code>  方法来克隆一个对象<br><code>let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));</code></p><p>这种克隆方法与 <code>for..in</code> 克隆的区别在于：</p><ol><li><code>for...in</code> 方法并不复制 <code>flags</code></li><li><code>for...in</code> 方法会忽视掉 <code>symbolic</code> 属性，但 <code>Object.getOwnPropertyDescriptors</code> 会返回包括 <code>symbolic</code>属性在内的所有属性描述符对象</li></ol><h4 id="1-1-7-设定一个全局的封闭对象"><a href="#1-1-7-设定一个全局的封闭对象" class="headerlink" title="1.1.7 设定一个全局的封闭对象"></a>1.1.7 设定一个全局的封闭对象</h4><p>属性描述符可以在各个属性的级别上工作。</p><p>还有一些限制访问整个对象的方法：</p><p><code>Object.preventExtensions(obj)</code><br>禁止向对象添加属性。</p><p><code>Object.seal(obj)</code><br>禁止添加/删除属性，为所有现有的属性设置 configurable: false。</p><p><code>Object.freeze(obj)</code><br>禁止添加/删除/更改属性，为所有现有属性设置 configurable: false, writable: false。</p><p>还有对他们的测试：</p><p><code>Object.isExtensible(obj)</code><br>如果添加属性被禁止，则返回 false，否则返回 true。</p><p><code>Object.isSealed(obj)</code><br>如果禁止添加/删除属性，则返回 true，并且所有现有属性都具有 configurable: false。</p><p><code>Object.isFrozen(obj)</code><br>如果禁止添加/删除/更改属性，并且所有当前属性都是 configurable: false, writable: false，则返回 true。</p><h3 id="1-2-属性的访问器属性-getter-和-setter"><a href="#1-2-属性的访问器属性-getter-和-setter" class="headerlink" title="1.2 属性的访问器属性 getter 和 setter"></a>1.2 属性的访问器属性 <code>getter</code> 和 <code>setter</code></h3><p>Js 有两种属性：</p><ul><li>数据属性</li><li>访问器属性：它们本质上是获取和设置值的函数，但从外部代码来看像常规属性。</li></ul><p>访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 get 和 set 表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> propName() &#123;</span><br><span class="line">    <span class="comment">// getter, the code executed on getting obj.propName</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> propName(value) &#123;</span><br><span class="line">    <span class="comment">// setter, the code executed on setting obj.propName = value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当读取 <code>obj.propName</code> 时，使用 <code>getter</code>，当设置值时，使用 <code>setter</code>。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  surname: <span class="string">"Smith"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> fullName(value) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.name, <span class="keyword">this</span>.surname] = value.split(<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get fullName</span></span><br><span class="line">alert(user.fullName) <span class="comment">// John Smith</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set fullName is executed with the given value.</span></span><br><span class="line">user.fullName = <span class="string">"Alice Cooper"</span>;</span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// Alice</span></span><br><span class="line">alert(user.surname); <span class="comment">// Cooper</span></span><br></pre></td></tr></table></figure><p>现在我们有一个“虚拟”属性。它是可读写的，但实际上并不存在。</p><p>从外表看，访问器属性看起来像一个普通的属性。这是访问器属性的设计思想。我们不以函数的方式调用 <code>user.fullName</code>，我们通常读取它：<code>getter</code> 在幕后运行。</p><p><strong>访问器属性只能访问 <code>get/set</code>。属性可以是“数据属性”或“访问器属性”，但不能同时属于两者。一旦使用 <code>get prop()</code> 或 <code>set prop()</code> 定义了一个属性，它就是一个访问器属性。所以必须有一个 <code>getter</code>来读取它，如果我们对它赋值，它必须是一个 <code>setter</code>。有时候只有一个 <code>setter</code> 或者只有一个 <code>getter</code> 是正常的。但在这种情况下，该属性将不可读或可写</strong></p><h4 id="1-2-1-访问器描述符"><a href="#1-2-1-访问器描述符" class="headerlink" title="1.2.1 访问器描述符"></a>1.2.1 访问器描述符</h4><p>访问器属性的描述符与数据属性相比是不同的。</p><p>对于访问器属性，没有 <code>value</code> 和 <code>writable</code>，但是有 <code>get</code> 和 <code>set</code> 函数。</p><p>所以访问器描述符可能有：</p><ul><li><code>get</code> —— 一个没有参数的函数，在读取属性时工作，</li><li><code>set</code> —— 带有一个参数的函数，当属性被设置时调用，</li><li><code>enumerable</code> —— 与数据属性相同，</li><li><code>configurable</code> —— 与数据属性相同。</li></ul><p>例如，要使用 <code>defineProperty</code> 创建 <code>fullName</code> 的访问器，我们可以使用 <code>get</code> 和 <code>set</code> 来传递描述符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  surname: <span class="string">"Smith"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">'fullName'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(value) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.name, <span class="keyword">this</span>.surname] = value.split(<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(user.fullName); <span class="comment">// John Smith</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> user) alert(key); <span class="comment">// name, surname</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对象属性&quot;&gt;&lt;a href=&quot;#对象属性&quot; class=&quot;headerlink&quot; title=&quot;对象属性&quot;&gt;&lt;/a&gt;对象属性&lt;/h1&gt;&lt;h2 id=&quot;1-对象属性标志和描述符&quot;&gt;&lt;a href=&quot;#1-对象属性标志和描述符&quot; class=&quot;headerlink&quot; title=&quot;1 对象属性标志和描述符&quot;&gt;&lt;/a&gt;1 对象属性标志和描述符&lt;/h2&gt;&lt;h3 id=&quot;1-1-属性标志&quot;&gt;&lt;a href=&quot;#1-1-属性标志&quot; class=&quot;headerlink&quot; title=&quot;1.1 属性标志&quot;&gt;&lt;/a&gt;1.1 属性标志&lt;/h3&gt;&lt;p&gt;对象的属性除了值(value)以e外，还有通常情况下不可见的特殊属性：标志(flag)。标志的值都是布尔值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;writable：&lt;/code&gt;为 &lt;code&gt;true&lt;/code&gt; ,则该属性可被修改，否则为只读属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enumerable&lt;/code&gt;：为 &lt;code&gt;true&lt;/code&gt;, 则该属性可被枚举。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;configurable&lt;/code&gt;： 为 &lt;code&gt;true&lt;/code&gt;, 则该属性可被删除和修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我们为对象添加属性时，属性的标志默认为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Morden JavaScript Tutorial" scheme="https://kerbalhao.github.io/categories/Morden-JavaScript-Tutorial/"/>
    
    
      <category term="JS 对象属性" scheme="https://kerbalhao.github.io/tags/JS-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
</feed>
