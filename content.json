{"pages":[{"title":"","text":"个人简介 博客信息 本站推荐索引 博客主题相关技术知识点 其他 计划 时间轴记录","link":"/about/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 var gitalk = new Gitalk({ clientID: 'a71d38c4a8dafab99dc9', clientSecret: '2ac14858f30545b5beea2e920b90d25dcbf1c78b', id: '666666', repo: 'issue_database', owner: 'kerbalhao', admin: \"kerbalhao\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/self-talking/index.html"}],"posts":[{"title":"Git 学习","text":"GITGIT指令git init:初始化仓库 git add &lt;fileName1&gt; [&lt;fileName2&gt;]... || . : 将文件添加到暂存区，可对特定文件操作，也可使用 . (点)符号对所有文件操作。注意对文件进行修改之后也需要调用 git commint -m &quot;&lt;comment&gt;&quot;: 提交文件，对文件进行改增删替之后都需要调用： git status: 查看仓库状态，可以用来查看工作区与暂存区的状态git diff: 比较的是工作区文件与暂存区文件的区别（上次git add 的内容）git diff --cached: 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别 git log--pretty=online： git log 查看提交历史，--pretty=online 用来缩减显示的历史git reflog: 查看命令历史git reset --hard HEAD^： HEAD指向的版本就是当前版本，HEAD^指向的是上一个版本，HEAD^^就是上上个版本。因此，Git允许我们在版本的历史之间穿梭，使用命令 git reset --hard commit_id git commit 相关：git commit 不输入 -m 以及后面的内容会进入vim模式 vi &amp; vim 有两种工作模式： 命令模式：接受、执行 vi &amp; vim 操作命令的模式，打开文件后的默认模式； 编辑模式：对打开的文件内容进行 增、删、改 操作的模式； 在编辑模式下按下 ESC 键，回退到命令模式。 创建、打开文件：$ vi [filename] 使用 vi 加 文件路径（或文件名）的模式打开文件，如果文件存在则打开现有文件，如果文件不存在则新建文件，并在终端最下面一行显示打开的是一个新文件。 键盘输入字母 “i”或“Insert”键进入最常用的插入编辑模式。 保存文件： 在插入编辑模式下编辑文件。 按下 “ESC” 键，退出编辑模式，切换到命令模式。 在命令模式下键入”ZZ”或者”:wq”保存修改并且退出 vi 。 如果只想保存文件，则键入”:w”，回车后底行会提示写入操作结果，并保持停留在命令模式。 放弃所有文件修改： 放弃所有文件修改：按下 “ESC” 键进入命令模式，键入 “:q!” 回车后放弃修改并退出vi。 放弃所有文件修改，但不退出 vi ，即回退到文件打开后最后一次保存操作的状态，继续进行文件操作：按下 “ESC” 键进入命令模式，键入 “:e!” ，回车后回到命令模式。 版本回退相关场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- &lt;file&gt;。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 命令 git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 分支相关Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt;切换分支：git checkout ``` 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt;","link":"/posts/638fbc0c/"},{"title":"Bootstrap 基本学习","text":"Bootstrap基础响应式设计(Responsive Design)使元素带有’嵌入’的效果：增加 class='well' 图片响应移动设备的设计：添加 class='img-responsive' 文字居中：给元素添加 class=‘text-center’‘text-primary‘预定颜色，文字变蓝‘text-danger‘，预定颜色之一(红色) 在 &lt;input&gt;&lt;textarea&gt;和 &lt;select&gt;等文本输入区域添加 class='form-control'会使文本区域拓展到整个水平线(非 block元素) bootstrap自建的 button：给 button添加 class='btn btn-default'(2个 class)：class还可以添加 btn-block(用于将 button变为 block元素，将占据所在行，在 button之后的内容都将被挤到下一行)btn-default：可以换成 btn-primary,为 bootstrap预定的颜色之一(深蓝)； btn-info也是预定颜色之一(浅蓝)；btn-danger，预定颜色之一(红色) 可以添加 Font Awesome (图标字体库和 CSS框架) 的图标：在 html开头加上 CDN:&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css&quot; integrity=&quot;sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+&quot; crossorigin=&quot;anonymous&quot;&gt;在需要图标的元素中，添加 &lt;i class=&quot;fa fa-paper-plane&quot;&gt;&lt;/i&gt;,&lt;i&gt;元素可以换成 &lt;span&gt;, .fa类是使用图标的必要类，.fa-\\*-\\*是选择图标的类 Bootstrap 网格类Bootstrap 4 网格系统有以下 5 个类: .col-* 针对所有设备 .col-xs-* 针对手机-屏幕宽度小于 576px(extra small) .col-sm-* 平板 - 屏幕宽度等于或大于 576px (samll m) .col-md-* 桌面显示器 - 屏幕宽度等于或大于 768px) (medium desk) .col-lg-* 大桌面显示器 - 屏幕宽度等于或大于 992px) {large} .col-xl-* 超大桌面显示器 - 屏幕宽度等于或大于 1200px) (extra large)(*表示一个整数，代表占得宽度，一行宽度最大为12) Bootstrap4 网格系统规则: 网格每一行需要放在设置了 .container (固定宽度) 或 .container-fluid (全屏宽度) 类的容器中，这样就可以自动设置一些外边距与内边距。 使用行来创建水平的列组。 内容需要放置在列中，并且只有列可以是行的直接子节点。 预定义的类如 .row 和 .col-sm-4 可用于快速制作网格布局。代码： 1234567891011&lt;div class='row'&gt; &lt;div class='col-xs-4'&gt; &lt;button class=\"btn btn-block btn-primary\"&gt;Like&lt;/button&gt; &lt;/div&gt; &lt;div class='col-xs-4'&gt; &lt;button class=\"btn btn-block btn-info\"&gt;Info&lt;/button&gt; &lt;/div&gt; &lt;div class='col-xs-4'&gt; &lt;button class=\"btn btn-block btn-danger\"&gt;Delete&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 列通过填充创建列内容之间的间隙。 这个间隙是通过 .rows 类上的负边距设置第一行和最后一列的偏移。 网格列是通过跨越指定的 12 个可用列来创建。 例如，设置三个相等的列，需要使用用三个 .col-sm-4 来设置。 Bootstrap 3 和 Bootstrap 4 最大的区别在于 Bootstrap 4 现在使用 flexbox（弹性盒子） 而不是浮动。 Flexbox 的一大优势是，没有指定宽度的网格列将自动设置为等宽与等高列 。 Css Animated库.animated(实现必须的 Class).bounce.shake.fadeOut.hinge 标题标签与标题类标签：&lt;h1&gt;标签与 .h1 类 ———— 标题&lt;small&gt;标签或 .small 类 ———-比标题小一个字号，可作为副标题&lt;mark&gt;标签，高亮文本类：.display-1,.display-2,.display-3,.display-4. 页面主体默认:font-size: 14px， line-height: 1.428&lt;p&gt;元素有10px的底部外边距.lead 类用于突出显示段落 内联文本元素:&lt;market&gt;元素 —–高亮文本&lt;del&gt;元素 —–删除线文本&lt;s&gt;元素 —–无用文本，基本同上&lt;ins&gt;标签 —— 额外插入的文本，带下划线&lt;u&gt;标签 —- 下划线文本&lt;strong&gt;标签 —- 加粗&lt;em&gt;标签 —– 斜体 对齐类与大小写改变类:.text-left.text-center.text-right.text-justified.text-lowercase.text-uppercase.text-capitalize 缩略语为缩略语 &lt;abbr&gt;标签的 title属性赋值,其 title值即为缩略语基本缩略语: &lt;abbr title=&quot;attribute&quot;&gt;attr&lt;/abbr&gt;为缩略语添加 .initialism 类，可以让 font-size 变得稍微小些:&lt;abbr title=&quot;HyperText Markup Language&quot; class=&quot;initialism&quot;&gt;HTML&lt;/abbr&gt; 引用默认引用:使用 &lt;blockquote&gt;标签标识引用。多用引用样式: 在 &lt;blockquote&gt;内部添加 &lt;footer&gt;用于表明引用来源,来源名可包裹进 &lt;cite&gt;标签中。此外,可以使用 .blockquote-reverse类呈现内容右对齐。 列表无样式列表: 使用 .list-unstyled 类 移除列表默认样式,需要对所有嵌套列表使用同行列表: 使用 .list-inline 类 带有描述的短语列表:1234&lt;dl&gt; //discribe list &lt;dt&gt;...&lt;/dt&gt; //discribe title &lt;dd&gt;...&lt;/dd&gt; //discribe document&lt;/dl&gt; 代码:使用 &lt;code&gt;标签标识基本的代码使用 &lt;kbd&gt;标签标记用户通过键盘输入的内容使用 &lt;pre&gt;标签标识代码块,使用 .pre-scrollable类,设置 max-height为350px,并在垂直方向展示滚动条使用 &lt;var&gt;标签标记变量使用 &lt;samp&gt;标签标记程序输出的内容 表格基本:为 &lt;table&gt;标签添加 .table类,为其赋予基本的样式条纹状表格：使用 .table-striped类 给 &lt;tbody&gt;之内的每一行增加斑马条纹样式带边框的表格：使用 .table-bordered类 为表格和其中的每个单元格增加边框鼠标悬停：使用 .table-hover 类，可以让 &lt;tbody&gt;中的每一行对数表悬停状态做出相应紧缩表格： 使用 .table-condensed 类，使表格更加紧凑，单元格中的 padding 会减半 状态的类：为行或单元格设置颜色 .active 鼠标悬停在行或单元格上时所设置的颜色 .success 标识成功或积极的动作 .info 标识普通的提示信息或动作 .warning 标识警告或需要用户注意 .danger 表示危险或潜在的带来负面影响的动作 响应式表格： 将 &lt;table&gt;或者 .table 元素包裹在有 .table-responsive类的元素中 表单基本样式： .form-control类的 &lt;input&gt; &lt;textarea&gt; &lt;select&gt;元素。&lt;label&gt;元素和之前的控件包裹在 .form-group中可以获得最好的排列 不要将表单组直接和输入框组混合使用。建议将输入框组嵌套到表单组中使用。内联表单：为 &lt;form&gt;元素添加 .form-inline 类可使其内容表现为 inline-block级别的控件只有正确设置了 type 属性的输入控件才能被赋予正确的样式。 .form-horizontal 改变了 .form-group的行为，表现为栅格系统中的 row,无需再额外添加 .row 多选和单选框类 .radio, .radio-inline, .checkbox, .checkbox-inline如果需要在表单中将一行纯文本和 label 元素放置于同一行，为 &lt;p&gt; 元素添加 .form-control-static 类即可。 为输入框设置 disable和 readonly属性可以设置其禁用或者只读 .help-block，为输入框提供输入指示 验证的类：.has-success, .has-warning, .has-error类 添加额外的图标可以针对校验状态，为输入框添加额外的图标，设置相应的 .has-feedback类 并添加正确的图标即可feedback icon只能使用在文本输入框 &lt;input class='form-control'&gt;元素上 可以使用 .sr-only类来隐藏 label标签（而不是使用其它标签选项，如 aria-label 属性）， 一旦它被添加，Bootstrap 会自动调整图标的位置。 控件尺寸通过 .input-lg 类似的类可以为控件设置高度， 通过 .col-lg-* 类似的类可以为空间设置宽度 高度尺寸.input-lg, .input-sm类 水平排列的表单组的尺寸.form-group=lg 或 .form-group-sm 类，为 .form-horizontal 包裹的 label元素和表单控件快速设置尺寸 按钮可作为按钮时用的标签或元素为 &lt;a&gt; &lt;button&gt; &lt;input&gt; 元素添加按钮类(btn class)即可使用 bootstrap 提供的样式 尽量使用 &lt;buttion&gt;元素 预定义样式.btn-default, .btn-success, .btn-primary, .btn-info, .btn-danger, .btn-link 按钮设置边框为按钮添加以下类设置边框： 12345678&lt;button type=\"button\" class=\"btn btn-outline-primary\"&gt;主要按钮&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-outline-secondary\"&gt;次要按钮&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-outline-success\"&gt;成功&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-outline-info\"&gt;信息&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-outline-warning\"&gt;警告&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-outline-danger\"&gt;危险&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-outline-dark\"&gt;黑色&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-outline-light text-dark\"&gt;浅色&lt;/button&gt; 尺寸.btn-lg, .btn-sm, -btn-xs, .btn-block 激活/禁用状态直接添加 .active 类，实现激活状态禁用状态：button元素： 添加 disabled属性， 12&lt;button type=\"button\" class=\"btn btn-primary active\"&gt;点击后的按钮&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-primary\" disabled&gt;禁止点击的按钮&lt;/button&gt; 按钮组可以在 &lt;div&gt;元素上添加 .btn-group类来创建按钮组，将按钮放在同一行上，可以使用 .btn-group-lg|sm 类来设置按钮组的大小。用法： 12345&lt;div class=\"btn-group btn-group-lg\"&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;Apple&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;Samsung&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;Sony&lt;/button&gt;&lt;/div&gt; 使用 .btn-group-vertical类创建垂直的按钮组 可以在按钮组内设置下拉菜单（内嵌按钮组及下拉菜单）： 12345678910111213&lt;div class=\"btn-group\"&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;Apple&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;Samsung&lt;/button&gt; &lt;div class=\"btn-group\"&gt; &lt;button type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\"&gt; Sony &lt;/button&gt; &lt;div class=\"dropdown-menu\"&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Tablet&lt;/a&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Smartphone&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 徽章/标识主要用于突出显示新的或未读的项，如需使用，只需要将 .badge 类加上带有制定意义的颜色类添加到 &lt;span&gt;元素上即可，会长可以根据父元素的大小的变化而变化 徽章的颜色类型：.badge-primary.badge-secondary.badge-success.badge-danger.badge-warning.badge-info.badge-light.badge-dark 使用 .badge-pill 类来设置药丸形状徽章 实例： 123&lt;button type=\"button\" class=\"btn btn-primary\"&gt; Messages &lt;span class=\"badge badge-light\"&gt;4&lt;/span&gt;&lt;/button&gt; 进度条用于显示用户任务的完成过程创建步骤： 添加一个带有 .progress 类的 &lt;div&gt; 接着，在上面的 &lt;div&gt;内，添加一个带有 .progress-bar 类的空的 &lt;div&gt;。 添加一个带有百分比表示的宽度的 style属性，例如 style='width:70%'标识进度条在70%的位置 123&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar\" style=\"width:70%\"&gt;70%&lt;/div&gt;&lt;/div&gt; 进度条的高度可以通过设置 带有 .progress 类的 &lt;div&gt;的 style属性调节，如 123&lt;div class=\"progress\" style=\"height:20px;\"&gt; &lt;div class=\"progress-bar\" style=\"width:40%;\"&gt;&lt;/div&gt;&lt;/div&gt; ###关于进度条的类 颜色为进度条添加各背景颜色设置进度条颜色.bg-success类.bg-info.bg-warning.bg-danger 条纹.progress-bar-striped类 动画.progress-bar-animated 混合色彩进度条进度条可以设置多种颜色 1234567891011&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar bg-success\" style=\"width:40%\"&gt; Free Space &lt;/div&gt; &lt;div class=\"progress-bar bg-warning\" style=\"width:10%\"&gt; Warning &lt;/div&gt; &lt;div class=\"progress-bar bg-danger\" style=\"width:20%\"&gt; Danger &lt;/div&gt;&lt;/div&gt; 图片响应式图片为图片添加 .img-responsive 类 使图片支持响应式布局，实质时为图片设置了 max-width: 100%、 height: auto和 display: block 图片形状为 &lt;img&gt;元素添加不同的类，使图片呈现不同的形状：.img-rounded：圆角.img-circle：圆形.img-thumbnail：缩略图 辅助类情景 文本/背景颜色文本：.text-muted：柔和的文本.text-promary：重要的文本.text-success：执行成功的文本.text-info：代表一些提示信息的文本.text-warning：警告文本.text-danger：危险文本.text-secondary：副标题文本.text-dark:深灰色文本.text-light:浅灰色文本.text-white: 白色文本 背景：.bg-primary：重要的背景颜色.bg-success：执行成功背景颜色.bg-info：信息提示背景颜色.bg-warning：警告背景颜色.bg-danger：危险背景颜色 关闭按钮象征关闭的按钮，可以让模态框和警告框消失 123&lt;button type='buttom' class='close' aria-label='Close'&gt; &lt;span aria-hidden='true'&gt;$times;&lt;/span&gt;&lt;/button&gt; 三角符号使用三角符号可以指示某个元素具有下拉菜单的功能 1&lt;span class='caret'&gt;&lt;/span&gt; 浮动添加一个类，可以将任意元素向左或向右浮动.pull-left.pull-right 清除浮动为父元素添加 .clearfix 类清除浮动 内容块居中为任意元素设置 .center-block 类 显示或隐藏内容.show 类 改变 display属性.hidden 类.invisible 类 不改变 display属性，能够影响文档流排布 .sr-only 类 可以对屏幕阅读器以外的设备隐藏内容。 .sr-only 和 .sr-only-focusable 联合使用的话可以在元素有焦点的时候再次显示出来 图片替换使用 .text-hide 类或对应的 mixin可以用来将元素的文本内容替换为一张背景图 信息提示框信息提示框可以使用 .alert 类，后面加上 .alert-success, .alert-info, .alert-warning, .alert-danger, .alert-primary, .alert-secondary, .alert-light, .alert-dark类来实现 关闭提示框偶们可以在提示框中的 div中添加 .alert-dismissible类，然后再关闭按钮的链接上添加 class='close'和 data-dismiss='alert'类来设置提示框的关闭操作 提示框动画添加 .fake 和 .show类用于设置提示框在关闭时的淡出和淡入效果","link":"/posts/367713ea/"},{"title":"CSS相关与经典布局（双飞翼与圣杯）","text":"CSS相关与经典布局（双飞翼与圣杯）CSS去除 inline-block元素间间距的N种方法via：张鑫旭 去除inline-block元素间间距的N种方法 使用 font-size:0在外层标签使用 font-size: 0，取消空白符，在内层标签重新设置 font-size的值，使文本内容显示。 使用 letter-spacing去除空白符 123456.space { letter-spacing: -3px;}.space a { letter-spacing: 0;} 使用word-spacing 去除空白符 1234567.space { display: inline-table; //用于chrome word-spacing: -6px;}.space a { word-spacing: 0;} 解决 float导致的高度塌陷问题 通过添加额外的标签，利用 clear属性来清除浮动 12345&lt;div class=\"container\"&gt; &lt;div class=\"box_1 float\"&gt;box 1&lt;/div&gt; &lt;div class=\"box_2 float\"&gt;box 2&lt;/div&gt; &lt;div style=\"clear: both\"&gt;&lt;/div&gt;&lt;/div&gt; 使用 br标签 br自带 clear属性，clear属性有 left、right和 all三个属性值可选。 给父元素设置 overflow: hidden 经典布局两栏布局HTML部分： 1234&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt; CSS基础部分： 12345678910111213141516.container { font-size: 0; /*消除间距*/}.left, .right { display: inline-block;}.left { width: 100px; height: 150px; background-color: #FFB5BF;}.right { height: 150px; background-color: #94E8FF; width: calc(100% - 100px);} 使用浮动特性实现两栏布局： 如果设置 .left为 左浮动，.right会当 .left不存在，由于块级元素的默认宽度是父级元素的 100%，此时 .right的宽度就已经是 100% 了，无需再计算。别忘了设置 .right的 margin值来给 .left预留空间，让两者看起来是和谐相处的。这便是第一种方法，代码如下： 123456789.left { float: left;}.right { margin-left: 100px; /* 为 .left 留出空间 */}.container { overflow: hidden; /* 别忘了清除浮动 */} 浮动元素会脱离文档流，直到它碰到父元素的边框或另一浮动元素为止，因此，我们可以还设置 .left、``.right均左浮动，这时，它们便会紧贴着排列在一行。因为 .right是浮动的，所以需要计算宽度。这是第二种方法： 12345678910.left { float: left;}.right { float: left; width: calc(100% - 100px);}.container { overflow: hidden;} .left浮动的时候，.right会无视 .left，有没有不无视，留出位置的可能？有的，让 .right形成 BFC，.right就不会和 .left重合了。BFC不会忽视浮动元素，这也是它的特点之一： 123456789.left { float: left;}.right { overflow: auto; /* 形成 BFC */}.container { overflow: hidden;} 使用 absolute，设置 .left的 postion为 absolute，.left脱离了文档流，.right会无视 .left的存在。 123456789.container { position: relative;}.left { postion: absolute;}.right { margin-left: 100px;} 三栏布局圣杯布局HTML： 12345&lt;div class=\"container\"&gt; &lt;div class=\"center\"&gt;center&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt; css： 1234567891011121314151617181920212223242526272829303132body { min-width: 630px; /* 防止页面缩小导致流布局混乱，设置最小宽度*/}.container { overflow: hidden; /*清除浮动*/ padding-left: 100px; /*为.left 预留位置，并保持文本不被遮盖*/ padding-right: 200px; /*同上*/}.center { width: 100%; height: 150px; background-color: #94E8FF; float: left;}.left { width: 100px; height: 150px; background-color: #FFB5BF; float: left; margin-left: -100%; /* .left.center 的后面。这个时候，.left 要回到 .center 的最左边，便是要向左移动 .center 的宽度，即 100%*/ position: relative; left: -100px; /*将.left移动到预留的位置*/}.right { width: 200px; height: 150px; background-color: #8990D5; float: left; margin-left: -200px; /* 同.left*/ position: relative; right: -200px;} 双飞翼布局html： 1234567&lt;div class=\"container\"&gt; &lt;div class=\"center-container\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;left&lt;/div&gt;&lt;div&gt; css： 12345678910111213141516171819202122232425262728293031body { min-width: 630px;}.container { overflow: hidden;}.center-container { width: 100%; float: left;}.center-container .center { height: 150px; background-color: #94E8FF; margin-left: 100px; /* 新添加的属性 */ margin-right: 200px; /* 新添加的属性 */}.left { width: 100px; height: 150px; background-color: #FFB5BF; float: left; margin-left: -100%;}.right { width: 200px; height: 150px; background-color: #8990D5; float: left; margin-left: -200px;} 双飞翼布局与圣杯布局的差异及优劣。同样的问题，双飞翼布局通过多加一个 div并使用了 margin来实现，圣杯布局则是使用 padding、相对定位（relative）、设置偏移量（left、right）来实现，相对来说，双飞翼布局更容易理解。在圣杯布局中，无限缩小屏幕（假设没有设置 body的最小宽度），当 .main的宽度小于 .left时，会出现布局错乱。 flex布局flex容器属性 flex-direction: row|row-reverse|column|column-reverse (定义了主轴方向，即项目(flex-item)的排列方向) flex-wrap： nowrap|wrap|wrap-reverse (flex-wrap用来定义当一行放不下时，项目如何换行。) flex-flow:row no-wrap ( 是 flex-direction和 flex-wrap的简写，默认值是 row no-wrap。) justify-content:flex-start|flex-end|center|&lt;ruby&gt;``space-between&lt;rt&gt;两端对齐，项目间的距离相等&lt;/rt&gt;|space-around&lt;rt&gt;项目的两侧间隔相等&lt;/rt&gt;&lt;/ruby&gt; (定义了项目在主轴上的对齐方式) align-items:flex-start|flex-end|center|stretch|&lt;ruby&gt;``baseline&lt;rt&gt;项目第一行文字的基线对齐&lt;/rt&gt;&lt;/ruby&gt; (定义了项目在交叉轴上如何对齐。) align-content:flex-start | flex-end | center | space-between | space-around | stretch; (定义了多根轴线的对齐方式，若此时主轴在水平方向，交叉轴在垂直方向，align-content 就可以理解为多行在垂直方向的对齐方式。项目排列只有一行时，该属性不起作用。) Flex-item项目属性 order: ``&lt;integer&gt; (定义了项目的排列顺序，默认值为 0，数值越小，排列越靠前。) flex-grow: ``&lt;number&gt; (flex-grow定义了项目的放大比例，默认为 0，也就是即使存在剩余空间，也不会放大。如果所有项目的 flex-grow都为 1，则所有项目平分剩余空间；如果其中某个项目的 flex-grow为 2，其余项目的 flex-grow为 1，则前者占据的剩余空间比其他项目多一倍。) flex-shrink：定义了项目的缩小比例，默认为 1，即当空间不足时，项目会自动缩小。如果所有项目的 flex-shrink都为 1，当空间不足时，所有项目都将等比缩小；如果其中一个项目的 flex-shrink为 0，其余都为 1，当空间不足时，flex-shrink为 0 的不缩小。 flex-basic：&lt;length&gt; | auto（flex-basis定义了在分配多余的空间之前，项目占据的主轴空间，默认值为 auto，即项目原来的大小。浏览器会根据这个属性来计算主轴是否有多余的空间。 flex-basis的设置跟 width或 height一样，可以是像素，也可以是百分比。设置了 flex-basis之后，它的优先级比 width或 height高。） flex：auto | none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]}（ flex属性是 flex-grow、flex-shrink、flex-basis的缩写，默认值是 0 1 auto，后两个属性可选。该属性有两个快捷值：auto（1 1 auto）和 none（0 0 auto）。auto代表在需要的时候可以拉伸也可以收缩，none表示既不能拉伸也不能收缩。） align-self： auto | flex-start | flex-end | center | baseline | stretch;（align-self 用来定义单个项目与其他项目不一样的对齐方式，可以覆盖 align-items 属性。默认属性值是 auto，即继承父元素的 align-items属性值。当没有父元素时，它的表现等同于 stretch。align-self的六个可能属性值，除了 auto之外，其他的表现和 align-items一样。）","link":"/posts/5ca0b31/"},{"title":"Css部分介绍","text":"Csscss的box-sizing属性：语法 box-sizing: content-box|border-box|inherit; content-box: 这是由 CSS2.1 规定的宽度高度行为。 宽度和高度分别应用到元素的内容框。 在宽度和高度之外绘制元素的内边距和边框。 border-box : 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距(padding)和边框(border)都将在已设定的宽度和高度内进行绘制。(即边框和内边距都在原设定的宽度和高度内，不需再次计算) 通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度 inherit : 规定应从父元素继承 box-sizing 属性的值。 CSS的 calc()函数CSS函数 calc()可以用在任何一个需要 &lt;length&gt;、&lt;frequency&gt;,&lt;angle&gt;、&lt;time&gt;、&lt;number&gt;、或 &lt;integer&gt;的地方。有了 calc()，你就可以通过计算来决定一个 CSS属性的值了。该函数可以嵌套 语法12 /* property: calc(expression) */width: calc(100% - 80px); 参数为一个数学表达式，表达式的结果就是最终的值表达式中的操作数可以使用任意语法种类的长度。如果你愿意，你可以在一个表达式中混用多种不同的长度单位。在需要时，你还可以使用小括号来调整计算顺序。 注意 + 和 - 运算符的两边必须始终要有空白符。比如 calc(50% -8px) 会被解析成为一个无效的表达式：一个百分比后跟一个负数长度值。而 calc(8px + -50%) 会被解析成为一个长度后跟一个加号再跟一个负百分比。 *和 / 运算符不需要空白符，但考虑到统一性，仍然推荐加上空白符。 CSS 的 perspective属性perspective 属性指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。 三维元素在观察者后面的部分不会绘制出来，即z轴坐标值大于 perspective属性值的部分。 默认情况下，消失点位于元素的中心，但是可以通过设置 perspective-origin属性来改变其位置。 Css的 backface-visibility属性指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。语法：backface-visibility: visible|hidden CSS 的 transition属性transition的 CSS属性是一个简写属性，用于 transition-property，transition-duration，transition-timing-function 和 transition-delay。 Transitions可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。比如在不同的伪元素之间切换，像是 :hover，:active 或者通过 JavaScript实现的状态变化。 语法transition: property-name* | duration* | timing-function | dely transition属性可以被指定为一个或多个 CSS 属性的过渡效果，多个属性之间用逗号进行分隔。 每个单属性转换都描述了应该应用于单个属性的转换（或特殊值 all和 none）。 这包括： 零或一个值，表示转换应适用的属性。 这可能是以下任何一种： 关键字 none 关键字 all 一个 CSS属性名。 零或一个 &lt;single-transition-timing-function&gt; 值表示要使用的计时功能 零，一或两个 &lt;time&gt; 值。可以解析为时间的第一个值被分配给 transition-duration，并且可以解析为时间的第二个值被分配给 transition-delay。 CSS的 transform属性transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 语法transform: none|transform-functions;具体用法看：w3cschool 值 描述 none 定义不进行转换。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n) 为 3D 转换元素定义透视视图。 延申transform-style属性，使被转换的子元素保留其3D转换语法：transform-style: flat|preserve-3d; 值 描述 flat 子元素将不保留其3D位置 preserve-3d 子元素将保留其3D位置 @media可以在不改变 html内容情况下，根据媒体设备不同，浏览器窗口尺寸不同使用不同的 css样式。用法如下： 123456@media mediatype and|not|only (media feature) { CSS-Code;}element { max-width:100%; //定义该元素的最大宽度，%意味着与父级元素的比例} css视窗视窗，指的是浏览器可视区域的宽高单位：也是相对单位。它们的大小都是由视窗大小来决定的vw：视窗宽度的百分比vh：视窗高度的百分比vmin：当前较小的 vw和 vhvmax：当前较大的 vw和 vh display:flex容器与项目采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。设为 Flex 布局以后，子元素的 float、clear和 vertical-align属性将失效项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 flex的容器属性： flex-direction：属性决定主轴的方向（即项目的排列方向）(顺序：水平：左-&gt;右，垂直：上-&gt;下)。用法： 123container { flex-direction: row | row-reverse | column | column-reverse;} flex-wrap:默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。用法： 123container{ flex-wrap: nowrap | wrap | wrap-reverse;} flex-flow :flex-flow属性是 flex-direction属性和 flex-wrap属性的简写形式，默认值为 row nowrap。用法： 123container { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;} justify-content:justify-content属性定义了项目在主轴上的对齐方式。用法：flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。 123container { justify-content: flex-start | flex-end | center | space-between | space-around;} align-items ：align-items属性定义项目在交叉轴上如何对齐。用法：flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度 123container { align-items: flex-start | flex-end | center | baseline | stretch;} align-content :align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。用法：flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 123container { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} flex的项目属性 order：order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。用法： 123.item { order: &lt;integer&gt;;} flex-grow:flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。用法：如果所有项目的 flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 123.item { flex-grow: &lt;number&gt;; /* default 0 */} flex-shrink：flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。用法：如果所有项目的 flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} flex-basis：lex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。用法：它可以设为跟 width或 height属性一样的值（比如 350px），则项目将占据固定空间。 123.item { flex-basis: &lt;length&gt; | auto; /* default auto */} flex:flex属性是 flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。用法：该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 123.item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]} align-self：align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items属性。默认值为 auto，表示继承父元素的 align-items属性，如果没有父元素，则等同于 stretch。用法：该属性可能取6个值，除了 auto，其他都与 align-items属性完全一致。 123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 详见阮大阮一峰博客： http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html http://www.ruanyifeng.com/blog/2015/07/flex-examples.html display:grid 网格布局CSS Grid布局 （又名”网格”），是一个基于二维网格布局的系统，主要目的是改变我们基于网格设计的用户接口方式。 Grid术语Grid Container :设置了 display: gird 的元素。 这是所有 grid item 的直接父项。 在下面的例子中，.container 就是是 grid container。 12345&lt;div class=\"container\"&gt; &lt;div class=\"item item-1\"&gt;&lt;/div&gt; &lt;div class=\"item item-2\"&gt;&lt;/div&gt; &lt;div class=\"item item-3\"&gt;&lt;/div&gt;&lt;/div&gt; Grid Item:Grid 容器的孩子（直接子元素）。下面的 .item 元素就是 grid item，但 .sub-item不是。 1234567&lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt; &lt;p class=\"sub-item\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; Grid Line这个分界线组成网格结构。 它们既可以是垂直的（“column grid lines”），也可以是水平的（“row grid lines”），并位于行或列的任一侧。 Grid Track:两个相邻网格线之间的空间。 你可以把它们想象成网格的列或行。 下面是第二行和第三行网格线之间的网格轨道。 Grid Cell:两个相邻的行和两个相邻的列网格线之间的空间。它是网格的一个“单元”。 下面是行网格线1和2之间以及列网格线2和3的网格单元。 Grid Area四个网格线包围的总空间。 网格区域可以由任意数量的网格单元组成。 下面是行网格线1和3以及列网格线1和3之间的网格区域。 Grid属性Grid父容器属性 display： 将元素定义为 grid contaienr，并为其内容建立新的网格格式化上下文(grid formatting context)。值: grid – 生成一个块级(block-level)网格 inline-grid – 生成一个行级(inline-level)网格 subgrid – 如果你的 grid container 本身就是一个 grid item（即,嵌套网格），你可以使用这个属性来表示你想从它的父节点获取它的行/列的大小，而不是指定它自己的大小。 用法： 123.container { display: grid | inline-grid | subgrid;} 注意：column, float, clear, 以及 vertical-align 对一个 grid container 没有影响 grid-template-columns/grid-template-rows：使用以空格分隔的多个值来定义网格的列和行。这些值表示轨道大小(track size)，它们之间的空格代表表格线(grid line)。用法： 1234.container {grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...; grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;} (如果未显示的给网格线命名)，轨道值之间仅仅有空格时，网格线会被自动分配数字名称： 但你可以给网格线指定确切的命名。 注意中括号里的网格线命名语法，中括号内即为网格线名， 一个网格线可以有不止一个名字：12345 .container {grid-template-columns: [first 1st] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line]; } ![GridArea](https://cloud.hunger-valley.com/18-1-11/1314820.jpg) 如果你的定义中包含重复的部分，则可以使用repeat() 符号来简化写法以下两种写法等价：1234.container {grid-template-columns: repeat(3, 20px [col-start]) 5%;} .container {grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;} “fr”单位允许您将轨道大小设置为网格容器自由空间的一部分。自由空间是在排除所有不可伸缩的`grid item` 之后计算得到的。 例如，下面的代码会将每个 `grid item` 为 `grid container` 宽度的三分之一：1.container {grid-template-columns: 1fr 1fr 1fr;} grid-template-areas：通过引用 grid-area属性指定的网格区域的名称来定义网格模板。 重复网格区域的名称导致内容扩展到这些单元格。 点号表示一个空单元格。 语法本身提供了网格结构的可视化。值： &lt;grid-area-name&gt; – 使用 grid-area 属性设置的网格区域的名称 . – 点号代表一个空网格单元 none – 没有定义网格区域 grid-template：在单个声明中定义 grid-template-rows、grid-template-columns、grid-template-areas 的简写。 值： none – 将三个属性都设置为其初始值 subgrid – 把 grid-template-rows 和 grid-template-columns 设置为 subgrid, 并且 - - - grid-template-areas 设置为初始值 grid-template-rows / &lt;grid-template-columns – 把 grid-template-columns 和 grid-template-rows 设置为指定值, 与此同时, 设置 grid-template-areas 为 none grid-column-gap/grid-row-gap：指定网格线的大小，你可以把它想象为设置列/行之间的间距的宽度。 值： line-size – 一个长度值 grid-gap：grid-row-gap 和 grid-column-gap 的缩写 justify-items：沿着行轴对齐网格内的内容（与之对应的是 align-items, 即沿着列轴对齐），该值适用于容器内的所有的 grid items。 值： start: 内容与网格区域的左端对齐 end: 内容与网格区域的右端对齐 center: 内容位于网格区域的中间位置 stretch: 内容宽度占据整个网格区域空间(这是默认值) align-items：沿着列轴对齐 grid item 里的内容（与之对应的是使用 justify-items 设置沿着行轴对齐），该值适用于容器内的所有 grid items。 值： start: 内容与网格区域的顶端对齐 end: 内容与网格区域的底部对齐 center: 内容位于网格区域的垂直中心位置 stretch: 内容高度占据整个网格区域空间(这是默认值) justify-content：有时，网格的总大小可能小于其网格容器的大小。如果你的所有 grid items 都使用像px这样的非弹性单位来设置大小，则可能发生这种情况。此时，你可以设置网格容器内的网格的对齐方式。 此属性沿着行轴对齐网格（与之对应的是 align-content, 沿着列轴对齐）。 值： start – 网格与网格容器的左边对齐 end – 网格与网格容器的右边对齐 center – 网格与网格容器的中间对齐 stretch – 调整 grid item 的大小，让宽度填充整个网格容器 space-around – 在 grid item 之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半 space-between – 在 grid item 之间设置均等宽度空白间隙，其外边缘无间隙 space-evenly – 在每个 grid item 之间设置均等宽度的空白间隙，包括外边缘 align-content：有时，网格的总大小可能小于其网格容器的大小。如果你的所有 grid items 都使用像px这样的非弹性单位来设置大小，则可能发生这种情况。此时，你可以设置网格容器内的网格的对齐方式。 此属性沿着列轴对齐网格（与之对应的是 justify-content, 即沿着行轴对齐）。 值： start – 网格与网格容器的顶部对齐 end – 网格与网格容器的底部对齐 center – 网格与网格容器的中间对齐 stretch – 调整 grid item 的大小，让高度填充整个网格容器 space-around – 在 grid item 之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半 space-between – 在 grid item 之间设置均等宽度空白间隙，其外边缘无间隙 space-evenly – 在每个 grid item 之间设置均等宽度的空白间隙，包括外边缘 grid-auto-columns/grid-auto-rows：指定自动生成的网格轨道（又名隐式网格轨道）的大小。 隐式网格轨道在你显式的定位超出指定网格范围的行或列（使用 grid-template-rows/grid-template-columns）时被创建。 值： &lt;track-size&gt;– 可以是一个长度值，一个百分比值，或者一个自由空间的一部分（使用 fr 单位） grid-auto-flow：如果你存在没有显示指明放置在网格上的 grid item，则自动放置算法会自动放置这些项目。 而该属性则用于控制自动布局算法的工作方式。 值： row – 告诉自动布局算法依次填充每行，根据需要添加新行 column – 告诉自动布局算法依次填充每列，根据需要添加新列 dense – 告诉自动布局算法，如果后面出现较小的 grid item，则尝试在网格中填充空洞 grid：在单个属性中设置所有以下属性的简写：grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns和 grid-auto-flow。 它同时也将 sets grid-column-gap 和 grid-row-gap 设置为它们的初始值，即使它们不能被此属性显示设置。 值： none – 将所有子属性设置为其初始值 &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt; – 将 grid-template-rows 和 grid-template-columns 分别设置为指定值，将所有其他子属性设置为其初始值 &lt;grid-auto-flow&gt; [&lt;grid-auto-rows&gt; [ / &lt;grid-auto-columns&gt;] ] – 接受所有与 grid-auto-flow，grid-auto-rows和 grid-auto-columns相同的值。 如果省略 grid-auto-columns，则将其设置为为 grid-auto-rows指定的值。 如果两者都被省略，则它们被设置为它们的初始值 Grid item属性 grid-column-start/grid-column-end/grid-row-start/grid-row-end：使用特定的网格线确定 grid item 在网格内的位置。grid-column-start/grid-row-start 属性表示 grid item的网格线的起始位置，grid-column-end/grid-row-end属性表示网格项的网格线的终止位置。 值： &lt;line&gt;: 可以是一个数字来指代相应编号的网格线，也可使用名称指代相应命名的网格线 span &lt;number&gt;: 网格项将跨越指定数量的网格轨道 span &lt;name&gt;: 网格项将跨越一些轨道，直到碰到指定命名的网格线 auto: 自动布局， 或者自动跨越， 或者跨越一个默认的轨道 grid-column/grid-row：grid-column-start + grid-column-end, 和 grid-row-start + grid-row-end 的简写形式。 值： &lt;start-line&gt; / &lt;end-line&gt; – 每个值的用法都和属性分开写时的用法一样 grid-area：给 grid item 进行命名以便于使用 grid-template-areas 属性创建模板时来进行引用。另外也可以做为 grid-row-start + grid-column-start + grid-row-end + grid-column-end 的简写形式。 值： &lt;name&gt; – 你的命名 &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt; – 可以是数字，也可以是网格线的名字 justify-self：沿着行轴对齐 grid item 里的内容（与之对应的是 align-self, 即沿列轴对齐）。 此属性对单个网格项内的内容生效。 值： start – 将内容对齐到网格区域的左端 end – 将内容对齐到网格区域的右端 center – 将内容对齐到网格区域的中间 stretch – 填充网格区域的宽度 (这是默认值) align-self：沿着列轴对齐 grid item 里的内容（与之对应的是 justify-self, 即沿行轴对齐）。 此属性对单个网格项内的内容生效。 值： start – 将内容对齐到网格区域的顶部 end – 将内容对齐到网格区域的底部 center – 将内容对齐到网格区域的中间 stretch – 填充网格区域的高度 (这是默认值)","link":"/posts/ef632e96/"},{"title":"ES6-Set Map","text":"ES6- Set 集合与 Map 集合Set 集合ES6 新增的 Set 类型是一种有序列表，其中含有一些相互独立的 非重复值，通过 Set 集合可以快速访问其中的数据，更有效的追踪各种离散值 创建 Set 集合并添加元素使用 new Set() 创建 Set 集合，调用 add() 方法 可以添加元素，访问 Set 集合的 size 属性 可以获取集合中目前的元素数量。 调用 add() 方法 将元素添加到 Set 集合中时，不会对所存的值进行强制的类型转换，所以数字 ·5 与 字符串 '5' 可以作为两个独立的存在， Set 中的对象相互之间也保持独立。添加重复元素时，其不会被添加到集合中， Set 集合中的 size 属性 会保持不变。 移除元素调用 delete() 方法 可以移除 Set 集合中的指定元素，调用 clear() 方法 会移除集合中的所有元素 Set 集合的 forEach() 方法Set 集合 的 forEach 方法与 数组的 forEach 方法类似，但其 回调函数 接受3个参数： Set 集合中下一次索引的位置 与第一个参数一样的值 北边里的 Set 集合本身 其第一个参数与第二个参数一致很奇怪是吧？我们可以联想一下 数组的 forEach 与 Map 集合的 forEach 方法，这两个集合的 forEach 方法都接受三个参数，与 Set 集合不同的是，它们的前两个参数分别是 值 和 键名(对于数组来说，是 数值型索引值)，而 Set 集合是没有键名也没有数值型索引值的，为了使 forEach 方法的使用便捷，决定将 Set 集合的每个元素也按照键名和值的形式储存(值与键同值) forEach 方法接受将 this 作为第二个参数，从而可以在回调函数中使用 this 引用 注意，Set 集合无法通过访问索引访问集合中的元素，不过我们可以将 Set 集合转换为数组 将 Set 集合转换为数组 将数组转换为 Set 集合： 给 Set 构造函数传入数组即可，转换为 Set 集合后，Set 集合中不会有重复的元素 使用展开运算符 ... 将 Set 集合转换回数组, 新数组中保存的是 Set 集合中的元素123456// 数组 转换为 Set 集合let setG = new Set([1, 2, 3, 4, 5, 3, 3, 3]);console.log(setG) // Set(5) {1, 2, 3, 4, 5}// Set 集合转换为 数组let arr = [...setG]console.log(arr) // (5) [1, 2, 3, 4, 5] Weak Set 集合Set 集合是强引用的 Set 集合： 12345678910111213let setG = new Set(), key = {}// 将 对象 key 添加进 Set 中set.add(key)console.log(setG.size) // 1// 移除原始引用key = nullconsole.log(setG.size) // 1// Set 集合保留了对原始对象的引用，仍然可以访问 引用的值，导致垃圾回收机制不能释放原始引用对象的内存空间，可能会造成内存泄漏key = [...setG][0] Weak Set 集合是弱引用的 Set 集合，只存储对象的弱引用，并且 不可以存储原始值，如果集合中包含任何非对象值，会抛出错误；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存 创建 Weak Set 集合用 WeakSet 构造函数可以创建 Weak Set 集合，集合支持3个方法： add() 方法，向集合中添加元素、 has()方法 检查集合中是否存在指定对象的引用、 delete() 移除指定对象的引用 两种 Set 类型的区别 在 WeakSet 实例中，如果向 add(), has(). delete() 这三个方法传入非对象参数都会导致程序报错 Weak Set 集合不可迭代，不能被用于 for-of 循环 Weak Set 集合不暴露任何迭代器方法，所以无法通关程序本身来检测其中的内容 Weak Set 集合不支持 forEach() 方法 Weak Set 集合不支持 size 属性 Map 集合Map 类型是一种储存着许多 键值对 的 有序列表，其中的 键名 和 值 支持所有的数据属性。 Map 类型的 键名 不会被强制类型转换，所以数字 5 与 字符串 '5' 可以作为两个独立的键 可以访问 Map 集合的 size 属性，获得集合中元素的数量 Map 类型还能以 对象 作为键值，并将其储存在集合中 Map 集合支持的方法 set() 方法: 分别传入 键名 和 对应的值 作为两个参数，向 Map 集合中添加新的元素 get() 方法： 传入要访问的 键名， 用于访问 Map 集合中的对应键名的值，如果 传入的键名 在集合中不存在，则返回 undefined has() 方法，传入一个指定的键名， 检测指定的键名在 Map 集合中是否已存在 delete() 方法 从 Map 集合中移除指定的键名及其对应的值 clear() 移除 Map 集合中的所有键值对 Map 集合的初始化方法可以向 Map 构造函数传入一个数组来初始化一个 Map 集合。数组中的每个元素 都是一个 子数组，子数组中包含一个 键值对的 键名 与 值 两个元素 123456let age = 25, obj = {}let map = new Map([['name', 'a'], ['age', age], [obj, obj]])console.log(map.get('name')) // 'a'console.log(map.get('age')) // 25console.log(map.get(obj)) //{} Map 集合的 forEach() 方法Map 集合 的 forEach 方法与 数组的 forEach 方法类似，其 回调函数 接受3个参数： Set 集合中下一次索引的位置 值对应的键名 北边里的 Set 集合本身 遍历过程中，会按照 键值对 插入 Map 集合中的顺序，将相应信息传入 forEach() 方法的回调函数 Weak Map 集合Weak Map 是弱引用的 Map 集合，用域存储对象的弱引用。 Weak Map 集合中的键名必须是一个对象，使用非对象键名会报错；集合中的键名保存的是这些对象的弱引用，如果在弱引用之外不存在其他的强引用，引擎的垃圾回收机制会自动回收这个对象，同时也会移除 Weak Map 集合中的 键值对。 **注意，只有集合的键名遵守这个规则，键名对应的 值 如果是一个对象，则保存的是对象的 强引用，不会触发垃圾回收机制。 Weak Map 集合支持的方法Weak Map 类型是一种存储着许多键值对的 无序 列表，列表的键名 必须是非 null 类型的对象，键名对应的值可以是任意类型。 WeakMap 集合通过 set() 方法添加数据，通过 get() 方法获取数据1234567891011121314let map1 = new WeakMap(), element = {}map1.set(element, 'Original')let value = map1.get(element)console.log(value) // 'Original'// 移除 element 元素element.parentNode.removeChild(element)element = null// 由于没有键对应的引用，无法通过 get() 方法获取到对应的值，Weak Map 集合自动切断了访问这个值的途径，当垃圾回收程序运行时，被这个值占用的内存将会被释放map1.get(element) // undefinedmap1.has(element) // false has() 方法可以检测指定的 键 在集合中是否存在 delete() 方法可以根据给定的键名，移除指定的键值对 Weak Map 集合的初始化方法调用 WeakMap 构造函数并传入一个数组容器，容器内包含其他数组，每一个数组由两个元素够撑，第一个元素是一个键名，传入的值必须是非 null 的对象，第二个元素是这个键对应的值，可以实任意类型 创建对象私有数据我们可以使用 Weak Map 集合来存放私有数据 1234567891011121314151617let Person = (function() { let PrivateData = new WeakMap() function Person1(name) { // Person 对象的实例被直接作为集合的键使用，用于跟踪数据，值是对象包含的私有数据(name) privateData.set(this, {name: name}) } // 调用 getName 是可以获得私有数据 Person1.prototype.getName = function() { return privateData.get(this).name } return Person1})()//对象实例被销毁时，相关的信息也会被销毁 Weak Map 与 Map 区别 Weak Map 只能使用 对象 作为集合的键名 Map 的键名是强引用，Weak Map 的键名是弱引用 Weak Map 集合不支持 forEach(), clear() 方法和 size 属性。","link":"/posts/1326466e/"},{"title":"ES6-Symbol","text":"ES6-Symbol主要用于与创建对象的 私有成员 创建 SymbolSymbol 使基本数据类型之一，但没有字面形式，无法通过 new 关键字创建，只能通过 Symbol 全局函数创建： 1234567891011121314// Symbol 接受一个可选参数，用于添加一段文本描述该 Symbol，该描述不可用于属性访问let firstSymbol = Symbol('first symbol')let person = {}person[firstSymbol] = 'a'console.log('first symbol' in person) //falseconsole.log(person[firstSymbol]) // 'a'//`Symbol` 的描述被存储在内部的 `[[Description]]` 属性中，只有调用 `Symbol` 的 `toString()` 方法才能读取该属性console.log(firstSymbol) // \"Symbol(first symbol)\"// 可以使用 typeof 来检测变量是否为 Symbol 类型console.log(typeof firstSymbol) // 'symbol Symbol 共享体系 在所有使用 可计算属性名 的地方，都可以使用 Symbol 来代替，但是为了在不同代码片段间有效的共享这些 Symbol ，需要建立一个体系。 如果要创建一个可共享的 Symbol ，需要使用 Symbol.for() 方法，它只接受一个参数，就是将要创建的 Symbol 的字符串标识符，这个参数也被用作 Symbol 的描述文本。 123456789101112131415161718let uid = Symbol.for('uid')letobject = {[uid]:'12345'}console.log(object[uid]) // '12345'console.log(uid) // 'Symbol(uid)'let uid2 = Symbol.for('uid')// uid 与 uid2 包含相同的 Symbol 并且可以互换使用console.log(uid === uid2) //trueconsole.log(object[uid2]) // '12345'console.log(uid2) // 'Symbol(uid)'// Symbol.keyFor 方法在 Symbol 全局注册表中检索与 Symbol 有关的键console.log(Symbol.keyFor(uid)) // 'uid'console.log(Symbol.keyFor(uid2)) // 'uid'// Symbol 全局注册表中不粗在 uid3 这个 Symbol， 因而返回 undefinedconsole.log(Symbol.keyFor(uid3)) // undefined 如上,Symbol.for() 方法首先在全局 Symbol 注册表中搜索键为 uid 的 Symbol 是否存在，如果存在，直接返回已有的 Symbol；否则，创建一个以 uid 为描述文本的新的 Symbol, 并使用这个键在 Symbol 全局注册表中注册，随即返回新创建的 Symbol Symbol 与类型强制转换Symbol 无法被强制转换为其他类型，无法进行字符串拼接，也无法与任何一个数学运算符混合使用。 Symbol 只能使用 String(Symbol) 或者 Symbol.toString() 方法，返回字符串类型的 Symbol 描述里的内容 Symbol 属性检索Object.getOwnProperty-Symbols() 方法，用域检索对象中的 Symbol 属性。该方法的返回值是一个包含所有 Symbol 自有属性的数组","link":"/posts/67a849eb/"},{"title":"ES6-函数","text":"ES6 函数参数默认参数 在定义函数时，可以直接给函数参数提供一个默认值： 12//如下，该函数的参数 `timeout`被赋予了一个2000的默认值，`callback`被赋予了一个空函数作为默认值function makeRequest(url, timeout=2000, callback = function() {}) 在 ES6 中，默认参数值会影响 arguments 对象，默认参数值的存在会使 arguments 对象与命名参数分离： 123456789101112// 如下所示，first 与 arguments[0]全等，但是改变形参 first 与 second 的值并不会影响 arguments 对象。所以我们总是可以利用 arguments 对象将形参恢复为初始值 function test(first, second='b') { console.log(arguments.length) //1 console.log(first === arguments[0]) //true console.log(second === arguments[1]) //false first = 'c' second = 'd' console.log(first === arguments[0]) //false console.log(second === arguments[1]) //false first = argumetns[0] console.log(first)}('a') 默认参数的值可以通过函数表达式得到： 123456789let value = 5function getValue() { return value++}// 此处如果默认参数未调用函数，那么传入的只是对函数的引用，而不是函数调用的结果function add(first, second=getValue()) { return first + second}console.log(add(1))//6 引用参数默认值的时候，只能引用前面的参数，即先定义的参数不能访问后定义的参数(TDZ)： 12345// 当初此执行函数add()时，绑定first和second被添加到一个专属于函数参数的临时性死区，因为当first初始化时second尚未初始化，first试图访问仍在TDZ的second，因此会抛出错误。function add(first=second, second) { return first + second}console.log(add(undefined, 1))// err 注意，函数参数有自己的作用域和临时死区，其与函数体的作用域是各自独立的，也就是说函数的默认值不可访问函数体内声明的变量 无命名参数与不定参数 无命名参数：调用函数时，提供的参数 超出 声明函数时 提供的参数数量 意外的 参数 不定参数： 在函数的命名参数前添加三个点(...)就表明这是一个不定参数，该参数为一个数组，包含着自他之后传入的所有参数，通过这个数组名轲注意访问里面的参数 函数的 length 属性统计的是函数命名参数的数量，不定参数的加入不会影响 length 属性的值 不定参数的使用限制 每个函数的最多只能声明一个不定参数，且只能放在所有参数的末尾 不定参数不能用于对象字面量 setter 中：因为对象字面量 setter 的参数有且只能有一个，而不定参数的定义中，参数可以有无限多个。 不定参数对 arguments 对象的影响无论是否适用不定参数，arguments 对象总是包含了所有传入函数的参数 展开运算符展开运算符可以让你指定一个数组，将他们打散后作为各自独立的参数传入函数，如下： 123456// example 1let values = [25, 50, 75, 100]console.log(Math.max.apply(Math, values)) //100//example 2： 此处实现的效果完全等同于 example 1let values = [25, 50, 75, 100]console.log(Math.max(...values)) 展开运算符适用于函数调用中 不定参数适用于函数的声明中 name 属性ES6中，所有的函数的 name 属性都有一个合适的值，如下： 1234567891011121314151617var doSomething = function doSomethingElse() {}var person = { get firstName() { return 'a'}, sayName: function() {console.log(this.name)}}// 命名函数的 name 的权重高于函数表达式的 name console.log(doSomethingElse.name) // 'doSomethingElse'console.log(person.sayName.name) //'sayname'// getter 和 setter 函数的 name 属性有 'get' 'set' 前缀console.log(person.firstName.name) //'get firstName'var doAnotherThing() {}// bind() 函数创建的函数的 name 属性带有 'bound' 前缀console.log(doAnotherThing.bind().name) // 'bound doAnotherThing'// 通过 Function 构造函数创建的函数，其 name 属性带有 'anonymous' 前缀console.log((new Function()).name) //'anonymous' 注意，函数的 name 属性不一定引用同名变量，他只是协助调试用的额外信息，所以不能使用 name 属性的值来获取对于函数的引用 判断函数如何被调用 的方法JavaScript 函数有两个内部方法: [[Call]] 和 [[Construct]]： 当通过 new 关键字调用函数时，执行的时 [[Construct]] 函数，他负责创建一个被称作实例的新对象，然后再执行函数体，将 this 绑定到实例上； 如果不是通过 new 来调用，则执行 [[Call]] 函数，从而直接执行代码中的函数体，具有 [[Construct]] 方法的函数被统称为构造函数 元属性 new.target元属性 new.target 是 ES6 新引入的，指非对象的属性，其可以提供非目标对象的补充信息，主要用于判断函数是否通过 new 关键字调用。 当调用函数的 [[Construct]] 时， new.target 被赋值为 new 操作为的目标，通常是新创建对象实例，也就是函数体内 this 的构造函数 如果调用的时 [[Call]] 方法，则 new.target 的值为 undefined 123456789101112131415function Person(name) { // 使用 new 关键字，typeof new.target 指向 构造函数本身 if (typeof new.target === Person) { this.name = name } else { throw new Error('必须使用 new 关键字来调用') }}function AntherPerson(name) { // 未使用 new 关键字，抛出错误 Person.call(this, name)}var person = new Person('a') // workvar anotherPerson = new AnotherPerson('a') // err 块级函数块级函数是指在块级作用域中声明的函数，ES6中对于严格模式和非严格模式的块级函数的表现有不同： 严格模式下，块级函数的声明将会被提升到块级作用域的顶部 非严格模式下，块级作用域的声明将会被提升到外围函数或全局作用域的顶部，因此可以在本块级作用域之外调用。 箭头函数特性： 没有 this, super, arguments, new.target 绑定，箭头函数的 this, super, arguments, new.target 这些值由外围最近一层非箭头函数决定 不能通过 new 关键字调用： 箭头函数没有 [[Construct]] 方法，所以不能被用作构造函数 没有原型，不存在 prototype 属性 不可以改变 this 的绑定 函数内部的 this 值不可被改编 不支持 arguments 对象，但始终可以访问外围函数的 arguments 对象 不支持重复的命名参数 尾调用优化尾调用是指： 函数作为另一个函数的 最后一条语句被调用 尾调用的实现： 创建一个新的栈帧，将其推入调用栈来表示函数调用，也就是说， 在循环调用中，每一个未用完的栈帧都会被保存在内存中，当调用栈变得过大时会造成程序问题 ES6的尾调用优化在ES6中严格模式下，如果满足以下条件，尾调用不在创建新的栈帧，而是清楚冰虫蛹当前栈帧： 尾调用不访问当前栈帧的变量(也就是说函数不是一个闭包) 在函数内部，尾调用是最后一条语句 尾调用的结果作为函数值返回 12345'use strict'function doSomething() { // 未访问当前栈帧的变更了，尾调用是最后一条语句，尾调用的结果作为函数值返回 return doSomethingElse()}","link":"/posts/fd61cab2/"},{"title":"ES6-块级作用域与字符串","text":"ES6 块级作用域与字符串块级作用域var 声明及变量提升在 函数作用域 或 全局作用域 中通过关键字 var 声明的变量，无论实际上是在那里声明的，都会被当成在当前作用域顶部声明的变量，这就是 var 的变量提升机制 123456// 注意，变量提升机制只是提升对变量的声明，赋值操作未被提升，例如：// 此时对于变量 a 的声明被提升到顶部，但是 a 未被赋值console.log(a) // undefined// 变量 a 此时才被赋值var a = 1console.log(a) //1 以上代码块可以解释使用 var 声明赋值的变量可以被看成是分成两步走的， 声明一个变量，并将其提升到作用域顶部 当代码执行到变量赋值那一行时，才进行变量的赋值操作 块级声明(词法作用域)块级作用域存在于: 函数内部 块中(字符 {和 }之间的区域) let 声明的变量 拥有块级作用域 不存在提升机制 不允许重复声明同一变量： 如果作用域中已经存在某个变量标识符，如使用 let 再次声明该变量标识符，则会抛出语法错误，若处于内嵌的作用域中，则无影响。如下： 12345678var a = 1if (true) { // 内嵌中,work let a = 2 console.log('let:' + a)}// 同一作用域中 SyntaxErrorlet a =3 const 声明的是常量： 在被声明时必须进行初始化(赋值) 不允许修改绑定，但允许修改值(不可以对基本数据类型的常数进行修改，可以对引用数据类型的常数的属性进行修改) 不允许重复声明同一变量 暂时死区(TDZ)JavaScript 引擎再扫描代码发现变量时，要么将它们的声明提升到作用于顶部(var 声明)， 要么将声明放到TDZ中(let 和 const 声明)。访问 TDZ 中的标量会触发运行时错误，只有执行过变量声明语句后，变量才会从 TDZ 中移出，然后放可正常访问 var, let, const 区别 区别 var声明 let声明 const声明 块级作用域 x o o 提升 o x x 重复声明同一标识符 o x x 标识符再赋值 o o x 声明时必须初始化 x x o 存在 TDZ x o o 在全局作用域中声明时的行为 会创建一个新的全局变量作为全局对象的属性 会创建一个全局变量，但不会作为全局对象的属性 会创建一个全局变量，但不会作为全局对象的属性 字符串字符串的子串识别 str.includes(string[, index]): 如果在字符串中检测到指定文本则返回true str.stratsWith(string[, index]): 如果在字符串的起始部分检测到指定的文本则返回true str.endsWith(string[, index]): 如果在字符串的结束部分检测到指定的文本则返回true","link":"/posts/51925e1/"},{"title":"ES6-对象","text":"ES6 对象对象字面量 语法扩展对象 属性与方法 的简写 在 ES6 中，如果一个对象的属性与本地变量同名时，可以使用简写的语法，即简单地只写属性名。如123var obj = {name: name, age: age}//以上代码等同于var obj = {name, age} 在 ES6 中，对象的方法可以省略 function 关键字与冒号，简写成 &lt;functionName&gt;(){} 的方式，如：1var person = {name:'a', sayName(){console.log(this.name)}} 可计算属性名在 ES6 中，对象的属性可以使用 [] 包裹。在对象字面量中，使用方括号表示的该属性名称是可计算的，它的内容将被求值并被转化为一个字符串，如 1234567var end = ' name'var person = { ['first' + end]: 'a', ['last' + end]: 'b',}console.log(person['first name']) // 'a'console.log(person['last name']) // 'b' 重复的 对象字面量 属性在 ES6 中，对象的重复属性不会报错，但是同名属性的值 会采用 位于最后的一个属性的取值 Object 新增方法Object.is(a, b)该方法用于比较两个值是否相等，其运行结果大部分情况下与 === 元素运算符一致，区别在于 +0 与 -0 被识别为不相等，NaN 与 NaN 等价 Object.assign()该方法接受一个接收对象 和任意数量的 源对象，并按指定的顺序将属性 复制到接收对象中，最终返回接收对象。 如果多个源对象具有同名属性，排名靠后的属性会覆盖排名靠前的。 123var receiver = {}Object.assign(receiver, {type: 'js', name:'file.js'}, {type: 'css'})console.log(receiver.type) //'css' 注意，Object.assign() 不能将源对象的 访问器属性 复制到接收对象中。因为 Objcet.assign() 执行了赋值操作(即查询 -&gt; 赋值)，因此访问器属性 会被转化为 接收对象的一个数据属性 Object.getOwnPropertyDescriptors()接收一个对象作为参数，返回一个对象，包含指定对象 所有自身属性（非继承属性）和属性描述符。 12345const obj = { foo: 123, get bar() { return 'abc' }};console.log(Object.getOwnPropertyDescriptors(obj)) //{foo: {value: 123, writable: true, enumerable: true, configurable: true}, bar: {set: undefined, enumerable: true, configurable: true, get: ƒ}} Object.getPropertypeOf(target)接收一个对象，返回该对象的原型 Object.setPropertypeOf(target, source)接收两个对象，将 source 对象设置为 target 对象的原型 Object 遍历方法 Object.keys() 返回一个包含对象自身所有的 可枚举的 属性键 的的数组 Object.values() 返回一个包含自身所有的 可枚举 属性值 的数组 Object.entries() 返回一个包含对象自身所有的 可枚举 键值对 的数组 Object.fromEntries() 把键值对列表转换为一个对象。 自有属性枚举顺序ES6 中，严格规定了对象的自有属性被枚举时的返回顺序，者将会影响到 Object.getOwnPropertyNames() 方法 及 Reflect.ownKeys 返回属性的方式， Objcet.assign() 方法处理属性的顺序也将随之改变。 自有属性枚举顺序的基本规则： 所有数字键按升序排序 所有字符串键按照他们被加入对象的顺序排序 所有 symbol 键按照他们被加入对象的顺序排序 注意，for-in 循环的枚举顺序未被统一，Object.keys() 和 JSON.Stringify() 方法采用与 for-in 相同的枚举顺序，因此他们的枚举顺序目前也不清晰 增强对象原型改变对象的原型Object.setPropertypeOf() 方法用于改变任意指定对象的原型，接受两个参数： 被改变原型的对象 及 替代第一个参数原型 的对象 Object.create() 方法用于创建一个对象，接收一个参数 null 或 一个对象： 如果这个参数值为 null 则会创建一个没有原型链的对象，彻底的空对象这个参数会被设置为。 如果这个参数值是一个对象，那么这个对象会成为 被创建对象的原型。 简化原型访问的 super 引用super 引用相当于 指向对象原型 的指针： 1234567891011121314var person = {getGreeting() {return 'Hello'}}var dor = {getGreeting() {return 'Woof'}}var friend = { getGreeting() { //相当于 Object.getPropertypeOf(this).getGreeting.call(this) return super.getGreeting() + 'hi!' }}Object.getPropertypeOf(friend, person)console.log(friend.getGreeting()) // 'Hello hi!'Object.getPropertypeOf(friend, dog)console.log(friend.getGreeting()) // 'Woof hi!' 可以通过 super 引用调用对象原型上所有方法。 必须要在使用简写方法的对象中使用 super 引用，在其它方法声明中使用会导致语法错误 super 引用不是动态变化的 正式的方法定义在 ES6 中，方法 被正式定义为一个 函数。它会有一个内部的 [[HomeObject]] 属性，来容纳这个方法 从属的对象。 123456789101112let person = { //方法 // 直接将函数赋值给了 person 对象，因而 gerGreeting 方法的 [[HomeObject]] 属性为 person. getGreeting() { return 'Hello' }}// 不是方法// 为被赋值给一个对象，因而没有明确定义 [[HomeObject]] 属性function shareGreeting() { return 'Hi'} super的所有引用都通过 [[HomeObject]] 来确定后续的运行过程。首先在 [[HomeObject]] 属性上调用 Object.getPropertypeOf() 方法来检索原型的引用，然后搜寻原型找到同名函数；最后，设置 this 绑定并调用相应的方法","link":"/posts/1274d57e/"},{"title":"ES6-解构","text":"ES6-解构解构赋值表达式(也就是 = 号右边的表达式)如果为 null 或者 undefined 会导致程序抛出错误 对象解构对象字面量语法形式的解构： 在一个赋值操作符左边放置一个对象字面量，如： 12345let node = {type: 'Identifier', name: 'foo'}// 变量声明解构时，必须要提供初始化程序（即必须要赋值（有等号右边的值），否则会报错）let {type, name} = node // 变量声明解构console.log(type) // 'Identifier'console.log(name)// 'foo' 解构赋值可以给 已赋值 的变量进行 解构赋值： 1234567let node = {type: 'Identifier', name: 'foo'}, type='Literal', name: 5// 解构赋值, 注意,JS引擎将一堆开放的花括号视为一个代码块，语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式({type, name} = node)console.log(type)// 'Identifier'console.log(name)// 'foo' 默认值 使用解构赋值表达式时，如果指定的 局部变量名称 在对象中不存在，这个局部变量会被赋值为 ‘undefined’: 123456let node = {type: 'Identifier', name: 'foo'}// value 在 node 中无同名属性, 因此被赋值为 undefinedlet {type, name, value} = node console.log(type) // 'Identifier'console.log(name) // 'foo'console.log(value) // undefined 当指定属性不存在时，可以给局部变量定义一个默认值，在局部变量后添加一个等号(=)和相应的默认值即可。 123456let node = {type: 'Identifier', name: 'foo'}// value 被赋予了一个默认值 true,该默认值只在 node 无同名属性或该属性为 'undefined' 是生效。let {type, name, value=true} = node console.log(type) // 'Identifier'console.log(name) // 'foo'console.log(value) // true 为 非同名局部变量 赋值1234567let node = {type: 'Identifier', name: 'foo'}// type: localType 语法的含义是 读取都名为 type 的属性，并将其值存储在变量 localType 中// 这种情况下也可以添加默认值，以下为 localValue 添加了默认值let {type: localType, name: localName, value: localValue = 5} = nodeconsole.log(localType) // 'Identifier'console.log(localName) //'bar'console.log(localValue) // 5 嵌套对象解构12345678910111213141516171819202122let node = { type: 'Identifier', name: 'foo', loc: { start: { line: 1, column: 1 }, end: { line: 1, column: 4 } }}// 在解构模式中使用了花括号，含义为在找到 node 对象的 loc 属性后，应当深入一层继续查找 start 属性let {loc: {start}} = nodeconsole.log(start.line) //1// 所有 冒号前的标识符 都代表在对象中的 检索位置，其右侧为 被赋值的变量名；如果冒号后是花括号，则意味着要赋予的最终值被嵌套在对象内部更深的层级中let {loc: {start: localStart}} = nodeconsole.log(localStart.line) //1 数组结构数组解构使用的是数组字面量，且解构操作全部在数组内完成 123456789let colors = ['red', 'green', 'blue']// 在数组解构语法中，我们通过 值 在数组中的位置进行选取，且可将其存储在任意变量中，未显示声明的元素都会被直接忽略，在此过程中，数组本身不会发生任何变化let [firstColor, secondColor] = colorsconsole.log(firstColor) // 'red'console.log(secondColor) // 'green'// 在数组解构语法中，可以直接忽略元素，职位感兴趣的元素提供变量名let [, , thirdColor] = colorsconsole.log(thirdColor) // 'blue' 解构赋值数组解构也可用于赋值上下文，但不需要用小括号包裹表达式 123456let colors = ['red', 'green', 'blue'] firstColor = 'black' secondColor = 'purple'[firstColor, secondColor] = colorsconsole.log(firstColor) // 'red'console.log(secondColor) // 'green' 交换两个变量的值12345let a = 1, b = 2// 左侧是一个解构模式，右侧是一个为交换过程创建的 临时数组字面量。在代码执行过程中，先解构临时数组，将 b 和 a 的值复制到左侧数组的前两个位置，最终结果是变量互换了它们的值[a, b] = [b, a]console.log(a) //2console.log(b) //1 默认值可以在数组解构表达式中为数组中的任意位置添加默认值，当指定位置的属性不存在或值为 undefined 时使用默认值 1234let colors = ['red']let [firstColor, secondColor = 'green'] = colorsconsole.log(firstColor) //'red'console.log(secondColor) //'green' 嵌套数组解构在原有的 数组解构模式 中插入另一个 数组解构模式，即可将结构过程深入到下一个层级 12345let colors = ['red', ['green', 'lightgreem'], 'blue']let [firstColor, [secondColor]] = colorsconsole.log(firstColor) //'red'console.log(secondColor) //'green' 不定元素在数组中，可以通过 ... 语法将数组中的其余元素赋值给一个特定的变量 1234567let colors = ['red', 'green', 'blue']let [firstColor, ...restColor] = colorsconsole.log(firstColor) // 'red'console.log(restColor.length) //2console.log(restColor[0]) // 'green'console.log(restColor[1]) // 'blue' 不定元素可以实现 数组复制 功能 123let colors = ['red', 'green', 'blue']let [...cloneColors] = colorsconsole.log(cloneColors) // ['red', 'green', 'blue']","link":"/posts/f2b8fbba/"},{"title":"ES6-迭代器与生成器","text":"ES6 迭代器与生成器迭代器迭代器是一种特殊的对象，具有专为 迭代过程 设计的撰有接口，迭代器对象都有一个 next() 方法，该方法调用后会返回一个结果对象。 该结果对象有两个属性： value，表示下一个将要返回的值 done，是一个布尔值，表示是否迭代完数据集 迭代其中有一个内部指针，用来指向当前集合中 值 的位置，每调用一次 next() 方法，都会返回下一个可用的 值。 当最后一个值返回后再调用 next() 方法，返回的对象中 属性 done 的值为 true， 属性 value 则包含迭代器最终返回的 值（这个返回值不是 数据集 中的一部分，它与函数的返回值类似，是函数调用过程中最后一次给 调用者 传递信息 的方法，如果没有相关数据则返回 undefined） 生成器生成器是一中返回 迭代器 的函数，通过 function 关键字后的星号(*)来表示，函数中会用到新的关键字 yield，如 123456789101112function *createIterator() { yield 1 // yield 关键字可以返回任何值或者表达式，每当执行完一句 yield 语句后，函数会自动停止执行，知道再次调用迭代器的 next() 方法 yield 2 yield 3}// 生成器的调用方式与普通函数一致，不过 返回一个迭代器let iterator = createIterator()console.log(iterator.next().value) //1console.log(iterator.next().value) //2console.log(iterator.next().value) //3 注意，yield 关键字只能在生成器内部使用，在其他地方，即使是生成器内部的函数内使用，都会抛出错误 生成器表达式生成器可以用表达式的方式来创建，如下 12let createIterator = function *(item) {//code...}let iterator = createIterator() 生成器对象的方法生成器本身就是函数，所以可以将它们添加到对象中 1234567let obj = { *creeateIterator() { yield 1 }}let iterator = o.createIterator() 可迭代对象和 for-of 循环可迭代对象都具有 Symbol.iterator 属性，是一种与迭代器密切相关的对象。 Symbol.iterator （默认被作为生成器）通过指定的函数可以返回一个作用于附属对象的迭代器 在 ES6 中，所有的集合对象和字符串都是可迭代对象，都有默认的迭代器 生成器默认会为 Symbol.iterator 属性赋值，所有通过生成器创建的迭代器都是可迭代对象 for-of 循环每执行一次都会调用可迭代对象的 next() 方法，并将迭代器返回的结果对象 的 value 属性存储在一个变量值，循环将持续执行这一过程，知道对象的 done 属性的 值 为 true,如下： 12345let values = [1, 2, 3]for (let num of values){ console.log(num) //被依次输出 1; 2; 3} 以上代码调用 数组 values 的 Symbol.iterator 方法来获取迭代器，随后迭代器的 next() 方法被多次调用，从它的 返回对象的 value 属性 堆区值 并存储在变量 num 中，当结果对象的 done 属性值为 true 时退出循环，所以 num 不会被赋值为 undefined。 for-of 与 for-in 区别 for-of 循环只可用于可迭代对象，否则会报错。 for-in 循环可枚举对象的属性键，for-of 循环可迭代对象的值 访问默认迭代器我们可以通过访问对象的 Symbol.iterator 来获得对象的 默认迭代器，例如： 123456let values = [1, 2, 3]// 将 values 的迭代器赋值给 iteratorlet iterator = values[Symbol.iterator]()console.log(iterator.next()) // '{value: 1, done: false}'... 因为具有 Symbol.iterator 属性的对象都有默认的迭代器，因此可以使用 typeof obj[Symbol.iterator === 'function 来检测对象是否为可迭代对象 创建可迭代对象默认情况下，开发者定义的对象都是不可迭代对象，如果给 Symbol.iterator 属性添加一个生成器，则可以将其变为可迭代对象 12345678910111213141516let obj = { items: [], *[Symbol.iterator]() { for (let item of this.items) { yield item } }}obj.items.push(1)obj.items.push(2)obj.items.push(3)for (let x of obj) { console.log(x)} 内建迭代器集合对象迭代器ES6 中的集合对象有三种： 数组、Map 集合与 Set 集合，这三种对象都内建了以下三种迭代器 enteries() 返回一个迭代器，其值为多个 键值对。每次调用 next() 方法时，entries() 迭代器都会返回一个数组，数组中的两个元素分别表示 集合中 每个元素的键与值。Map 集合的默认迭代器就是 entries() 方法 values() 返回一个迭代器，其值为集合中的所有值，values() 方法是 数组与 Set集合的默认迭代器方法 keys() 返回一个迭代器，其值为集合中的所有键名 字符串迭代器字符串的默认迭代器与数组的默认迭代器一致，都是 values() 方法。 NodeList 迭代器NodeList 的默认迭代器与数组的默认迭代器一致，都是 values() 方法。 展开运算符 与 非数组可迭代对象通过展开运算符，可以将任何 非数组可迭代对象 转换为 数组 12345678let map = new Map([['name','Nich'], ['age': 25]]), array = [...map]console.log(array) // [['name','Nich'], ['age': 25]]let small = [1, 2, 3], big = [100, 101, 102] all = [0, ...small, ...big]console.log(all) // [0, 1, 2, 3, 100, 101, 102] 高级迭代器功能给迭代器传递参数迭代器的 next() 方法可以接受参数，这个参数的值会替代生成器内部，上一条 yield 语句的返回值。 1234567891011121314function *createIterator() { let first = yield 1 let second = yield first + 2 yield second + 3}let iterator = createIterator()// 第一次调用 next() 方法时，传入的参数会被丢弃 console.log(iterator.next()) // '{value: 1, done: false}'console.log(iterator.next(4)) // '{value: 6, done: false}'console.log(iterator.next(5)) // '{value: 8, done: false}'console.log(iterator.next()) // '{value: undefined, done: true}' 在含参的 yield 语句中，yield 关键字后面的计算结果 即为 当前 next() 方法调用后的返回值；next() 方法中传递的参数，是作为 上一次 next() 方法调用后的返回值，用于计算此次 next() 调用后的返回值 生成器返回语句由于生成其实函数，因此可以通过 return 语句提前退出函数执行，对于最后一次 next() 方法调用，可以主动为其指定一个返回值。在生成其中， return 表示所有操作已经完成，属性 done 被设置为 true，如果提供了相应的值，则属性 value 会被设置成这个值。 return 语句指定的返回值，只会在返回对象中出现一次，在后续调用返回的对象中， value 属性会被重置为 undefined。 1234567891011function *createIterator() { yield 1; return 2; // 3 将不会出现 yield 3;}let iterator = createIterator()console.log(iterator.next()) // {value: 1, done: false}console.log(iterator.next()) // {value: 2, done: true}console.log(iterator.next()) // {value: undefined, done: true} 委托生成器我们可以创建一个生成器，再给 yield 语句添加一个星号，就可以将生成数据的过程委托给其他生成器。 123456789101112131415161718192021222324funtion *createNumber() { yield 1 yield 2}function *createColor() { yield 'red' yield 'green'}function *createCombined() { yield *createNumber() yield *createColor() yield true}let iterator = createCombined()console.log(iterator.next()) // {value: 1, done: false}console.log(iterator.next()) // {value: 2, done: false}console.log(iterator.next()) // {value: 'red, done: false}console.log(iterator.next()) // {value: 'green', done: false}console.log(iterator.next()) // {value: true, done: false}console.log(iterator.next()) // {value: undefined, done: true} 异步迭代器与生成器可以查看我翻译自 《现代JavaScript教程》 的文章 异步迭代器与生成器","link":"/posts/31d9c0d4/"},{"title":"Html5相关","text":"HTML5HTML5特性归类scrollIntoView与 scrollIntoViewIfNeeded API介绍Element.scrollIntoView()该方法让当前的元素滚动到浏览器窗口的可视区域内。可以选择传入一个参数（Boolean型或者 Object型参数）： Boolean型，用法 element.scrollIntoView(true|false)true为元素的顶端与其所在滚动区的可视区域的顶端对齐；false为元素的顶端与其所在滚动区的可视区域的底端对齐，Object型,用法: 12345678element.scrollIntoView({ //设定垂直向的对齐 block: 'start'|'end'|'nearest'|'center', //设定水平向的对齐 inline: 'nearest'|'start'|'end'|'center', //设定滑动动画 behavior:'auto'|'smooth'}) Element.scrollIntoViewIfNeeded（）","link":"/posts/e679f26b/"},{"title":"JS语言精粹读书笔记 -- 对象与函数","text":"JavaScript语言精髓第三章 对象原型每个对象都链接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到 Object.prototype,它是 JS 中的标配对象。 Object.create(obj) 该方法返回一个新对象，该对象的 __proto__ 属性指向 obj，继承 obj 的所有属性和其原型对象(prototype) 原型连接在更新时是不起作用的。当我们对某个对象做出改变，不涉及其 prototype 属性时，不会触及到该对象的原型。 原型连接只有在检索时才会被用到。如果我们试图获取对象中不存在的属性名，Js会试着从其原型中获得。若原型中没有，则继续检索其原型的原型，直到重点 Object.propertype，此时会返回 Undefined. 原型连接是一种动态的关系，如果我们添加一个新属性到原型中，该属性会立即对所有基于该原型创建的对象可见。 获取对象本身属性obj.hasOwnProperty('propertyName') 该方法返回一个布尔值。如果该属性为对象拥有独有的属性，则返回 true。该方法不会检查原型链 枚举for in 语句可用来遍历一个对象中的所有属性名–包括函数和原型中的属性。如果要过滤函数和原型中的属性，最常用的方法是 hasOwnProperty() 方法和使用 typeof 来排除函数。 属性名出现的顺序是不确定的。如果想要属性名以特希ing的属性出现，最好的方法是避免使用 for in 语句，而是船舰一个数组，在其中以正确的顺序包含属性名。如下： 12345678910var i;va properties = [ 'first-name', 'middle-name', 'last-name', 'profession']for (i = 0; i &lt; properties.length; i ++) { document.writeIn(properties[i] + ':' + obj[properties[i]])} 删除delete 运算符用来删除对象的属性，它不会触及原型链中的任何对象。但是有可能会让来自原型链中的属性透现出来。因为对象检索属性是先检索对象本身，在检索原型链，若对象中的属性被删除，那么将会显示在原型链中的同名属性。 减少全局变量最小化全局变量的方法之一就是为你的应用之船建一个唯一的全局变量使用一个对象将所有变量包含在内，将该变量成为应用容器。 第四章 函数对于 JavaScript来说，所谓编程，就是将一组需求分解成一组函数与数据结构的技能 函数对象JS 中的函数是对象。对象是”名/值”对的集合，并且拥有一个连接到原型对象的隐藏链接。 对象字面量产生的对象连接到 Object.prototype 函数对象连接到 Function.prototype(该原型对象本身连接 到 Object.prototype) 每个函数对象在创建时都配有一个 prototype 属性。它的值是一个拥有 constructor 属性，并且该属性的值为函数本身 的对象。这和隐藏链接到 Function.prototype 完全不同。 注意，只有函数对象在创建时才会产生一个 prototype 属性，此外，函数对象也会有一个隐藏连接指向 Function.prototype。对象字面量不会产生 prototype 属性，只会有一个隐藏连接指向 Object.prototype。 调用在 JS 中一共有4种调用模式： 方法调用模式；函数调用模式；构造器调用模式；apply 调用模式。这些模式在如何初始化关键参数 this 上存在差异。 方法调用模式当函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时， this 被绑定到该对象。如果调用表达式 包含一个提取属性的动作(即包含一个 .点表达式或者 []下标表达式)，那么他就是被当作一个方法调用。 方法可以使用 this 访问自己所属的对，所以他能从对象中取值或者对对象进行修改。通过 this 可取的它所属对象的上下文的方法称为 公共方法 函数调用模式当一个函数并非一个对象的属性时，那么他就是被当作一个函数来调用的。类似 var sum = add(3, 4) 依此模式调用函数时， this 被绑定到全局对象。 构造器调用模式JS 是一门基于原型继承的语言。这意味着对象可以直接从其他对象继承属性。该语言是 无类型的。 如果在一个函数前面带上 new 来调用，那么背地里将会创建一个 连接到该函数的 prototype 成员的新对象，同时 this 会被绑定到那个新对象上。 一个函数，如果创建的目的就是希望结合 new 前缀来调用，那他就被称为构造器函数。如果调用构造器函数时没有使用 new 运算符，可能会发生预料之外的事情。 Apply 调用模式apply 方法让我们构建一个参数数组传递给调用函数。允许我们选择 this 的值。 参数函数可以通过 类数组参数 arguments 访问所有的他被调用时传递给它的参数列表。 注意，arguments并不是一个真正的数组，只是一个 类似数组的对象。它拥有一个 length 属性，但没有任何数组的方法。 返回一个函数总是会返回一个值。如果没有指定返回值，则返回 Undefined 如果函数调用时在前面加上了 new 前缀，且返回值不是一个对象，则返回 this（该新对象）","link":"/posts/5325c245/"},{"title":"jQuery基础","text":"jQuery123$(document).ready(function() { }) .addClass()方法 .removeClass()方法 .css()方法，直接修改 Css,接收两个参数，修改的属性和修改的值 .prop()方法，直接修改元素属性，接收两个参数，修改的属性和修改的值 .html()方法，不传递参数则获取目标元素的内容(包括 html标签)，如传递参数，则直接修改元素内容，原有内容会被替换，参数是任何字符串，可以将 html标签以字符串形式传递进去，从而实现内嵌 html元素。相当于原生 DOM的 .innerhtml() .text()方法，不传递参数则获取目标元素的内容(不包括 html标签，只有文本内容)，如传递参数直接修改元素内容，原有内容会被替换，参数是任何字符串，不会转变为 html标签。相当于原生 DOM的 .innertext() getJSON()方法：用于获取 JSON数据，接收2个参数，第一个是 JSON文件的存储位置，第二个是一个回调函数。如下所示: 123$.getJSON(\"/json/cats.json\", function(json) { $(\".message\").html(JSON.stringify(json));}); .remove() .appendTo()方法，将目标元素添加到参数（另一个元素）中（排在最后） .clone()方法，复制目标元素，返回目标元素，不接受参数 .parent()返回直接父元素 .children()返回所有的直接子元素 nth-child(n) 父元素下的第n个子元素，n必须大于0，索引都是从1开始。 target:nth-child(n) 返回属于目标元素的父元素的第n个 target元素 如·$(&quot;.target:nth-child(3)&quot;).addClass(&quot;animated bounce&quot;); //给.target元素的父元素，的第3个.target元素添加Class target:odd|:even 选择器:返回所有奇数|偶数的 target元素 索引值从 0 开始，第一个元素是偶数 (0)，第二个元素是奇数 (1)，以此类推。 事件click() dblclick() mouseenter() mouseleave() mousedown() mouseup() hover() blur() focus() 常用效果隐藏和显示$(selector).hide(speed, callback) $(selector).show(speed, callback) $(selector).toggle(speed, callback) 淡入淡出$(selector).fadeIn(speed, callback) $(selector).fadeOut(speed, callback) $(selector).fadeToggle(speed, callback) $(selector).fadeTo(speed, opacity, callback): fade到 opacity指定的程度 滑动$(selector).slideDown(speed, callback) $(selector).slideUp(speed, callback) $(selector).slideToggle(speed, callback) 动画$(selector).animate({params},speed,callback)： 必需的 params参数定义形成动画的 CSS属性， params参数是一个 css对象，可以操作多个属性。 jQuery提供针对动画的队列功能。 这意味着如果您在彼此之后编写多个 animate() 调用，jQuery会创建包含这些方法调用的”内部”队列。然后逐一运行这些 animate调用。 DEMO如下： 1234567$(\"button\").click(function(){ var div=$(\"div\"); div.animate({height:'300px',opacity:'0.4'},\"slow\"); div.animate({width:'300px',opacity:'0.8'},\"slow\"); div.animate({height:'100px',opacity:'0.4'},\"slow\"); div.animate({width:'100px',opacity:'0.8'},\"slow\");}); 停止动画$(selector).stop(stopAll,goToEnd)可选的 stopAll参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 DOM操作获得与设置内容 - text()、html() 以及 val() text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML标记） val() - 设置或返回表单字段的值都可接受参数，参数作为将会替换其中的内容 获取与设置属性$(selector).attr(prop, value)，第二个参数 value可为空，即获取属性值; 给定的第二个参数可以修改属性的值 添加元素 append(elem) - 在被选元素的结尾插入内容 prepend(elem) - 在被选元素的开头插入内容 after(elem) - 在被选元素之后插入内容 before(elem1,elem2, …) - 在被选元素之前插入内容可添加多个参数，即为添加若干新元素 删除元素 remove() - 删除被选元素（及其子元素）， remove() 方法也可接受一个参数，允许您对被删元素进行过滤。 empty() - 从被选元素中删除子元素 获取并设置 CSS类 addClass() - 向被选元素添加一个或多个类, 用 ,分隔 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 css(“propertyname“) ,可返回指定的 CSS属性的值 css(“propertyname“,”value“);设置指定的 CSS属性 css({“propertyname“:”value“,”propertyname“:”value“,…}) 设置多个 CSS属性 尺寸方法 设置或返回元素的高度|宽度（不包括内边距、边框或外边距） width() height() 设置或返回元素的高度|宽度（包括内边距） innerWidth() innerHeight() 设置或返回元素的高度|宽度（包括内边距和边框），可接受一个 boolean参数，默认为 false, 当为 true时，元素的高度|宽度（包括外边距，内边距和边框） outerWidth() outerHeight() 遍历向上遍历 DOM树（祖先） parent() 返回被选元素的直接父元素。该方法只会向上一级对 DOM树进行遍历。 parents() 返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (&lt;html&gt;)。 可使用可选参数来过滤对祖先元素的搜索。如 $(&quot;span&quot;).parents(&quot;ul&quot;);，返回所有 &lt;span&gt;元素的所有祖先，并且它是 &lt;ul&gt; 元素 parentsUntil()返回介于两个给定元素之间的所有祖先元素。如 $(&quot;span&quot;).parentsUntil(&quot;div&quot;)返回介于 &lt;span&gt; 与 &lt;div&gt; 元素之间的所有祖先元素 向下遍历 DOM树(后代) children() 返回被选元素的所有直接子元素。只会向下一级对 DOM树进行遍历。 find() 返回被选元素的后代元素，一路向下直到最后一个后代。 在 DOM树中水平遍历(兄弟) siblings() 返回被选元素的所有同胞元素。 next() 返回被选元素的下一个同胞元素。 nextAll() 返回被选元素的所有跟随的同胞元素。 nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素。 prev() 返回被选元素的上一个同胞元素。 prevAll() 返回被选元素的所有之前的同胞元素。 prevUntil() 返回介于两个给定参数之间的所有跟随的同胞元素以上都可以使用参数（CSS选择器）进行过滤 缩小搜索元素的范围（过滤） first() 方法返回被选元素的首个元素。 last() 方法返回被选元素的最后一个元素。 eq() 方法返回被选元素中带有指定索引号的元素。 filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 not() 方法返回不匹配标准的所有元素。与 fliler方法相反 jQuery AJAXAJAX load() 方法$(selector).load(URL,data,callback) 必需的 URL参数规定您希望加载的 URL。可以使用空白符 space分隔，将 jQuery选择器添加到 URL参数中。 下面的例子把 “demo_test.txt” 文件中 id=”p1” 的元素的内容，加载到指定的 &lt;div&gt; 元素中：$(&quot;#div1&quot;).load(&quot;demo_test.txt #p1&quot;) 可选的 data参数规定与请求一同发送的查询字符串键/值对集合。 可选的 callback参数是 load() 方法完成后所执行的函数名称。回调函数可以设置不同的参数： responseTxt -包含调用成功时的结果内容 statusTXT -包含调用的状态 xhr -包含 XMLHttpRequest对象 AJAX get() 和 post() 方法jQuery$.get() 方法$.get() 方法通过 HTTP GET请求从服务器上请求数据。$.get(URL,callback) 参数说明： 必需的 URL参数规定您希望请求的 URL。 可选的 callback参数是请求成功后所执行的函数名。回调函数的参数： 第一个回调参数存有被请求页面的内容， 第二个回调参数存有请求的状态。DEMO： 12345$(\"button\").click(function(){ $.get(\"demo_test.php\",function(data,status){ alert(\"数据: \" + data + \"\\n状态: \" + status); });}); jQuery$.post() 方法$.post() 方法通过 HTTP POST请求向服务器提交数据。$.post(URL,data,callback) 参数说明： 必需的 URL参数规定您希望请求的 URL。 可选的 data参数规定连同请求发送的数据。 可选的 callback参数是请求成功后所执行的函数名。回调函数的参数： 第一个回调参数存有被请求页面的内容， 第二个参数存有请求的状态。DEMO： 12345678910$(\"button\").click(function(){ $.post(\"/try/ajax/demo_test_post.php\", { name:\"菜鸟教程\", url:\"http://www.runoob.com\" }, function(data,status){ alert(\"数据: \\n\" + data + \"\\n状态: \" + status); });}); 如何在页面上同时使用 jQuery和其他框架？可以创建自己的简写。noConflict() 可返回对 jQuery的引用，您可以把它存入变量，以供稍后使用。 123456var jq = $.noConflict();jq(document).ready(function(){ jq(\"button\").click(function(){ jq(\"p\").text(\"jQuery 仍然在工作!\"); });});","link":"/posts/889563/"},{"title":"JS 12个重要概念以及reduce方法详解","text":"JavaScript方面12个 JS概念来源: infoQ 了解这 12 个概念，让你的 JavaScript 水平更上一层楼 1. 变量赋值（值与引用）JavaScript总是按照值来给变量赋值。当指定的值是 JavaScript的五种原始类型之一（即 Boolean、null、undefined、String和 Number）时，将为变量分配实际的值。但是，当指定的值是 Array、Function或 Object时，将为变量分配内存的对象引用。 2. 闭包闭包是一种重要的 JavaScript模式，可用于访问私有变量。在下面的示例中，createGreeter返回一个匿名函数，这个函数可以访问参数 greeting（在这里是“Hello”）。在后续的调用中，sayHello将有权访问这个 greeting！ 12345678function createGreeter(greeting) { return function(name) { console.log(greeting + ', ' + name); }}const sayHello = createGreeter('Hello');sayHello('Joe');// Hello, Joe 在一个更真实的场景中，你可以设想一个初始化函数 apiConnect(apiKey)，它返回一些使用 API密钥的方法。在这种情况下，只需要提供一次 apiKey即可。 12345678910111213141516171819function apiConnect(apiKey) { function get(route) { return fetch(`${route}?key=${apiKey}`); } function post(route, params) { return fetch(route, { method: 'POST', body: JSON.stringify(params), headers: { 'Authorization': `Bearer ${apiKey}` } }) } return { get, post }}const api = apiConnect('my-secret-key');// No need to include the apiKey anymoreapi.get('http://www.example.com/get-endpoint');api.post('http://www.example.com/post-endpoint', { name: 'Joe' }); 3. 解构JavaScript参数解构是一种从对象中提取属性的常用方法。 1234567const obj = { name: 'Joe', food: 'cake'}const { name, food } = obj;console.log(name, food);// 'Joe' 'cake' 如果需要以其他名称来提取属性，可以使用以下格式来指定它们。 1234567const obj = { name: 'Joe', food: 'cake'}const { name: myName, food: myFood } = obj;console.log(myName, myFood);// 'Joe' 'cake' 在下面的示例中，解构被用来将 person对象传给 introduce函数。换句话说，解构可以（并且经常）直接用于提取传给函数的参数。如果你熟悉 React，可能已经见过这个！ 123456789const person = { name: 'Eddie', age: 24}function introduce({ name, age }) { console.log(`I'm ${name} and I'm ${age} years old!`);}console.log(introduce(person));// \"I'm Eddie and I'm 24 years old!\" 详细可看阮一峰的 ES6 入门 4. 展开（spread）语法在下面的示例中，Math.max不能直接接受 arr数组，因为它的参数不是数组类型，但可以以数组中的各个元素作为参数。展开运算符 …可用于提取数组的各个元素。 1234const arr = [4, 6, -1, 3, 10, 4];const max = Math.max(...arr);console.log(max);// 10 5.变长参数 (rest) 语法可以用它将 传给函数的 任意数量的 参数放入数组中 12345function myFunc(...args) { console.log(args[0] + args[1]);}myFunc(1, 2, 3, 4);// 3 6.数组方法JavaScript数组方法通常可以为你提供令人难以置信的优雅方式来执行所需的数据转换 map、filter、reduce map:返回一个数组，其中每个元素都是用指定函数进行过转换。 1234const arr = [1, 2, 3, 4, 5, 6];const mapped = arr.map(el =&gt; el + 20);console.log(mapped);// [21, 22, 23, 24, 25, 26] filter:返回一个数字，只有当指定函数返回 true时，相应的元素才会被包含在数组内。 1234const arr = [1, 2, 3, 4, 5, 6];const filtered = arr.filter(el =&gt; el === 2 || el === 4);console.log(filtered);// [2, 4] reduce：基于给定函数累加值。语法： arr.reduce(callback,[initialValue]) callback（执行数组中每个值的函数，包含四个参数） previousValue（上一次调用回调返回的值，或者是提供的初始值（initialValue）） currentValue（数组中当前被处理的元素）index（当前元素在数组中的索引） array（调用 reduce的数组） initialValue（作为第一次调用 callback的第一个参数。） 基本应用如下： 123456789var items = [10, 120, 1000];// our reducer functionvar reducer = function add(sumSoFar, item) { return sumSoFar + item; };// do the jobvar total = items.reduce(reducer, 0);console.log(total); // 1130 reduce函数的返回结果类型和传入的初始值相同，上个实例中初始值为 number类型，同理，初始值也可为 object类型。 123456789101112var items = [10, 120, 1000];// our reducer functionvar reducer = function add(sumSoFar, item) { sumSoFar.sum = sumSoFar.sum + item; return sumSoFar;};// do the jobvar total = items.reduce(reducer, {sum: 0});console.log(total); // {sum:1130} reduce进阶应用:详见思否 数组reduce方法的高级技巧 by 风雨后见彩虹 我们看下面一个例子。 某同学的期末成绩如下表示 1234567891011121314var result = [ { subject: 'math', score: 88 }, { subject: 'chinese', score: 95 }, { subject: 'english', score: 80 }]; 如何求该同学的总成绩？ 我们可以使用 reduce来搞定这个问题 123var sum = result.reduce(function(prev, cur) { return cur.score + prev;}, 0); 这个时候，我们给 reduce参数添加了第二个参数。通过打印我发现设置了这个参数之后，reduce遍历便已经从第一项开始了。 这第二个参数就是设置 prev的初始类型和初始值，比如为0，就表示 prev的初始值为 number类型，值为0，因此，reduce的最终结果也会是 number类型。 因为第二个参数为累计结果的初始值，因此假设该同学因为违纪被处罚在总成绩总扣10分，只需要将初始值设置为-10即可。 123var sum = result.reduce(function(prev, cur) { return cur.score + prev;}, -10); 假如该同学的总成绩中，各科所占的比重不同，分别为50%，30%，20%，我们应该如何求出最终的权重结果呢？ 解决方案如下： 12345678910111213141516var dis = { math: 0.5, chinese: 0.3, english: 0.2}var sum = result.reduce(function(prev, cur) { console.log(prev); return cur.score + prev;}, -10);var qsum = result.reduce(function(prev, cur) { return prev + cur.score * dis[cur.subject]}, 0)console.log(sum, qsum); 为了计算出权重之后的总值，我们在回调函数内部修改了数组当前项，是使他和权重比例相关联，并重新返回一个一样的回调函数，将新修改的当前项传入，就和之前的例子是一样的了。 如何知道一串字符串中每个字母出现的次数？ 我们同样可以使用 reduce来解决这个问题 我们在 reduce的第二个参数里面初始了回调函数第一个参数的类型和值，将字符串转化为数组，那么迭代的结果将是一个对象，对象的每一项 key值就是字符串的字母。 123456var arrString = 'abcdaabc';arrString.split('').reduce(function(res, cur) { res[cur] ? res[cur] ++ : res[cur] = 1 return res;}, {}) 由于可以通过第二参数设置叠加结果的类型初始值，因此这个时候 reduce就不再仅仅只是做一个加法了，我们可以灵活的运用它来进行各种各样的类型转换，比如将数组按照一定规则转换为对象，也可以将一种形式的数组转换为另一种形式的数组，大家可以动手去尝试一样。 1234[1, 2].reduce(function(res, cur) { res.push(cur + 1); return res;}, []) 这种特性使得 reduce在实际开发中大有可为！但是需要注意点，在 ie9一下的浏览器中，并不支持该方法 ！ 此外，使用 reduce方法可以完成多维度的数据叠加。如上例中的初始值{sum: 0}，这仅仅是一个维度的操作，如果涉及到了多个属性的叠加，如{sum: 0,totalInEuros: 0,totalInYen: 0}，则需要相应的逻辑进行处理。 在下面的方法中，采用分而治之的方法，即将 reduce函数第一个参数 callback封装为一个数组，由数组中的每一个函数单独进行叠加并完成 reduce操作。所有的一切通过一个 manager函数来管理流程和传递初始参数。 1234567891011var manageReducers = function(reducers) { return function(state, item) { return Object.keys(reducers).reduce( function(nextState, key) { reducers[key](state, item); return state; }, {} ); }}; 上面就是 manager函数的实现，它需要 reducers对象作为参数，并返回一个 callback类型的函数，作为 reduce的第一个参数。在该函数内部，则执行多维的叠加工作（Object.keys（））。 通过这种分治的思想，可以完成目标对象多个属性的同时叠加，完整代码如下： 123456789101112131415161718192021222324252627282930var reducers = { totalInEuros : function(state, item) { return state.euros += item.price * 0.897424392; }, totalInYen : function(state, item) { return state.yens += item.price * 113.852; }};var manageReducers = function(reducers) { return function(state, item) { return Object.keys(reducers).reduce( function(nextState, key) { reducers[key](state, item); return state; }, {} ); }};var bigTotalPriceReducer = manageReducers(reducers);var initialState = {euros:0, yens: 0};var items = [{price: 10}, {price: 120}, {price: 1000}];var totals = items.reduce(bigTotalPriceReducer, initialState);console.log(totals); find、findIndex、indexOf find：返回与指定条件匹配的第一个实例，不会继续查找其他匹配的实例。 1234const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];const found = arr.find(el =&gt; el &gt; 5);console.log(found);// 6 虽然 5 之后的元素都符合条件，但只返回第一个匹配的元素。 findIndex：这与 find几乎完全相同，但不返回第一个匹配的元素，而是返回第一个匹配元素的索引。 1234const arr = ['Nick', 'Frank', 'Joe', 'Frank'];const foundIndex = arr.findIndex(el =&gt; el === 'Frank');console.log(foundIndex);// 1 indexOf：与 findIndex几乎完全相同，但它的参数不是一个函数，而是一个简单的值。 1234const arr = ['Nick', 'Frank', 'Joe', 'Frank'];const foundIndex = arr.indexOf('Frank');console.log(foundIndex);// 1 push、pop、shift、unshift push：这是一个相对简单的方法，它将一个项添加到数组的末尾。它就地修改数组，函数本身会返回数组的新长度。 123456let arr = [1, 2, 3, 4];const pushed = arr.push(5);console.log(arr);// [1, 2, 3, 4, 5]console.log(pushed);// 5 pop：从数组中删除最后一项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。 123456let arr = [1, 2, 3, 4];const popped = arr.pop();console.log(arr);// [1, 2, 3]console.log(popped);// 4 shift：从数组中删除第一个项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。 123456let arr = [1, 2, 3, 4];const shifted = arr.shift();console.log(arr);// [2, 3, 4]console.log(shifted);// 1 unshift：将一个或多个元素添加到数组的开头。同样，它也是就地修改数组。与其他方法不同的是，函数本身返回数组最新的长度。 123456let arr = [1, 2, 3, 4];const unshifted = arr.unshift(5, 6, 7);console.log(arr);// [5, 6, 7, 1, 2, 3, 4]console.log(unshifted);// 7 splice、slice、sort splice：通过删除或替换现有元素或者添加新元素来修改数组的内容。这个方法也是就地修改数组。下面的代码示例的意思是：在数组的位置 1 上删除 0 个元素，并插入 b。 12let arr = ['a', 'c', 'd', 'e'];arr.splice(1, 0, 'b') slice：从指定的起始位置和结束位置之前返回数组的浅拷贝。如果未指定结束位置，则返回数组的其余部分。这个方法不会修改数组，只是返回所需的子集。 123456let arr = ['a', 'b', 'c', 'd', 'e'];const sliced = arr.slice(2, 4);console.log(sliced);// ['c', 'd']console.log(arr);// ['a', 'b', 'c', 'd', 'e'] sort：根据提供的函数对数组进行排序。这个方法就地修改数组。如果函数返回负数或 0，则顺序保持不变。如果返回正数，则交换元素顺序。 12345let arr = [1, 7, 3, -1, 5, 7, 2];const sorter = (firstEl, secondEl) =&gt; firstEl - secondEl;arr.sort(sorter);console.log(arr);// [-1, 1, 2, 3, 5, 7, 7] 7. 生成器详看阮一峰es6 入门生成器函数指定下一次调用 next() 时会生成什么 value。既可以生成有限数量的 value（最后调用 next() 会返回 undefined），也可以使用循环生成无限数量的 value。 1234567891011121314function* greeter() { yield 'Hi'; yield 'How are you?'; yield 'Bye';}const greet = greeter();console.log(greet.next().value);// 'Hi'console.log(greet.next().value);// 'How are you?'console.log(greet.next().value);// 'Bye'console.log(greet.next().value);// undefined 使用生成器生成无限个值： 12345678910111213function* idCreator() { let i = 0; while (true) yield i++;}const ids = idCreator();console.log(ids.next().value);// 0console.log(ids.next().value);// 1console.log(ids.next().value);// 2// etc... === 与 ==一定要知道 JavaScript中 === 运算符和 == 运算符之间的区别！== 运算符在比较之前会进行类型转换，而 === 运算符在比较之前不会进行类型转换。 1234console.log(0 == '0');// trueconsole.log(0 === '0');// false 9. 对象比较JavaScript新手容易犯的一个错误是直接比较对象。变量一般是指向内存中对象的引用，而不是对象本身！比较对象的一种方法是将它们转换成 JSON字符串。但这样做有一个缺点：无法保证对象属性的顺序！一种更安全的方法是使用专门进行深度对象比较的库（例如 lodash的 isEqual，https://lodash.com/docs#isEqual）。下面的对象看起来相同，但它们实际上指向不同的引用。 1234const joe1 = { name: 'Joe' };const joe2 = { name: 'Joe' };console.log(joe1 === joe2);// false 相反，下面的结果为 true，因为使用其中一个对象为另一个对象赋值，它们都指向相同的引用（内存中只有一个对象）。 1234const joe1 = { name: 'Joe' };const joe2 = joe1;console.log(joe1 === joe2);// true 10. 回调函数很多人都被 JavaScript回调函数吓倒了！它们其实很简单，请看下面的例子。console.log函数作为回调传给 myFunc，并在 setTimeout完成时执行。 1234567function myFunc(text, callback) { setTimeout(function() { callback(text); }, 2000);}myFunc('Hello world!', console.log);// 'Hello world!' 11. promise详看阮一峰的es6 入门一旦你理解了 JavaScript回调，很快就会发现自己陷入了“回调地狱”中。这个时候可以使用 promise！将异步逻辑包装在 promise中，使用“then”来处理成功的情况，使用“catch”来处理异常。 1234567891011121314151617181920const myPromise = new Promise(function(res, rej) { setTimeout(function(){ if (Math.random() &lt; 0.9) { return res('Hooray!'); } return rej('Oh no!'); }, 1000);});myPromise .then(function(data) { console.log('Success: ' + data); }) .catch(function(err) { console.log('Error: ' + err); }); // If Math.random() returns less than 0.9 the following is logged:// \"Success: Hooray!\"// If Math.random() returns 0.9 or greater the following is logged:// \"Error: On no!\" 12. Async/Await详看阮一峰的es6 入门在掌握了 promise的用法后，你可能也会喜欢 async await，它只是一种基于 promise的“语法糖”。在下面的示例中，我们创建了一个 async函数，并 await greeter promise。 123456789const greeter = new Promise((res, rej) =&gt; { setTimeout(() =&gt; res('Hello world!'), 2000);})async function myFunc() { const greeting = await greeter; console.log(greeting);}myFunc();// 'Hello world!'","link":"/posts/66c0dcbe/"},{"title":"JS类型检测","text":"类型检测JS 中有多个可以检测数据类型的方法，比如： typeof instanceof constructor Object.prototype.toString.call(instance) 但是它们基本都有一些不足，接下来就让我来一一说明一下 typeof我们经常使用 typeof 判断数据的类型，其性能很高，但是它有两个致命的缺陷： typeof null === 'object' // =&gt; true 对 null 使用 typeof 会返回 object 这是因为 typeof 是浏览器底层基于二进制对值进行判断，对象类型是用 000 开头的二进制储存的，而 null 的二进制值是全为 0，因此它会被 typeof 判断为 object 对除了 Function 以外的原生对象类型使用 typeof，其都只返回一个 object instanceofa instanceof b 可以被认为判断在 a 的原型链上是否存在 b 的原型对象，可以简单的认为判断 a 是否为 b 的实例对象。话虽如此，但是因为在 JS 中，我们可以随意改变原型的指向，因此此方法并不一定准确，比如 1234let fn = function () {};fn.prototype = Array.prototype;let f = new fn();console.log(f instanceof Array); // =&gt; true 此外， instanceof 无法判断基本类型在上述代码中，fn 是一个函数，但是我们通过将其的原型对象指定为 Array 的原型对象，导致 Array 的原型对象出现在 fn 的实例的原型链上，因此返回了 true。 在我们知道了 instanceof 的原理之后，我们可以自己实现一个 instanceof 12345678910111213function myInstanceof(instance, classFunc) { let classFuncProto = classFunc.prototype; // 获取父类的原型 let proto = Object.getPrototype(proto); // 获取实例的原型 // 递归获取实例原型链上的原型 while (true) { // 当实例原型链原型走到了 Object.prototype 即 null 时， // 表示整个原型链都不存在父类原型 if (proto === null) return false; if (proto === classFuncProto) return true; proto = Object.getPrototype(proto); }} constructor正如我们所知，一个实例的 constructor 等于其构造函数的 constructor，因此我们可以根据这个原理来判断对象的数据类型。constructor 但是，它也和 instanceof 一样，JavaScript 自身并不能确保正确的 constructor 函数值。它只存在于函数的默认 prototype 中，可以被随时改变 12345678let fn = function () {};let f = new fn();f.constructor === fn; // =&gt; true// 修改 fn 的构造函数指向fn.prototype.constructor = Array;f.constructor === fn; // =&gt; falsef.constructor === Array; // =&gt; true Object.prototype.toString.call(instance)其返回的值可能是: [object Number/String/Boolean/Null/Undefined/Symbol/Object/Array/RegExp/Date/Function]这个方法可以说是究极方法了，这个方法用的是原型链最顶端的 toString 方法，通过调用 call 将 this 绑定到要检测的对象身上，会返回一个字符串”[object Type ]”，Type 是判断出来的类型。 该方法的缺点在于代码太长，如果判断基本类型的话，我们也可以直接使用 typeof 来检测，因此我们可以考虑优化一下： 1234567891011121314var class2type = {}ve toString = class2type.toString// 设置映射表['Boolean','Number','String','Function','Array','Date','RegExp','Object','Error','Symbol'].forEach(name =&gt; { class2type[`[object ${name}]`] =name.toLowerCase()})function toType(obj) { if (obj == null) { return obj + '' } return (typeof obj === 'object' || typeof obj === 'function') ? class2type[toString.call(obj)] : typeof obj}","link":"/posts/b6a5ef32/"},{"title":"Js立即执行函数写法以及FCC中学到的css部分用法和语义化html笔记","text":"js中 (function(){…})()立即执行函数写法理解javascript和其他编程语言相比比较随意，所以 javascript代码中充满各种奇葩的写法，有时雾里看花，当然，能理解各型各色的写法也是对 javascript语言特性更进一步的深入理解。 ( function(){…} )()和( function (){…} () )是两种javascript立即执行函数的常见写法，最初我以为是一个括号包裹匿名函数，再在后面加个括号调用函数，最后达到函数定义后立即执行的目的，后来发现加括号的原因并非如此。要理解立即执行函数，需要先理解一些函数的基本概念。 函数声明、函数表达式、匿名函数 函数声明：function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。 匿名函数：function () {}; 使用 function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。 函数声明和函数表达式不同之处在于，一、Javascript引擎在解析 javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到 Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式，二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以 fnName()形式调用 。以下是两者差别的两个例子。 1234567891011fnName();function fnName(){ ...}//正常，因为‘提升’了函数声明，函数调用可在函数声明之前fnName();var fnName=function(){ ...}//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后 123456789101112131415var fnName=function(){ alert('Hello World');}();//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数function fnName(){ alert('Hello World');}();//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用function(){ console.log('Hello World'); }();//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名 在理解了一些函数基本概念后，回头看看 ( function(){…} )()和 ( function (){…} () )这两种立即执行函数的写法，最初我以为是一个括号包裹匿名函数，并后面加个括号立即调用函数，当时不知道为什么要加括号，后来明白，要在函数体后面加括号就能立即调用，则这个函数必须是函数表达式，不能是函数声明。 1234567891011121314151617181920212223(function(a){ console.log(a); //firebug输出123,使用（）运算符})(123);(function(a){ console.log(a); //firebug输出1234，使用（）运算符}(1234));!function(a){ console.log(a); //firebug输出12345,使用！运算符}(12345);+function(a){ console.log(a); //firebug输出123456,使用+运算符}(123456);-function(a){ console.log(a); //firebug输出1234567,使用-运算符}(1234567);var fn=function(a){ console.log(a); //firebug输出12345678，使用=运算符}(12345678) 可以看到输出结果，在 function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了 javascript引擎识别函数表达式和函数声明的歧义，告诉 javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。 加括号是最安全的做法，因为！、+、-等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。 不过这样的写法有什么用呢？ javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 javascript函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以(function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。 JQuery使用的就是这种方法，将JQuery代码包裹在( function (window,undefined){…jquery代码…} (window)中，在全局作用域中调用 JQuery代码时，可以达到保护 JQuery内部变量的作用。 文属个人理解整理，如有错误之处欢迎指出，文中观点参考于： 《javascript权威指南》、《javascript高级程序设计》ref:https://www.cnblogs.com/chris-oil/p/4862083.html freecodecampcss:. 渐变：bcakground:linear-gradient(deg, color,color). 重复渐变：repeating-linear-gradient(deg, color \\*px, color \\*px). 背景插入图片：background: utl('url'). 按比例缩放：transform:scale() //善于在 css中对伪类的使用. 使元素倾斜：transform: skewX(deg)/skewY(deg) == rotate(). 阴影：box-shadow: offset-x, offset-y, blur-radius, spread-radius,color ::before and ::after伪类作用：These pseudo-elements are used to add something before or after a selected element. they must have a defined content property. This property is usually used to add things like a photo or text to the selected element. When the ::before and ::after pseudo-elements are used to make shapes, the content property is still required, but it’s set to an empty string. @keyframes . @keyframes最重要的两个属性：animation-name动画名称和 animation-duration(.持续时间)，进行设定 @keyframes之前，需要先设置好动画名称与时间，然后使用 @keyframes animation-name{}进行设置. 动画完成后保持该状态：animation-fill-mode: forwards;（该代码需放置在 @keyframes外面）. 设置动画播放次数：animation-iteration-count: ``number;(可设置为 infinite，无线播放)，同样放置在动画名称那一块. 动画播放速度： animation-timing-function：有默认的关键词 （ease(先快后慢),ease-in(加速),ease-out(减速), linear（线性），还有一个 cubic-bezier(x1,y1,x2,y2)（贝塞尔曲线），贝塞尔曲线用来自定义速度 语义化 html根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 12345678910111213141516&lt;main&gt;&lt;article&gt;&lt;section&gt; 一般与容器有关联的用&lt;section&gt;，无关联的用&lt;div&gt;&lt;header&gt; 一般用于页眉&lt;footer&gt; 一般用于页脚&lt;nav&gt; 一般用于导航栏&lt;lable for=''&gt; 一般与input连用，for的值为相关的input的id值，该标签用于拓展input事件的选定范围&lt;input type=''&gt;type有多种，如:date;text;button等&lt;audio&gt;&lt;figure&gt; 一般用于图片及图片描述 &lt;figcaption&gt;名字&lt;figcaption&gt; &lt;img &gt;&lt;/figure&gt;表单相关：fieldset定义一个表单容器，legend标签内容用于显示容器名字&lt;fieldset&gt;&lt;legend&gt;名字&lt;/legend&gt;&lt;/fieldset&gt; 关于 &lt;input&gt;标签的type属性： 值 描述 button 定义可点击的按钮（通常与 JavaScript一起使用来启动脚本）。 checkbox 定义复选框。 colorNew 定义拾色器。 dateNew 定义 date控件（包括年、月、日，不包括时间）。 datetimeNew 定义 date和 time控件（包括年、月、日、时、分、秒、几分之一秒，基于 UTC时区）。 datetime-localNew 定义 date和 time控件（包括年、月、日、时、分、秒、几分之一秒，不带时区）。 emailNew 定义用于 e-mail地址的字段。 file 定义文件选择字段和 “浏览…” 按钮，供文件上传。 hidden 定义隐藏输入字段。 image 定义图像作为提交按钮。 monthNew 定义 month和 year控件（不带时区）。 numberNew 定义用于输入数字的字段。 password 定义密码字段（字段中的字符会被遮蔽）。 radio 定义单选按钮。 rangeNew 定义用于精确值不重要的输入数字的控件（比如 slider控件）。 reset 定义重置按钮（重置所有的表单值为默认值）。 searchNew 定义用于输入搜索字符串的文本字段。 submit 定义提交按钮。 telNew 定义用于输入电话号码的字段。 text 默认。定义一个单行的文本字段（默认宽度为 20 个字符）。 timeNew 定义用于输入时间的控件（不带时区）。 urlNew 定义用于输入 URL的字段。 weekNew 定义 week和 year控件（不带时区）。 任何元素都有的属性： accesskey，用来自定义快捷键 focus到该元素 tabindex=”0” 可换成其他正数表示顺序，1为第一个被 focus的，表示可以用 table键 focus","link":"/posts/6d3fcd8e/"},{"title":"Js面向对象、DRY原则以及函数式编程","text":"Js高级程序设计Don’t Repeat Yourself (DRY)原则 面向对象对象的属性类型ECMAScript中有两种对象属性：数据属性和访问器属性，可以通过对象字面量方法或者 Objet.defineProperty()方法设置数据属性，但是访问器属性只能通过 Object.defineProperty()设置。可以通过 Object.defineProperties()方法同时设置多个属性 数据属性包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个描述其行为的‘特性’： [[Configurable]]:表示能否通过 delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问其属性。 [[Enumerable]]:表示能否通过 for-in循环返回属性 [[Writable]]：表示能否修改属性的值 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读，写入的时候，把新值保存在这个位置。 要修改属性的特性，要是用 Object.defineProperty()方法，接收三个参数：属性所在的对象，属性名和一个描述符对象（描述符对象是:Configurable,Writable,Enumerable,value之一）；看代码 123456789101112var person = {};Object.defineProperty(person, 'name', { configurable: false value: 'Nick' })delete persone.name //无效Object.defineProperty(person, 'name', { configurable: true value: 'nick' }) //抛出错误 访问器属性访问器属性不包含数值：它们包含一对 setter和 getter函数（非必须）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter值并传入新值，这个函数负责决定如何处理数据。 [[configurable]]:同数据属性2.[[Enumerable]]: 同数据属性 [[Get]]：读取属性时调用的函数，默认值为 undefined [[Set]]： 写入属性时调用的函数，默认值为 undefined 读取属性的特性使用 Object.getOwnPRopertyDescriptor()方法，可以去的给定属性的描述符。接收两个参数：属性所在的对象和尧都区其描述符的属性名称，如下： 1234567891011var book = {}Object.defineProperties(book, { _year: { value: 2004 }, edition: { value: 1 } })var descriptor = Object.getOwnPRopertyDescriptor(book, '_year')alert(describes.value) //2004 创建对象工厂模式用函数来封装 以特定接口创建对象 的细节。但无法解决对象识别问题（怎样知道一个对象的类型） 1234567891011function creatPerso(name, age, job) { var o = new Object() o.name = Name o.age = age o.job = job o.sayName = function() { alert(this.name) } return o}var per1 = creatPerso('nick', 29,'job') 简单的原型语法需要重新设定 constructor 123456function Person() {}Person.prototype { constructor: Person, name:'Nick',} 原型的动态性可以随时为圆形添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，再调用以前的属性和方法就会出现错误。因为调用构造函数时回尉氏里添加一个指向最初原型的[[property]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。注意： 实例中的指针仅指向原型，而不指向构造函数。 #freeCodeCamp Object.create()介绍Object.create(null) 创建的对象是一个空对象，在该对象上没有继承 Object.prototype原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法 Object.create()方法接受两个参数:Object.create(obj,propertiesObject) ; obj:一个对象，应该是新创建的对象的原型。 propertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与 Object.defineProperties()的第二个参数一样）。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。使用 Object.create()是将对象继承到 __proto__属性上 继承原型：let dog = Object.create(Animal.prototype与function Dog() {}Dog.prototype = Object.create(Animal.prototype)区别 使用上述方法啊继承原型，其 constructor的值也会复制过来，创建一个新的实例后，其 constructor的值为 Animal，而不是 DOg，可以为 Constructor重新赋值 123Dog.prototype.constructor = Dogvar beagle = new Dog()beagle 立即执行函数 is often used to group related functionality into a single object or module. 123(function() { }) () 1234567891011121314151617let motionModule = (function () { return { glideMixin: function (obj) { obj.glide = function() { console.log(\"Gliding on the water\"); }; }, flyMixin: function(obj) { obj.fly = function() { console.log(\"Flying, wooosh!\"); }; } }}) (); // The two parentheses cause the function to be immediately invokedmotionModule.glideMixin(duck);duck.glide(); Array/Strings的各种方法在函数式编程中，要注意数组和字符串的各种方法，因为部分方法会导致原始数组的改变，比如 push(),pop(),splice(),sort()下面是不会导致原始数组发生改变的方法：concat(),slice(),map(),filter(),forEach().reduce() 关于 arguments对象arguments是一个特殊的对象，可以使用 Array.prototype.slice.call(arguments,(beginIndex),(endIndex))将 arguments转换为数组 函数式编程Functional programming follows a few core principles: Functions are independent from the state of the program or global variables. They only depend on the arguments passed into them to make a calculation Functions try to limit any changes to the state of the program and avoid changes to the global objects holding data Functions have minimal side effects in the program 函数式编程中局部应用（Partial Application）和局部套用（Currying）的区别https://segmentfault.com/a/1190000000765247","link":"/posts/ab4edb64/"},{"title":"随手小记","text":"简单技巧 在js中，四则运算符(+, -,*,/)中，当两个数字中有一个或两个都是字符串的时候，只用 +会表现为连字符，其他符号都会自动将字符串数字转变为数字(toNumber) 函数 “no text giving”。。。中，改(该)表达。 对象 对象 标题错误–属性简写 js垃圾收集机制，mark and sweep,标记并扫除，遍历标记每一个变量，确定其有否引用，无引用则扫除。 SymbolSymbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个不影响任何东西的标签。 JavaScript 中的大多数值都支持 string 的隐式转换。但Symbol 是特别的，它无法自动转换。需要显式toString() Symbol.for()Symbol.keyfor() Object.getOwnPropertySymbols() well-known SymbolSymbol.hasInstance()Symbol.isConcatSpreadableobj[Symbol.toPrimitive]obj[Symbol.interator] 为了进行转换，JavaScript 尝试查找并调用三个对象方法： 调用 objSymbol.toPrimitive 如果这个方法存在的话， objSymbol.toPrimitive,hint只有三种，即 string number 和 default 否则如果暗示是 “string” 尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。 否则，如果暗示 “number” 或者 “default” 尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。 1234567891011121314let user = { name: \"John\", money: 1000, [Symbol.toPrimitive](hint) { alert(`hint: ${hint}`); return hint == \"string\" ? `{name: \"${this.name}\"}` : this.money; }};// 转换演示：alert(user); // hint: string -&gt; {name: \"John\"}alert(+user); // hint: number -&gt; 1000alert(user + 500); // hint: default -&gt; 1500 arraydelete array[n]，使用 delete 删除数组元素，会使该元素变为 undefined ,且 length 不会变，因为 delete obj.key 是通过 key 来移除对应的值。 arr 与 str 都可以使用 indexOf, lastIndexOf 和 includes 还有 slice array 的 sort，reverse 和 splice 方法改变数组本身 Array.from(),以一个可迭代对象或者类数组对象作为参数并返回一个真正的 Array 数组。Array.from 的完整语法允许提供一个可选的 “mapping”（映射）函数：Array.from(obj[, mapFn, thisArg]),第二个参数 mapFn 应是一个在元素被添加到数组前，施加于每个元素的方法，thisArg 允许设置方法的 this 对象。 &lt;a&gt; 标签的 href 属性还可以使用一个值 mailto ，表示发送邮件 Map Set WeakMap WeakSetMapMap 是一个键值对的集合，很像 Object。但主要的区别是，Map 允许所有数据类型作为键。Map的主要方法： new Map() – 创建 map。 map.set(key, value) – 根据键（key）存储值（value）。也可以传递[key, value] 键值对数组。返回map本身 ，例如: 123456// [key, value] 键值对数组let map = new Map([ ['1', 'str1'], [1, 'num1'], [true, 'bool1']]); 有一个内建方法 Object.entries(obj)，它可以返回一个对象的键值对数组，格式就和上面一样。 所以我们可以用一个对象来初始化一个 map，就像这样： 1234let map = new Map(Object.entries({ name: \"John\", age: 30})); 这里，Object.entries 返回了键值对数组：[ [“name”,”John”], [“age”, 30] ]。这正是 Map 需要的。 map.get(key) – 根据键返回值，如果 map 中该键不存在，返回 undefined。 map.has(key) – 如果键存在，返回 true，否则返回 false。 map.delete(key) – 移除该键的值。 map.clear() – 清空 map map.size – 返回当前元素个数。 有三种方法可以循环遍历 map（也可以遍历 set）： map.keys() – 返回键的迭代器， map.values() – 返回值的迭代器， map.entries() – 返回 [key, value] 迭代器入口，for..of 循环会默认使用它。迭代器的迭代顺序和值被插入的顺序一致，Map 会保留这个顺序。 SetSet 是一个值的集合，这个集合中所有的值仅出现一次。 主要方法包括： new Set(iterable) – 创建 set，利用数组来创建是可选的（任何可迭代对象都可以）。 set.add(value) – 添加值，返回 set 自身。 set.delete(value) – 删除值，如果该 value 在调用方法的时候存在则返回 true ，否则返回 false。 set.has(value) – 如果 set 中存在该值则返回 true ，否则返回 false。 set.clear() – 清空 set。 set.size – 元素个数。 WeakMap WeakSet WeakMap —— Map 的一个变体，仅允许对象作为键，并且当对象由于其他原因不可引用的时候将其删除。 它不支持整体的操作：没有 size 属性，没有 clear() 方法，没有迭代器。 WeakSet —— 是 Set 的一个变体，仅存储对象，并且当对象由于其他原因不可引用的时候将其删除。 同样不支持 size/clear() 和迭代器。 WeakMap 和 WeakSet 被用作主要对象存储的次要数据结构补充。一旦对象从存储移除，那么存在于 WeakMap/WeakSet 的数据将会被自动清除。 Object.keys、values、entries 三个方法对于纯对象，下列方法是可用的： Object.keys(obj) —— 返回一个包含该对象全部的键的数组。 Object.values(obj) —— 返回一个包含该对象全部的值的数组。 Object.entries(obj) —— 返回一个包含该对象全部 [key, value] 键值对的数组。… 但是请注意区别（比如说跟 map 的区别）： — Map Object 调用语法 map.keys() Object.keys(obj)，而不是 obj.keys() 返回值 可迭代项 「真正的」数组 Object.keys/values/entries 忽略 Symbol 类型的属性","link":"/posts/b2765b69/"},{"title":"随手小记","text":"读书小记构造器函数对于 new 操作符对于构造函数，如果我们不适用 new 操作符，直接调用构造函数，那么它就是普通的函数，其 this 值直接指向全局环境。 123456789101112function Hero(name) { this.name = name}var h = Hero('Josh')alert(typeof h) // undefinedalert(typeof h.name) // h has no properties```当而使用 `new` 操作符调用的构造函数，则会创建一个新对象， `this` 也会自动指向该对象```jsalert(name) // Joshalert (window.name) //Josh 对于构造器函数的返回值 构造器函数默认返回 this。但当函数内制定了 return 值为其他对象时，该构造器函数返回的是 return 指定的其他对象。当 return 值非对象时，则仍然返回 this 12345678function C() {this.a = 1}var c = new C()alert(c.a) // 1function C2() {this.a = 1; return {b: 2};}var c2 = new C2()alert(typeof c2.a) // undefinedalert(c2.b) //2 内建对象Object所有对象都拥有的属性和方法: 返回构造器函数的构造器属性 constructor 返回对象描述字符串的 toString() 方法，当使用 alert() 和使用 + 进行字符串连接操作时，也会隐式地调用 toString() 方法。 返回对象胆汁描述信息的 valueOf() 方法。一般情况下，对于简单的对象来说(即构造器函数是 Object 的对象)，valeOf() 返回的就是对象本身。 **valueOf() 和 toString() 的区别 Array我们可以使用字面量法，也可以使用 new 操作符 + Array构造器创建一个数组，需要注意的是，使用构造器创建新数组时，如果值传递一个数字，将会认为该数值是数组的长度。 12345var a = new Array(1, 2, 3, 4)a //[1, 2, 3, 4]var a2 = new Array(3)a2 //[unfinded, unfinded, unfinded] 数组也是对象，也可以为数组增加属性，但是定义数组对象自动生成的 length 属性只会计算数字属性的数量，不会计算非数字属性的数量。 length 属性可以被手动设置，如果设置的值大于当前数组中的元素数量，剩下的部分会被自动创建(值为 undefined)的空对象所填充。如果设置的值小于元素数量，多出的部分元素会被移除。 FunctionFunction 对象也有一个 length 属性，用于记录该函数所拥有的 参数的数量。 Function 对象有一个 caller 属性，该属性在 EMCA 标准之外。这个属性会返回一个调用该函数对象的外层函数引用。如果我们在全局作用域调用 A()，那么 A.caller 的值将为 null。例如： 1234function A() {return A.caller}function B() {return a()}B() //B()A() //null 函数对象有一个最重要的属性是 prototype 属性： 每个函数的 prototype 属性中都包含了一个对象 prototype 属性只有在该函数是构造器时才会发挥作用 该函数创建的所有对象都会持有一个该 prototype 属性的引用，并且可以将其当作自身的属性来引用 当我们对一个函数调用 toString() 方法时，所得到的时该函数的源代码。(不可查看内建函数的源码) RegExp","link":"/posts/b2765b69/"},{"title":"React 思维导图","text":"React 学习，思维导图","link":"/posts/70af37a7/"},{"title":"Lua学习","text":"以下是我学习 lua 时做的思维导图，方便自己记忆与理解，点击详情查看。","link":"/posts/f79b72d/"},{"title":"MDN教程学习-CSS","text":"CSS基本连接符 空格连接符(‘ ‘)，表示选择所有后代元素 div p，表示选择 div内的所有 p元素 &gt; 连接符, 表示选择直接子元素 div &gt; p，表示选择 div内的直接的子元素 p(们) ，p(们) 的父元素就是 div + 连接符，表示选择相邻的唯一兄弟元素。div + p，表示选择 div后面的第一个 p元素 ~ 连接符，表示选择之后的所有符合的兄弟元素。div ~ p，表示选择 div后面的所有 p元素 单位1em 相对单位，与字体大小有关，默认为页面字体大小，但会继承父元素的字体大小 1rem(root em),一直保持页面字体大小，不继承父元素字体大小 特殊规则@support 查询，用于判断浏览器是否支持某个特性，如果支持，则对选择器选中的元素使用该特性，例如： 12345@supports (display: grid) { .item { width: auto; }} 上面是对于浏览器是否支持 grid 布局进行了判断，如果支持 grid ，则将 .item 元素的宽度设置为 auto 字体text Property Description color Sets the color of text direction Specifies the text direction/writing direction letter-spacing Increases or decreases the space between characters in a text line-height Sets the line height text-align Specifies the horizontal alignment of text text-decoration Specifies the decoration added to text text-indent Specifies the indentation of the first line in a text-block text-shadow Specifies the shadow effect added to text text-transform Controls the capitalization of text text-overflow Specifies how overflowed content that is not displayed should be signaled to the user unicode-bidi Used together with the direction property to set or return whether the text should be overridden to support multiple languages in the same document vertical-align Sets the vertical alignment of an element white-space Specifies how white-space inside an element is handled word-spacing Increases or decreases the space between words in a text fontfont-size: W3C标准推荐使用em单位，一般来说 em 以页面字体大小为基准,一般为 16px = 1em，应对IE浏览器，使用 em 时，可以在样式表开头添加一条样式 body {font-size: 100%},使用如下： 123456body { font-size: 100%;}h1 { font-size: 2.5em} font-variant:normal|small-caps|initial|inherit;The font-variant property specifies whether or not a text should be displayed in a small-caps font.(which means uppercase the letter with a smaller font size) aligntext-align: left|center|right(horizontal align)vertical-align: top|center|bottom元素水平居中： margin: auto 使用 position: absolute;left: 50%; transform: translateX(-50%) 文本/图片（inline元素）水平垂直居中： 使用 padding: vertical horizonal; text-align: center 使用 position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) (translate 的 % 单位，是基于该元素的宽和高的百分比) 设置 line-height 的值与元素的 height 值一致，文字垂直居中，详细可看CSS行高（line-height）及文本垂直居中原理 区块max-width|min-widthmax-height|min-height如果要设置最大最小，不要设置基础的width和height，因为最大最小会被覆盖 背景background-colorbackground-imagebackground-repeatbackground-attachmentbackground-positionbackground:is shorthand property of all above, allow missing value, but need to in order box-sizing:content-box(width数值不包含内边距和边框宽度)|border-box(width数值包括了内边距和边框宽度) background-image 属性可以使用函数 linear-gradient(direction, color1, color2 [position], color3 [position]....) 设置背景渐变,position 用于控制在哪渐变。 bg-image 还可以使用多个背景，每个背景按由近到远次序排列，第一个背景置于顶层。 bg-clip 用于设置背景图像或颜色出现的区域，值介绍： content-box : 只出现于 content 区域 padding-box : 出现于 padding 和 content 区域 border-box ： 出现于 border padding 和 content 区域 简写属性 background: 可以在一次声明中定义一个或多个属性 background 属性被指定多个背景层时，使用逗号分隔每个背景层。 每一层的语法如下： 在每一层中，下列的值可以出现 0 次或 1 次： &lt;attachment&gt; &lt;bg-image&gt; &lt;position&gt; &lt;bg-size&gt; &lt;repeat-style&gt; &lt;bg-size&gt; 只能紧接着 &lt;position&gt; 出现，以”/“分割，如： “center/80%”. &lt;box&gt; 可能出现 0 次、1 次或 2 次。如果出现 1 次，它同时设定 background-origin 和 background-clip。如果出现 2 次，第一次的出现设置 background-origin，第二次的出现设置 background-clip。 &lt;background-color&gt; 只能被包含在最后一层。 边框border-image CSS属性允许在元素的边框上绘制图像, 使用 border-image 时，其将会替换掉 border-style 属性所设置的边框样式。 相关属性介绍： border-image-source: url(url) : 设置边框图片 border-image-slice: 该属性将 border-image-source 引入的文件，根据值用4条线切为9宫格，图片的4个角的形状为相应的边框的角的形状，值如下： 数字或百分比： 百分比是基于图片大小来说，数字是对于矢量图片的偏移值 fill : 确定是否将图片填满内容区 border-image-width: 定义图像边框宽度。假如border-image-width大于已指定的border-width，那么它将向内部(padding/content)扩展.其值与margin等的设置相似。border-image-outset: 定义边框图像可超出边框盒的大小。值与margin等的设置相似 border-image-repeat: 指定我们希望图像如何填充边界，值如下： stretch：默认;侧面的图像被拉伸来填满边界。这通常看起来很糟糕和像素化，所以不推荐。 repeat：边图像被重复，直到边界被填满。根据具体情况，这可能看起来不错，但您可能会看到一些难看的图像片段。 round： 边的图像被重复，直到边界被填满，它们都被稍微拉伸，这样就不会出现碎片。(推荐) space：边图像被重复，直到边界被填满，每个拷贝之间添加了少量的间隔，这样就不会出现任何片段。这个值只在Safari(9+)和Internet Explorer(11+)中得到支持。 outlineoutline 环绕在 border 外，对盒模型的大小没有任何影响，还有可能会与其他元素的内容产生重叠效果。用法与 border 类似，有一个 outline-offset 属性，可以设置outline 与 border 的距离。两者之间的距离是透明的 list Property Description list-style Sets all the properties for a list in one declaration list-style-image Specifies an image as the list-item marker list-style-position Specifies the position of the list-item markers (bullet points) list-style-type Specifies the type of list-item marker table Property Description border Sets all the border properties in one declaration border-collapse Specifies whether or not table borders should be collapsed border-spacing Specifies the distance between the borders of adjacent cells caption-side Specifies the placement of a table caption empty-cells Specifies whether or not to display borders and background on empty cells in a table table-layout Sets the layout algorithm to be used for a table(设定表格宽度显示布局： auto 布局visibilityvisibility:hidden;隐藏元素，但页面仍然保留布局display:none;隐藏元素，页面布局不保留，仿佛该元素不存在 floatfloat 元素可以设置正常的 margin,padding 和 border 值。float 元素会超出正常的文档流。 float 元素中,当浮动元素的高度不一致，清除浮动后可能会出现高度问题，导致接下来的区块元素与高度最大的元素仅仅贴合在一起，形成难看的布局，我们可以使用以下 clearfix 区块方法或者 overflow:auto 方法： 12345678910/*clearfix 区块方法主要是使用一个空白的区块元素 &lt;div&gt;，取代需要的元素，与浮动元素的底部紧密贴合，而后在将需要的元素卸载 clearfix 区块后面，解决高度问题*/.clearfix { content: ''; clear: both; display:table}/* overflow 只是使用bfc，固定浮动元素宽度并将超出部分滚动而已 */.clearfix { overflow: auto} 定位(position)position: absolute; 绝对定位是基于最近的 非静态定位(static) 的祖先元素定位的 position: sticky，是一个比其他属性要新一些的属性。这基本上是相对位置和固定位置之间的混合，其允许定位的元件像它被相对定位一样动作，直到其滚动到某一阈值点（例如，从视口顶部10像素），之后它变得固定。 Flex(弹性布局)(详情请看阮一峰-flex)[http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html] 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器属性以下6个属性设置在容器上。 flex-directionflex-direction属性决定主轴的方向（即项目的排列方向）。 语法： flex-direction: row | row-reverse | column | column-reverse; 值介绍： row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 语法: flex-wrap: nowrap | wrap | wrap-reverse; 值介绍： nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 语法： justify-content: flex-start | flex-end | center | space-between | space-around; 值介绍： flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。与 space-around 区别在于，首末两个项目与容器没有间隔 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 语法： align-items: flex-start | flex-end | center | baseline | stretch; 值介绍： flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。一定程度上可理解为 只有当 flex-wrap 设置为 wrap 时，有多行项目时才能生效。 语法： align-content: flex-start | flex-end | center | space-between | space-around | stretch; 值介绍： flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。可以为负数 语法： order: &lt;integer&gt;; flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。（剩余空间：容器内的 外边距，内边距，边框和内容框大小以外 的空间） 语法： flex-grow: &lt;number&gt;; /* default 0 */ 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 语法： flex-shrink: &lt;number&gt;; /* default 1 */ 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小，其他缩小。 负值对该属性无效。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 语法： flex-basis: &lt;length&gt; | auto; /* default auto */ 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 语法: flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 语法： align-self: auto | flex-start | flex-end | center | baseline | stretch; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 Grid(网格布局)详细看阮一峰的 CSS Grid 网格布局教程 注意，网格布局的项目中的 width 属性如果设置为 百分数，则该百分数值是基于容器对项目的 grid-template-column 属性的宽度定义的。 多列布局简单方法使用基础的 column-count 属性和与之配套的其他基本属性。 columnscolumns 是一个简写的CSS 属性，允许同时设置 column-width 和 column-count 属性。语法：columns: &lt;'column-width'&gt; || &lt;'column-count'&gt; column-countcolumn-content 用于确定需要分成多少列布局，语法：column-count: auto | &lt;integer&gt; column-widthcolumn-width 用于确定布局内每列需要的宽度，根据该宽度尽可能的划分多的列,语法 column-width: auto | &lt;length&gt; column-rulecolumn-rule 是一个简写的css 属性，允许同时设置 column-rule-width, column-rule-style 和 column-rule-color 的值 语法: column-rule: &lt;'column-rule-width'&gt; || &lt;'column-rule-style'&gt; || &lt;'column-rule-color'&gt;,与 border 属性一致 column-rule-styleCSS 特性 column-rule-style 让你可以设置在多列布局中被画在两列之间的规则（线条）的样式。语法同 border-style 一致 column-rule-colorCSS 特性 column-rule-color 让你可以设置在多列布局中被画在两列之间的规则（线条）的颜色。语法同 border-color 一致 column-rule-widthCSS 特性 column-rule-width 让你可以设置在多列布局中被画在两列之间的规则（线条）的宽度。语法同 border-width 一致 column-gapcolumn-gap 该 CSS 属性用来设置元素列之间的间隔 (gutter) 大小。语法：column-gap: normal | &lt;length&gt; | &lt;percentage&gt; break-insidebreak-inside CSS 属性描述了在多列布局页面下的内容盒子如何中断，如果多列布局没有内容盒子，这个属性会被忽略。 在每一个元素的边界，都可能生成一个中断点，这些中断点由三个属性来定义。break-after 属性定义之前元素的中断点，break-before 定义了之后元素的中断点， break-inside 定义了当前元素的中断点。 语法：break-inside: auto | avoid | avoid-page | avoid-column | avoid-region 小技巧居中方法1. 水平居中简单的水平居中，可以使用 CSS 属性 margin: 0 auto， 实现，该方法将元素的左右外边距设置为 50%，从而实现内容的水平居中。但这种方法无法做到水平垂直居中。 2. 水平垂直居中我所知道的水平垂直居中的方法有以下几种： 绝对定位法：如下： 12345678.align { /* 此处绝对定位使用的 50%，是将元素整体移动到位于相对元素的 50% 的地方，即元素左上角所代表的坐标是位于父元素最中心的位置，因而会存在一定的误差 */ position: absolute; top: 50%; left: 50%; /* 此处的 tranform： translate() 用于调整上述误差。translate(百分比) 此处的百分比是相对该元素的宽高的，正数为向右转移，负数为向左转移，（-50%， -50%）意味着将该元素向左移动该元素一半的宽度，向上移动该元素一一半的宽度*/ transform: translate( -50%, -50%)} flex 方法，为需要垂直水平居中的元素添加一个父元素，父元素 css 设置如下： 1234567.parent { display:flex; /* 设置子项在交叉轴上的对齐方式*/ align-items: center; /*设置子项在主轴上的对齐方式*/ justify-content: center|space-around|space-between}","link":"/posts/e11baa7f/"},{"title":"MDN教程学习-HTML","text":"HTML元数据&lt;meta&gt; 标签&lt;meta&gt; 元素表示那些不能由其它 HTML元相关元素 (&lt;base&gt;, &lt;link&gt;, &lt;script&gt;, &lt;style&gt; 或 &lt;title&gt;) 之一表示的任何元数据信息. meta 属性： charset 此特性声明当前文档所使用的字符编码，但该声明可以被任何一个元素的 lang特性的值覆盖。 content 此属性包含 http-equiv或 name属性的值，具体取决于所使用的值。 http-equiv 这个枚举属性定义了能改变服务器和用户引擎行为的编译。这个编译值使用 content 来定义 default-style这个属性指定了在页面上使用的首选样式表. content属性必须包含 &lt;link&gt; 元素的标题, href属性链接到 CSS样式表或包含 CSS样式表的 &lt;style&gt;元素的标题. refresh这个属性指定: 如果 content 只包含一个正整数,则是重新载入页面的时间间隔(秒); 如果 content 包含一个正整数并且跟着一个字符串,则是重定向到指定链接的时间间隔(秒) name该属性定义文档级元数据的名称。如果设置了 itemprop,http-equiv or charset 之一，就不能在设置这个属性了。以下是 name 属性可能的值： application-name，定义正运行在该网页上的网络应用名称； author ，就是这个文档的作者名称，可以用自由的格式去定义； description ，其中包含页面内容的简短和精确的描述。 一些浏览器，如Firefox和Opera，将其用作书签页面的默认描述。 generator , 包含生成页面的软件的标识符。 keywords , 包含与逗号分隔的页面内容相关的单词。 referrer 控制所有从该文档发出的 HTTP 请求中HTTP Referer 首部的内容：&lt;meta name=&quot;referrer&quot;&gt; content 属性可取的值：| content value | means || —————————— | —————————————————————————————————————————————————————— || no-referrer | 不要发送 HTTP Referer首部。 || origin | 发送当前文档的 origin。 || no-referrer-when-downgrade | 当目的地是先验安全的(https-&gt;https)则发送 origin作为 referrer，但是当目的地是较不安全的 (https-&gt;http)时则不发送 referrer。这个是默认的行为。 || origin-when-crossorigin | 在同源请求下，发送完整的 URL(不含查询参数) ，其他情况下则仅发送当前文档的 origin。 || unsafe-URL | 在同源请求下，发送完整的 URL(不含查询参数)。 | 响应式图片实现响应式图片，有以下方法： 使用 &lt;img&gt; 标签的新属性： srcset 和 sizes,用法如下： 1234567&lt;img srcset=\"elva-fairy-320w.jpg 320w, elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w\" sizes=\"(max-width: 320px) 280px, (max-width: 480px) 440px, 800px\" src=\"elva-fairy-800w.jpg\" alt=\"Elva dressed as a fairy\"&gt; srcset 定义了我们允许浏览器选择的图像集，以及每个图像的大小。在每个逗号之前，我们写： 一个文件名 (elva-fairy-480w.jpg.) 一个空格 图像的固有宽度（以像素为单位）（480w）——注意到这里使用w单位，而不是你预计的px。这是图像的真实大小，可以通过检查你电脑上的图片文件找到（例如，在Mac上，你可以在 Finder上选择这个图像，然后按 Cmd+ I来显示信息）。 sizes 定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择—我们在之前已经讨论了一些提示。在这种情况下，在每个逗号之前，我们写： 一个媒体条件（(max-width:480px)）,讨论的是媒体条件描述了屏幕可能处于的状态。在这里，我们说“当视窗的宽度是480像素或更少”。 一个空格 当媒体条件为真时，图像将填充的槽的宽度（440px） 有了这些属性，浏览器会： 查看设备宽度 检查 sizes列表中哪个媒体条件是第一个为真 查看给予该媒体查询的槽大小 加载 srcset列表中引用的最接近所选的槽大小的图像 使用 &lt;picture&gt; 元素，用法如下： 12345&lt;picture&gt; &lt;source media=\"(max-width: 799px)\" srcset=\"elva-480w-close-portrait.jpg\"&gt; &lt;source media=\"(min-width: 800px)\" srcset=\"elva-800w.jpg\"&gt; &lt;img src=\"elva-800w.jpg\" alt=\"Chris standing up holding his daughter Elva\"&gt;&lt;/picture&gt; &lt;source&gt; 元素包含一个 media属性，这一属性包含一个媒体条件——就像第一个 srcset例子，这些条件来决定哪张图片会显示——第一个条件返回真，那么就会显示这张图片。在这种情况下，如果视窗的宽度为799 px或更少，第一个 &lt;source&gt; 元素的图片就会显示。如果视窗的宽度是800px或更大，就显示第二张图片。注意， media属性只在需要确定艺术方向时确定(横屏或竖屏) srcset属性包含要显示图片的路径。请注意，正如我们在 &lt;img&gt; 上面看到的那样，&lt;source&gt; 可以使用引用多个图像的 srcset属性，还有 sizes属性。所以你可以通过一个 &lt;picture&gt; 元素提供多个图片，不过也可以给每个图片提供多分辨率的图片。实际上，你可能不想经常做这样的事情。 在任何情况下，你都必须在 &lt;/picture&gt; 之前正确提供一个 &lt;img&gt; 元素以及它的 src和 alt属性，否则不会有图片显示。当媒体条件都不返回真的时候（你可以在这个例子中删除第二个 &lt;source&gt; 元素），它会提供图片；如果浏览器不支持 &lt;picture&gt; 元素时，它可以作为后备方案。这样的代码允许我们在宽屏和窄屏上都能显示合适的图片 表格 需要注意 col colgroup对于列的样式作用 注意 scope属性对于视障人士的作用。 colspan, rowspan， &lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt; 表单&lt;fieldset&gt; 和 &lt;legend&gt; 元素 &lt;fieldset&gt; 用于给表单分段， &lt;legend&gt; 给 filedset&gt; 元素提供标题 &lt;input&gt; 元素的 type 属性值 type属性可能的常用值 ： text email search搜索框 tel电话号码 url date number，通过设置 min 和 max 属性来约束该值。通过设置 step 属性来指定增加和减少按钮更改小部件的值的数量。 range, 滑块，设置 min 、 max 和 step 属性 日期 所有日期和时间控制都可以使用 min和 max属性来约束。 datetime-local本地时间 month创建了一个小部件来显示和挑选一个月。 time这将创建一个小部件来显示并选择一个时间值。 week建一个小部件来显示并挑选一个星期号和它的年份。 color拾色器 img file文件选择器 hidden有些数据是用表单发送的，但不显示给用户.需要设置它的 name和 value属性 表单小部件 进度条 &lt;progress&gt;，有属性 max value,这是为了实现任何需要进度报告的内容，例如下载的总文件的百分比，或者问卷中填写的问题的数量。 仪表 &lt;meter&gt; ，一个仪表表示一个固定值，这个值由一个 min 和一个 max 值所定。这个值是作为一个条形显示的，并且为了知道这个工具条是什么样子的，我们将这个值与其他一些设置值进行比较 low 和 high 值范围划分为三个部分： 该范围的较低部分是在 min和 low值(包括那些值)之间。 该范围的中间部分是在 low和 high值之间(不包括那些值)。 该范围的较高部分是在 high和 max值(包括那些值)之间。 optimum 值定义了 &lt;meter&gt; 元素的最优值。在与 htmlattrxref(“low”、“meter”) 和 high 值的联合中，它定义了该范围的哪个部分是优先的： 如果 optimum 值在较低的范围内，则较低的范围被认为是首选项，中等范围被认为是平均值，而较高的范围被认为是最坏的部分。 如果 optimum 值在该范围的中等部分，则较低的范围被认为是一个平均值，中等范围被认为是优先的部分，而较高的范围也被认为是平均值。 如果 optimum 值在较高的范围内，则较低的范围被认为是最坏的部分，中等范围被认为是一般的部分，较高的范围被认为是优先的部分。所有实现 &lt;meter&gt;元素的浏览器都使用这些值来改变米尺的颜色。 如果当前值位于该范围的优先部分，则该条是绿色的。 如果当前值位于该范围的平均部分，则该条是黄色的。 如果当前值处于最糟糕的范围，则该条是红色的。 下拉内容 – 自动补全输入框 可以使用 &lt;datalist&gt; 元素来为表单小部件提供建议的、自动完成的值，并使用一些 &lt;option&gt; 子元素来指定要显示的值。 然后使用 list属性将数据列表绑定到一个文本域(通常是一个 &lt;input&gt; 元素)。 一旦数据列表与表单小部件相关联，它的选项用于自动完成用户输入的文本;通常，这是作为一个下拉框向用户展示的，在输入框中输入可能匹配的内容。 &lt;datalist&gt; 元素是 HTML表单的最新补充，因此浏览器的支持比我们之前看到的要少一些。最值得注意的是，它在10以下的 IE版本中不受支持，Safari在写作时仍然不支持它。 为了处理这个问题，这里有一个小技巧，可以为这些浏览器提供一个不错的备用： 1234567891011121314151617&lt;label for=\"myFruit\"&gt;What is your favorite fruit? (With fallback)&lt;/label&gt;&lt;input type=\"text\" id=\"myFruit\" name=\"fruit\" list=\"fruitList\"&gt; &lt;datalist id=\"fruitList\"&gt; &lt;!-- 为不支持的浏览器提供的备选 --&gt; &lt;label for=\"suggestion\"&gt;or pick a fruit&lt;/label&gt; &lt;select id=\"suggestion\" name=\"altFruit\"&gt; &lt;option&gt;Apple&lt;/option&gt; &lt;option&gt;Banana&lt;/option&gt; &lt;option&gt;Blackberry&lt;/option&gt; &lt;option&gt;Blueberry&lt;/option&gt; &lt;option&gt;Lemon&lt;/option&gt; &lt;option&gt;Lychee&lt;/option&gt; &lt;option&gt;Peach&lt;/option&gt; &lt;option&gt;Pear&lt;/option&gt; &lt;/select&gt;&lt;/datalist&gt; 支持 &lt;datalist&gt; 元素的浏览器将忽略所有不是 &lt;option&gt; 元素的元素，并按照预期工作。另一方面，不支持 &lt;datalist&gt; 元素的浏览器将显示标签和选择框。当然，还有其他方法可以处理 &lt;datalist&gt; 元素的不足，但这是最简单的(其他方法往往需要 JavaScript)。","link":"/posts/6b3c3b6a/"},{"title":"MDN教程学习-JS","text":"JavaScript MDN&lt;script&gt; 标签中的 asyn 与 deferHTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 文档对象模型 DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。即脚本阻塞了 HTML 元素的解析。 在引用外部 js文件的 &lt;script&gt; 标签中使用 asyn 与 defer 是为了防止以上所说的脚本阻塞问题 asyn 浏览器遇到 async 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，async 是最理想的选择。 当多个 &lt;script&gt; 标签使用 asyn 时，各个标签的加载顺序无法确定，如果脚本之间存在依赖关系，则有可能导致脚本出错。 defer: 添加 defer 属性的脚本将按照在页面中出现的顺序加载 脚本调用策略小结： 如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 async。 如果脚本需要等待解析，且依赖于其它脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML中。 对象原型prototype constructor与 __proto__ 关系 prototype:是 构造器函数中的一个特殊对象，在其中定义的方法和属性可以被实例继承 __proto__： 是实例对象的一个内置属性，实例通过 __proto__ 访问构造器函数的 prototype对象 constructor： 每个实例对象都从原型中继承了一个 constructor属性，该属性指向了用于构造此实例对象的构造函数。 Object.create() 方法创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__。 demo: 123var person1 = new Person()var person2 = Object.create(person1)person2.__proto__ === person1 // true 原型继承的基本方法之一：demo: 123456789101112function Person(name, age) { this.name = name this.age = age}function Teacher(name, age, subject) { Person.call(this, name, age) // 使用call 方法，使 Teacher 能够继承来自 Person 的属性 this.subject = subject // 这是 Teacher 自身的属性，也可以被继承}Teacher.prototype = Object.create(Person.prototype) //通过 create 方法，使 Teacher 能够继承来自 Person 的 prototype 的属性和方法，这里基本可以认为是 Teacher.prototype.__proto__ === person.prototypeTeacher.prototype.constructor = Teacher 以上是 Teacher继承 Person的基本方法， 原型连接只有在检索值时才会被用到。如果我们去尝试获取对象的某个属性值，但是该对象没有此属性名，那么 JavaScrit会尝试从原型对象中获取属性值。 hasOwnProperty() 方法，检查对象的值时原型属性还是对象独有的属性。该方法不会检查原型链 Canvas要在网页中创建 2D 或者 3D 场景，必须在 HTML文件中插入一个 &lt;canvas&gt; 元素，以界定网页中的绘图区域。 123456var canvas = document.querySelector('canvas')// 设置宽高var width = canvas.width = window.innerWidth;var height = canvas.height = window.innerHeight;// 画布模板设置还有最后一步。我们需要获得一个对绘画区域的特殊的引用（称为“上下文”）用来在画布上绘图。var ctx = canvas.textContent('2d') 上面的 ctx 变量包含一个 CanvasRenderingContext2D对象，画布上所有绘画操作都会涉及到这个对象。 12ctx.fillStyle = 'rgb(0, 0, 0)';ctx.fillRect(0, 0, width, height); 这里我们使用画布的 fillStyle 属性（和 CSS属性 色值 一致）设置填充色，然后使用 fillRect 方法绘制一个覆盖整个区域的矩形（前两个参数是矩形左上顶点的坐标，后两个参数是矩形的长宽，现在你知道 width和 height的作用了吧）。 简单矩形可以通过 fillStyle 和 fillRect 方法设置一个简单的矩形 描边（stroke） 和 线条可以绘制仅包含外部框线（图形设计中称为描边）的矩形。你可以使用 strokeStyle属性来设置描边颜色，使用 strokeRect来绘制一个矩形的轮廓。 默认的描边宽度是 1 像素，可以通过调整 lineWidth属性（接受一个表示描边宽度像素值的数字）的值来修改。 123ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';ctx.strokeRect(25, 25, 175, 200);ctx.lineWidth = 5; 绘制路径可以通过绘制路径来绘制比矩形更复杂的图形。路径中至少要包含钢笔运行精确路径的代码以确定图形的形状。 绘制路径的通用方法和属性： beginPath()：在钢笔当前所在位置开始绘制一条路径。在新的画布中，钢笔起始位置为 (0, 0)。 moveTo()：将钢笔移动至另一个坐标点，不记录、不留痕迹，只将钢笔“跳”至新位置。 fill()：通过为当前所绘制路径的区域填充颜色来绘制一个新的填充形状。终止路径 stroke()：通过为当前绘制路径的区域描边，来绘制一个只有边框的形状。 路径也可和矩形一样使用 lineWidth 和 fillStyle / strokeStyle 等功能。 lineTo():需要两个参数，x 和 y 坐标，将从钢笔当前位置 到 x,y处画一条直线。 画圆画布中绘制圆的方法—— arc() ，通过连续的点来绘制整个圆或者弧（arc，即局部的圆）。 arc() 函数有六个参数。前两个指定圆心的位置坐标，第三个是圆的半径，第四、五个是绘制弧的起、止角度（给定 0° 和 360° 便能绘制一个完整的圆），第六个是绘制方向（false是顺时针，true是逆时针）。 12345ctx.fillStyle = 'rgb(0, 0, 255)';ctx.beginPath();// 顺时针画一个坐标在 （150，106），半径为50px，的圆ctx.arc(150, 106, 50, degToRad(0), degToRad(360), false);ctx.fill(); 1234567ctx.fillStyle = 'yellow';ctx.beginPath();//最后一个参数设置为 true，意味着弧将逆时针绘制,也就意味着即使起、止角度分别设置为 -45°、45°，我们还是得到了区域外的一条 270° 的弧。ctx.arc(200, 106, 50, degToRad(-45), degToRad(45), true);//在调用 fill() 前，我们绘制了一条终点为圆心的直线。然后我们就渲染出一个惟妙惟肖的吃豆人模型。如果删除这条线（试试呗）再重新运行代码，你只能得到一个起止点间被砍掉一块的圆。这向我们展示了画布的另一个重要事项：如果要填充一个未完成（也就是没有首尾相接）的路径，浏览器将在起、止点件绘制一条直线，然后直接填充。ctx.lineTo(200, 106);ctx.fill(); 文本以下两个函数用于绘制文本： fillText() ：绘制有填充色的文本。 strokeText()：绘制文本外边框（描边）。 这两个函数有三个基本的参数：需要绘制的文字、文本框（顾名思义，围绕着需要绘制文字的方框）左上顶点的X、Y坐标。 还有一系列帮助控制文本渲染的属性：比如用于指定字体族、字号的 font，它的值和语法与 CSS的 font属性一致。 12345678ctx.strokeStyle = 'white';ctx.lineWidth = 1;ctx.font = '36px arial';ctx.strokeText('Canvas text', 50, 50);ctx.fillStyle = 'red';ctx.font = '48px georgia';ctx.fillText('Canvas text', 50, 150); 绘制图片drawImage()方法可将图片绘制在画布上。 最简单的版本需要三个参数：需要渲染的图片、图片左上角的X、Y坐标。 将图片源嵌入画布中，代码如下： 12var image = new Image();image.src = 'firefox.png'; 这里使用 Image() 构造器创建了一个新的 HTMLImageElement 对象。返回对象的类型与非空 &lt;img&gt; 元素的引用是一致的。然后将它的 src 属性设置为 Firefox的图标。此时浏览器将开始载入这张图片。 这次我们尝试用 drawImage() 函数来嵌入图片，应确保图片先载入完毕，否则运行会出错。可以通过 onload事件处理器来达成，该函数只在图片调用完毕后才会调用。在上文代码末尾添加以下内容： 123image.onload = function() { ctx.drawImage(image, 50, 50);} 保存刷新，可以看到图片成功嵌入画布中。 还有更多方式。如果仅需要显示图片的某一部分，或者需要改变尺寸，该怎么做呢？复杂版本的 drawImage() 可解决这两个问题。请更新 ctx.drawImage() 一行代码为： 1ctx.drawImage(image, 20, 20, 185, 175, 50, 50, 185, 175); 第一个参数不变，为图片引用。 参数 2、3 表示裁切部分左上顶点的坐标，参考原点为原图片本身左上角的坐标。原图片在该坐标 左、上的部分均不会绘制出来。 参数 4、5 表示裁切部分的长、宽。 参数 6、7 表示裁切部分左上顶点在画布中的位置坐标，参考原点为画布左上顶点。 参数 8、9 表示裁切部分在画布中绘制的长、宽。本例中绘制时与裁切时面积相同，你也可以定制绘制的尺寸。 循环与动画ctx.translate()方法，可用于移动画布的原点。（画布的原点(0, 0)默认为左上角） 12//这会使原点 (0, 0) 从画布左上顶点移动至画布正中心ctx.translate(width/2, height/2); 客户端存储复杂的客户端存储方式 – indexDB打开或者创建 indexDB 数据库对象 1234567891011121314151617181920212223242526272829303132333435let db// 将版本为 1， 名为 'note'的数据库储存在 request 变量中let request = windeow.indexDB.open('note', 1) // 数据库对象的事件处理程序request.onerror = () =&gt; { console.log('database open failed')}request.onsuccess = () =&gt; { console.log('database open successfully') //将数据库对象的结果(属性名为 result )赋值给变量 db db = request.result}// indexDB 中重要的事件处理程序，'onupgradeneeded'。该事件处理程序将在数据库未建立 或者 有比现在打开的数据库 更新版本的数据库被打开 时运行request.onupgradeneeded = e =&gt; { // 获得现在打开的数据库的引用, e.target 相当于 request,这一行等价于 db = request.result。不适用 request 的原因是 onupgradeneeded 有可能在 onsuccess 之前运行，意味着 request.result 还没有获得引用 let db = e.target.result // We then use IDBDatabase.createObjectStore() to create a new object store inside our opened database called notes_os. This is equivalent to a single table in a conventional database system. We've given it the name notes, and also specified an autoIncrement key field called id — in each new record this will automatically be given an incremented value — the developer doesn't need to set this explicitly. Being the key, the id field will be used to uniquely identify records, such as when deleting or displaying a record. let objectStore = db.createObjectStore('note_os', {keyPath: 'id', autoIncresement: true}) // We also create two other indexes (fields) using the IDBObjectStore.createIndex() method: title (which will contain a title for each note), and body (which will contain the body text of the note). objectStore.createIndex('title', 'title', { unique: false }); // 第二个参数表示 keyPath,可用于索引数据库中的数据 objectStore.createIndex('body', 'body', { unique: false }); console.log('Database setup complete');};// Create an onsubmit handler so that when the form is submitted the addData() function is runform.onsubmit = addData;}","link":"/posts/cb9aac77/"},{"title":"Js现代教程笔记 -- Class","text":"ClassES6提供了一个新的 class 关键字用于更创建基于原型继承的类。 class 基础语法123456789101112131415class MyClass { prop = value; // field constructor(...) { // constructor // ... } method(...) {} // method get something(...) {} // getter method set something(...) {} // setter method [Symbol.iterator]() {} // method with computed name/symbol name // ...} 如上，new MyClass() 创建一个有着上列方法的新对象，constructor() 方法会因为 new 操作符被自动调用，再此我们初始化了该对象，例如： 123456789101112131415class User { constructor(name) { this.name = name; } sayHi() { alert(this.name); }}// Usage:let user = new User(\"John\");user.sayHi(); 当 new User('John') 被调用： 一个新对象被创建。 constructor 根据给定的参数运行，并把 this.name 赋值给它 到底什么是 class 呢class 的本质还是 函数(Function)。 上面的例子中， class User{...} 做了这些事情： class 声明的结果创建了一个叫 User 的函数：函数代码取自 construtor 方法 把所有其他方法保存在 User.prototype 所以，当我们在新对象调用一个方法时，它是取自 Fn.prototype 的。上面的 new User 对象能从 User.prototype 获得 class 的方法。 因为我们可以通过不用 class 关键字声明一个看似一样的类，因此有人认为 class 只是一个语法糖，例如: 1234567891011121314151617// rewriting class User in pure functions// 1. Create constructor functionfunction User(name) { this.name = name;}// any function prototype has constructor property by default,// so we don't need to create it// 2. Add the method to prototypeUser.prototype.sayHi = function() { alert(this.name);};// Usage:let user = new User(\"John\");user.sayHi(); 但是，这个方法和 class 声明有一定的区别： 通过 class 创建的函数有一个隐藏的内部属性 [[FunctionKind]]::'classConstructor', 因为这个属性，如果不通过 new 运算符调用 class，将会直接报错。而且 class 的字符串描述也不同。 12345class User {constructor() {}}alert(User); // class User { ... } class 的方法都是不可枚举的(non-enumerable)。class 声明将 prototype 内的所有方法的 enumerable 描述符都设置为了 false.因此 for...in 将无法获取对象继承到的方法 class 内的所有代码都是被强制使用了 strict mode class 表达式与 function 类似，class 也可以被其他表达式定义，比如赋值，return 等。 class 声明也可以是匿名的或者命名的，但是命名的 class 只有在 class 内部才能调用其名。 12345678910// \"Named Class Expression\" (alas, no such term, but that's what's going on)let User = class MyClass { sayHi() { alert(MyClass); // MyClass is visible only inside the class }};new User().sayHi(); // works, shows MyClass definitionalert(MyClass); // error, MyClass not visible outside of the class 我们还可以动态地请求生成 class ： 12345678910111213function makeClass(phrase) { // declare a class and return it return class { sayHi() { alert(phrase); }; };}// Create a new classlet User = makeClass(\"Hello\");new User().sayHi(); // Hello getter/setter和其他属性class 也包含了 getter/setter,generators, computed 等属性，下面是一个用 get/set 操作 user.name 的例子 12345678910111213141516171819202122232425class User { constructor(name) { // invokes the setter this._name = name; } get name() { return this._name; } set name(value) { if (value.length &lt; 4) { alert(\"Name is too short.\"); return; } this._name = value; }}let user = new User(\"John\");alert(user.name); // Johnuser = new User(\"\"); // Name is too short. 实际上，getter和 setter 被创建在 User.prototype，如下： 12345678910Object.defineProperties(User.prototype, { name: { get() { return this._name }, set(name) { // ... } }}); class 属性123456789101112class User { name = \"Anonymous\"; //* sayHi() { alert(`Hello, ${this.name}!`); }}new User().sayHi();alert(User.prototype.sayHi); // placed in User.prototypealert(User.prototype.name); // undefined, not placed in User.prototype 该属性 name 并没有被放在 User.prototype。它是属于对象 User 自身的属性，它会在调用 constructor() 之前通过 new 创建在每个对象内，各对象内的该属性互不影响。 类的继承类可以继承另外一个类。这是一个非常棒的语法，在技术上是它基于原型继承实现的。 extends 关键字为了继承另外一个类，我们需要在括号 {..} 前指定 &quot;extends&quot; 和父类 这里我们写一个继承自 Animal 的 Rabbit： 123456789101112131415161718192021222324252627282930class Animal { constructor(name) { this.speed = 0; this.name = name; } run(speed) { this.speed += speed; alert(`${this.name} runs with speed ${this.speed}.`); } stop() { this.speed = 0; alert(`${this.name} stopped.`); }}// 从 Animal 继承class Rabbit extends Animal { hide() { alert(`${this.name} hides!`); }}let rabbit = new Rabbit(\"White Rabbit\");rabbit.run(5); // 白色兔子会以速度 5 奔跑。rabbit.hide(); // 白色兔子藏了起来！ 例如，为了找到 rabbit.run() 方法，引擎的查找顺序如下： rabbit 对象（未找到）。 rabbit 的原型，即 Rabbit.prototype（有 hide()，但没有 run） Rabbit.prototype 的原型，因为 extends 关键字指向了 Animal，即 Animal.prototype，找到 run() 方法 就如你期望的那样，也正如我们之前所见，extends 关键字实际上是给 Rabbit.prototype 添加了一个属性 [[Prototype]]，并且它会指向 Animal.prototype。 所以，现在 rabbit 即可以访问它自己的方法，也可以访问 Animal 的方法。 注意，类语法不仅允许在 extends 后指定一个类，也允许指定任何表达式。 123456789function f(phrase) { return class { sayHi() { alert(phrase) } }}class User extends f(\"Hello\") {}new User().sayHi(); // Hello 上面的代码中， User 就是继承了 f('Hello) 的返回结果 重写一个方法现在让我们继续前进并尝试重写一个方法。到目前为止，Rabbit 继承了 Animal 的 stop 方法，该方法设置了 this.speed = 0。 如果我们在 Rabbit 中定义了我们自己的 stop 方法，那么它将被用来代替 Animal 的 stop 方法： 12345class Rabbit extends Animal { stop() { // ...这将用于 rabbit.stop() }} …但是通常来说，我们不希望完全替换父类的方法，而是希望基于它做一些调整或者扩展。我们在我们的方法中做一些事情，但是在它之前/之后或在执行过程中调用父类的方法。 为此，类提供了 &quot;super&quot; 关键字。 执行 super.methodName(...) 来调用一个父类的方法。执行 super(...) 调用父类的构造函数 (只能在子类的构造函数中执行)。 例如，让我们的兔子在停下时自动隐藏： 12345678910111213141516171819202122232425262728293031323334class Animal { constructor(name) { this.speed = 0; this.name = name; } run(speed) { this.speed += speed; alert(`${this.name} runs with speed ${this.speed}.`); } stop() { this.speed = 0; alert(`${this.name} stopped.`); }}class Rabbit extends Animal { hide() { alert(`${this.name} hides!`); } stop() { super.stop(); // 调用父类的 stop 函数 this.hide(); // 并且在那之后隐藏 }}let rabbit = new Rabbit(\"White Rabbit\");rabbit.run(5); // White Rabbit runs with speed 5.rabbit.stop(); // White Rabbit stopped. White rabbit hides! 现在，Rabbit 有自己的 stop 函数，并且在执行过程中会调用父类的 super.stop()。 注意，箭头函数中没有 super. 如果被访问，它将从外部函数获取 重写构造函数到目前为止，Rabbit 还没有自己的 constructor。 根据规范，如果一个类继承了另一个类并且没有构造函数，那么将生成以下构造函数： 123456class Rabbit extends Animal { // 为没有构造函数的继承类生成以下的构造函数 constructor(...args) { super(...args); }} 我们可以看到，它调用了父类的 constructor 并传递了所有的参数。如果我们不写自己的构造函数，就会出现上述这种情况。 如果我们要手写子类的构造函数，那么，继承类的构造函数必须调用 super(...)，并且一定要在使用 this 之前调用。 为什么呢？在 JavaScript 中，“派生类的构造函数”与所有其他的构造函数之间存在区别。在派生类中，相应的构造函数会被标记为特殊的内部属性 [[ConstructorKind]]:&quot;derived&quot;。 不同点就在于: 当一个普通构造函数执行时，它会创建一个空对象作为 this 并继续执行。 但是当派生的构造函数执行时，它并不会做这件事。它期望父类的构造函数来完成这项工作。 因此，如果我们构建了我们自己的构造函数，我们必须调用 super，否则的话 this 指向的对象不会被创建，并且我们会收到一个报错。例如： 123456789101112131415161718192021222324class Animal { constructor(name) { this.speed = 0; this.name = name; } // ...}class Rabbit extends Animal { constructor(name, earLength) { super(name); //如果没有这一行，下面调用将会报错 Error: this is not defined. this.earLength = earLength; } // ...}// now finelet rabbit = new Rabbit(\"White Rabbit\", 10);alert(rabbit.name); // White Rabbitalert(rabbit.earLength); // 10 Super: 内部基于 [[HomeObject]] 实现让我们再深入的去研究下 super。顺便说一句，我们会发现一些有趣的事情。 首先要说的是，从我们迄今为止学到的知识来看，super 是不可能运行的。 的确是这样，让我们问问自己，在技术上它是如何实现的？当一个对象方法运行时，它会将当前对象作为 this。如果之后我们调用 super.method()，那么如何检索 method？我们想当然地认为需要从当前对象的原型中获取 method。但是从技术上讲，我们（或者 JavaScript 的引擎）可以做到这一点吗？ 也许我们可以从 this 的 [[Prototype]] 上获得方法，就像 this.__proto__.method？不幸的是，这样是行不通的。 让我们尝试去这么做看看。简单起见，我们不使用类，只使用普通对象。 在这里，rabbit.eat() 会调用父对象的 animal.eat() 方法： 1234567891011121314151617let animal = { name: \"Animal\", eat() { alert(`${this.name} eats.`); }};let rabbit = { __proto__: animal, name: \"Rabbit\", eat() { // 这是 super.eat() 可能工作的原因 this.__proto__.eat.call(this); // (*) }};rabbit.eat(); // Rabbit eats. 在 (*) 这一行，我们从 animal 的原型上获取 eat，并在当前对象的上下文中调用它。请注意，.call(this)在这里非常重要，因为简单的调用 this.__proto__.eat() 将在原型的上下文中执行 eat，而非当前对象 在上述的代码中，它按照期望运行：我们获得了正确的 alert。 现在让我们在原型链上再添加一个额外的对象。我们将看到这件事是如何被打破的： 12345678910111213141516171819202122232425let animal = { name: \"Animal\", eat() { alert(`${this.name} eats.`); }};let rabbit = { __proto__: animal, eat() { // ...新建一个兔子并调用父类的方法 this.__proto__.eat.call(this); // (*) }};let longEar = { __proto__: rabbit, eat() { // ...用长耳朵做一些事情，并调用父类（rabbit）的方法 this.__proto__.eat.call(this); // (**) }};longEar.eat(); // Error: Maximum call stack size exceeded 代码无法再运行了！我们可以看到，在试图调用 longEar.eat() 时抛出了错误。 原因可能不那么明显，但是如果我们跟踪 longEar.eat() 的调用，就可以发现原因。在 (*) 和 (**) 这两行中，this 的值都是当前对象 longEar。这是至关重要的一点：所有的对象方法都将当前对象作为 this，而非原型或其他什么东西。 因此，在 (*) 和 (**)这两行中，this.__proto__ 的值是完全相同的，都是 rabbit。在这个无限循环中，他们都调用了 rabbit.eat，而不是在原型链上向上寻找方法。 在 longEar.eat() 中，(**) 这一行调用 rabbit.eat 并且此时 this=longEar.123456// 在 longEar.eat() 中 this 指向 longEarthis.__proto__.eat.call(this) // (**)// 变成了longEar.__proto__.eat.call(this)// 即等同于rabbit.eat.call(this); 之后在 rabbit.eat 的 (*)行中，我们希望将函数调用在原型链上向更高层传递，但是因为 this=longEar，因此 this.__proto__.eat 又是 rabbit.eat！123456// 在 rabbit.eat() 中 this 依旧等于 longEarthis.__proto__.eat.call(this) // (*)// 变成了longEar.__proto__.eat.call(this)// 再次等同于rabbit.eat.call(this); 所以 rabbit.eat 不停地循环调用自己，因此它无法进一步地往原型链的更高层调用 这个问题没法单独使用 this 来解决。 [[HomeObject]]为了提供解决方法，JavaScript 为函数额外添加了一个特殊的内部属性 ：[[HomeObject]]。 当一个函数被定义为类或者对象方法时，它的 [[HomeObject]] 属性就成为当前类或对象。 一般来说，对象中的函数是自由函数，可以改变他们的 this 值，可以在对象间自由地赋值，但是 [[HomeObject]] 违反了 “解除绑定” 功能的想法，因为函数会记录他们绑定的对象。 [[HomeObject]] 不能被改变，并且这个绑定是永久的。 但是这种改变是安全的。[[HomeObject]] 只有使用 super 调用父类的方法是才会被使用。所以它不会破坏兼容性。 让我们看看它是如何帮助 super 运行的 —— 我们再次使用普通对象： 123456789101112131415161718192021222324let animal = { name: \"Animal\", eat() { // [[HomeObject]] == animal alert(`${this.name} eats.`); }};let rabbit = { __proto__: animal, name: \"Rabbit\", eat() { // [[HomeObject]] == rabbit super.eat(); }};let longEar = { __proto__: rabbit, name: \"Long Ear\", eat() { // [[HomeObject]] == longEar super.eat(); }};longEar.eat(); // Long Ear eats. 每个方法都会在内部的 [[HomeObject]] 属性上标记它的对象。然后 super 利用它来解析父级原型。 [[HomeObject]] 是为类和简单对象中定义的方法定义的。但是对于对象，方法必须按照给定的方式定义：使用简写的 methodName()，而不是完整 methodName: function()。 在下面的例子中，使用非方法语法来进行对比 。[[HomeObject]] 属性没有被设置，并且此时继承没有生效： 1234567891011121314let animal = { eat: function() { // 应该使用简短语法：eat() {...} // ... }};let rabbit = { __proto__: animal, eat: function() { super.eat(); }};rabbit.eat(); // 调用 super 报错（因为没有 [[HomeObject]]） class的静态属性和方法静态方法我们也可以给 class 本身赋予方法，而不是给其 prototype 赋予方法，这种方法被叫做 静态方法 123456789101112131415//这两种方法是等价的// 1.class User { static staticMethod() { alert(this === User); }}// 2. function User() { }User.staticMethod = function() { alert(this === User);}; 静态方法并不用于具体的实例，它不要求有实例存在，只要求一个 class，它是 class 独有的，不与实例共享。 静态属性静态属性用于存储 class 级的数据，同样不与实例绑定，语法如下： 1234567class MyClass { static property = ...; static method() { ... }} 这相当于把值赋予 class 本身： 12MyClass.property = ...MyClass.method = ... 静态属性和方法都是可继承的。技术上来讲，对于 class B extends A,类 B 的原型指向类 A： B.[[prototype]] = A。 123456789101112131415161718192021222324252627282930313233343536class Animal { static planet = \"Earth\"; constructor(name, speed) { this.speed = speed; this.name = name; } run(speed = 0) { this.speed += speed; alert(`${this.name} runs with speed ${this.speed}.`); } static compare(animalA, animalB) { return animalA.speed - animalB.speed; }}// Inherit from Animalclass Rabbit extends Animal { hide() { alert(`${this.name} hides!`); }}let rabbits = [ new Rabbit(\"White Rabbit\", 10), new Rabbit(\"Black Rabbit\", 5)];rabbits.sort(Rabbit.compare);rabbits[0].run(); // Black Rabbit runs with speed 5.alert(Rabbit.planet); // Earth 如上述代码，当我们调用 Rabbit.compare() 的时候，调用的是继承自 Animal 的静态方法 compare() 这是如何实现的呢？也是通过 prototype，正如你所想的， extends 将 Rabbit 的 [[Prototype]] 指向了 Animal 所以，我们可以说， Rabbit extends Animal 创建了两个 [[Prototype]] 的引用： Rabbit 类自身的 [[Prototype]] 指向 Animal 类自身 Rabbit.prototype 的 [[Prototype]] 指向 Animal.prototype 所以，继承对于常规方法和静态方法都管用 我们可以通过代码来检测一下： 12345678class Animal {}class Rabbit extends Animal {}// for staticsalert(Rabbit.__proto__ === Animal); // true// for regular methodsalert(Rabbit.prototype.__proto__ === Animal.prototype); // true 内置类没有静态方法继承请注意，内置类没有这种静态 [[Prototype]] 的引用。例如， Object 有 Object.defineProperty，``Object.keys 等等的方法，但是 Array，``Date 等等并不会继承他们。 请注意，Date 和 Object 之间没有关联 。Object 和 Date 都是独立存在的 。Date.prototype 继承自 Object.prototype，但也仅此而已。 原生方法是可扩展的Array，``Map 等 JavaScript 内置的类也是可以扩展的。 例如，这里的 PowerArray 继承自原生的 Array： 12345678910111213 // 给 Array 增加一个新方法（可以做更多功能）class PowerArray extends Array { isEmpty() { return this.length === 0; }}let arr = new PowerArray(1, 2, 5, 10, 50);alert(arr.isEmpty()); // falselet filteredArr = arr.filter(item =&gt; item &gt;= 10);alert(filteredArr); // 10, 50alert(filteredArr.isEmpty()); // false 有一件非常有趣的事情需要注意。像 filter，map 或者其他原生的方法，都会根据继承的类型返回新的对象。他们都是依赖 constructor 属性实现的这一功能。 在上面的例子中： 1arr.constructor === PowerArray 所以当调用 arr.filter() 时，就像 new PowerArray 一样，他会在内部创建新的结果数组。并且我们可以继续链式调用它的方法。 更重要的是，我们可以定制这种行为。在这种情况下，如果存在静态的 getter Symbol.species，那么就会使用它的返回值作为构造函数。 举个例子，这里因为有 Symbol.species，像 map，``filter 这样的内置方法将返回“普通”数组： 1234567891011121314151617181920class PowerArray extends Array { isEmpty() { return this.length === 0; } // 内置函数会使用它作为构造函数 static get [Symbol.species]() { return Array; }}let arr = new PowerArray(1, 2, 5, 10, 50);alert(arr.isEmpty()); // false// filter 使用 arr.constructor[Symbol.species] 作为构造函数创建了新数组let filteredArr = arr.filter(item =&gt; item &gt;= 10);// filteredArr 不是 PowerArray，而是一个 普通数组alert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function JavaScript 中的 Mixin 模式根据维基百科的定义，mixin 是一个包含许多供其它类使用的方法的类，而且这个类不必是其它类的父类。 换句话说，一个 mixin 提供了许多实现具体行为的方法，但是我们不单独使用它，我们用它来将这些行为添加到其它类中。 ###一个 Mixin 实例在 JavaScript 中构造一个 mixin 最简单的方式就是构造一个拥有许多实用方法的对象，通过这个对象我们可以轻易地将这些实用方法合并到任何类的原型中。 例如，这个叫做 sayHiMixin 的 mixin 用于给 User 添加一些“言语”。 1234567891011121314151617181920212223// mixinlet sayHiMixin = { sayHi() { alert(`Hello ${this.name}`); }, sayBye() { alert(`Bye ${this.name}`); }};// 用法：class User { constructor(name) { this.name = name; }}// 拷贝方法Object.assign(User.prototype, sayHiMixin);// 现在 User 可以说 hi 了new User(\"Dude\").sayHi(); // Hello Dude! 没有继承，只有一个简单的方法拷贝。因此 User 可以扩展其它类并且同样包含 mixin 来 “mix-in”其它方法，就像这样： 12345class User extends Person { // ...}Object.assign(User.prototype, sayHiMixin); Mixin 可以在自己内部使用继承。 比如，这里的 sayHiMixin 继承于 sayMixin： 1234567891011121314151617181920212223242526272829let sayMixin = { say(phrase) { alert(phrase); }};let sayHiMixin = { __proto__: sayMixin, // （或者，我们可以在这里通过 Object.create 来设置原型。） sayHi() { // 调用父类中的方法 super.say(`Hello ${this.name}`); }, sayBye() { super.say(`Bye ${this.name}`); }};class User { constructor(name) { this.name = name; }}// 拷贝方法Object.assign(User.prototype, sayHiMixin);// 现在 User 可以说 hi 了new User(\"Dude\").sayHi(); // Hello Dude! 请注意在 sayHiMixin 内部对于父类方法 super.say() 的调用会在 mixin 的原型上查找方法而不是在 class 自身查找。 那是因为 sayHiMixin 内部的方法设置了 [[HomeObject]] 属性。因此 super 实际上就是 sayHiMixin.__proto__ ，而不是 User.__proto__。 EventMixin现在让我们为了实际运用构造一个 mixin。 许多对象的重要特征是与事件一起工作。 也就是说：对象应该有一个方法在发生重要事件时“生成事件”，其它对象应该能够“监听”这样的事件。 一个事件必须有一个名称，并可以选择性的捆绑一些额外的数据。 比如说，一个 user 对象能够在访问者登录时产生“login”事件。另一个 calendar 对象可能在等待着接受一个这样的事件以便为登录后的用户加载日历。 或者，menu 在菜单选项被选择之后会产生 “select“ 事件，并且其它对象可能在等待着接受事件的信息并且对事件做出反应。 事件是一种与任何想要得到信息的人分享信息的方式。它在任何类中都可以使用，因此现在为它构造一个 mixin。 12345678910111213141516171819202122232425262728293031323334353637383940 let eventMixin = { /** * 订阅事件，用法： * menu.on('select', function(item) { ... } */ on(eventName, handler) { if (!this._eventHandlers) this._eventHandlers = {}; if (!this._eventHandlers[eventName]) { this._eventHandlers[eventName] = []; } this._eventHandlers[eventName].push(handler); }, /** * 取消订阅，用法： * menu.off('select', handler) */ off(eventName, handler) { let handlers = this._eventHandlers &amp;&amp; this._eventHandlers[eventName]; if (!handlers) return; for (let i = 0; i &lt; handlers.length; i++) { if (handlers[i] === handler) { handlers.splice(i--, 1); } } }, /** * 触发事件并传递参数 * this.trigger('select', data1, data2); */ trigger(eventName, ...args) { if (!this._eventHandlers || !this._eventHandlers[eventName]) { return; // 对应事件名没有事件处理函数。 } // 调用事件处理函数 this._eventHandlers[eventName].forEach(handler =&gt; handler.apply(this, args)); }}; 有三个方法： .on(eventName, handler) — 指定函数 handler 在具有对应事件名的事件发生时运行。这些事件处理函数存储在 _eventHandlers 属性中。.off(eventName, handler) — 在事件处理函数列表中移除指定的函数。.trigger(eventName, ...args) — 触发事件：所有被指定到对应事件的事件处理函数都会被调用并且 args 会被作为参数传递给它们。用法： 1234567891011121314151617// 新建一个 classclass Menu { choose(value) { this.trigger(\"select\", value); }}// 添加 mixinObject.assign(Menu.prototype, eventMixin);let menu = new Menu();// 被选中时调用事件处理函数：menu.on(\"select\", value =&gt; alert(`Value selected: ${value}`));// 触发事件 =&gt; 展示被选中的值：123menu.choose(\"123\"); // 被选中的值 现在如果我们已经有了针对用户选择事件做出具体反应的代码，可以将代码使用 menu.on(…) 进行绑定。 只要我们喜欢，就可以通过 eventMixin 将这些行为添加到任意个数的类中而不影响继承链。 总结Mixin — 是一个通用的面向对象编程术语：一个包含其他类的方法的类。 一些其它语言比如 python 允许通过多继承实现 mixin``。JavaScript 不支持多继承，但是可以通过拷贝多个类中的方法到某个类的原型中实现 mixin。 我们可以使用 mixin 作为一种通过多种行为来增强类的方式，就像我们上面看到的事件处理一样。 如果 Mixins 偶尔会重写原生类中的方法，那么 Mixins 可能会成为一个冲突点。因此通常情况下应该好好考虑 mixin 的命名，以减少这种冲突的可能性。","link":"/posts/6f845446/"},{"title":"Js现代教程笔记 -- this 值的探索","text":"对于 Js 中 this 值的探索this 基本介绍在 JS 中，有很多时候，对象方法需要访问对象本身的数据来完成其工作，为了访问对象本身，方法中可以使用 this 关键字。如下所示： 1234567891011let obj = { name: obj, age: 30, sayHi() { alert(this.name); // this 的值就是调用该方法的对象，在下方的调用中，就是 `.` 操作符前面的对象。 }};user.sayHi(); // obj 在没有 . 操作符的情况下（即没有对象引用的情况下），this 的值在严格模式下为 undefined, 在非严格模式下为全局对象 window 或者 注意，this 的值只在调用时被确定，不取决于 this 被声明的位置，只取决于 . 操作符前面的对象。 this 丢失与引用类型复杂的方法调用可能会失去 this，比如： 12345678let user = { name: \"John\", hi() { alert(this.name); }}// 将赋值与方法调用拆分为两行let hi = user.hi;hi(); // 错误，因为 this 未定义 对于方法调用 obj.method() 语句中有两个操作符： . 操作符：取得这个 obj.method 的属性（即这个函数|方法的引用类型的值） 使用 () 调用它在这里，如果把这两个操作符分开操作，this 的值将会丢失，如下： 12345678let user = { name: \"John\", hi() { alert(this.name); }}// split getting and calling the method in two lineslet hi = user.hi;hi(); // Error, because this is undefined 为了确保 user.hi() 调用能正常工作，JS 用了一个小技巧—— .操作符返回的只是一个特殊的引用类型的值，而不是一个函数。 我们无法使用这个这个特殊的引用类型，它只在语言内部被使用。 这个引用类型的值由三个部分组成 (base, name, strict)： base 指的是 . 操作符前面的对象。 nama 就是属性名（方法名） strict 是一个布尔值，表示是否开启严格模式。 当特殊引用类型的值使用了 () 操作符，它们接受了完整的对象和方法，并且能够准确地设置 this 值 但如果将尝试将函数赋值给一个变量(例如 let hi = user.sayhi)，那么特殊引用类型的值将会被整个丢弃，this 的值也随之丢失 使用 function.call() 和 function.apply() 改变 this 的指向,使用 function.bind() 绑定 this 值call 与 apply接上文，当函数赋值给另外一个变量，this 值丢失以后，我们可以使用 function.call(context, arg1, arg2, ...rest) 或者 function.apply(context, [arg1, arg2, ...rest])显示地指定 this 值，如下： 12345678910let user = { name: \"John\", hi() { alert(this.name); }}// split getting and calling the method in two lineslet hi = user.hi;hi(); // Error, because this is undefinedhi.call(user) //it workshi.apply(user) //it works 注意 function.call(context, arg1, arg2, ...rest) 和 function.apply(context, [arg1, arg2, ...rest]) 的区别只在于指定this值之后的参数传递方式，call 方法是接受一个参数列表，而 apply 则接受带有一个类似数组的对象。 以下的调用结果完全相同： 1234let args = [1, 2, 3];func.call(context, ...args); // 使用 spread 运算符将数组作为参数列表传递func.apply(context, args); // 与使用 apply 相同 如果我们仔细观察，那么 call 和 apply 的使用会有一些细微的差别。 扩展运算符 ... 允许将 可迭代的 参数列表 作为列表传递给 call。 apply 只接受 类似数组一样的 参数列表。 所以，这些调用方式相互补充。我们期望有一个可迭代的 call 实现，我们也期望有一个类似数组，apply 的实现。 如果 参数列表 既可迭代又像数组一样，就像真正的数组一样，那么我们在技术上可以使用它们中的任何一个，但是 apply 可能会更快，因为它只是一个操作。大多数 JavaScript 引擎内部优化比一对 call + spread 更好。 apply 的进阶用法 呼叫转移(forwarding) 方法借用(Borrowing a method) bind 方法函数对象提供了一个内建方法 bind，它可以固定住 this。function.bind(context), 该方法用于绑定 this 值，从而实现将函数赋值给变量时， 不会丢失 this 的值，该方法返回一个函数。 bind、call、apply区别call、apply： 接受上下文和参数，显式地指定 this 值，返回的是函数结果bind: 只接受上下文，绑定 this 值，返回一个函数。 箭头函数的 this箭头函数没有 this 值，在箭头函数内使用的 this 值直接指向箭头函数的外部正常函数的上下文。 构造函数中 new 操作符对 this 的影响当一个函数作为 new ClassName(...)执行时，它执行以下步骤： 一个新的空对象被创建并分配给 this。 函数体执行。通常它会修改 this，为其添加新的属性。 返回 this 的值。","link":"/posts/24667931/"},{"title":"Js现代教程笔记 -- 函数高阶应用","text":"函数高阶应用递归和堆栈递归递归是函数「自调用」的编程术语。这种函数可以被用来优雅解决特定的任务。 当一个函数调用自身时，我们称其为递归步骤。递归基础是函数参数使得任务很简单，不需要其它更进一步调用。 任何递归函数都可以被重写为迭代形式。这是优化时做的事情。对多数任务，递归解决方式足够快且容易编写和维护。 Rest 参数与 Spread 操作符当我们在代码中遇到 “…” 时，它不是 Rest 参数就是 Spread 操作符。 我们可以使用下列方法区分二者： 若 … 出现在函数的参数列表，那它表示的就是 Rest 参数，它会把函数多余的实参收集到一个数组中。 若 … 出现在函数调用或类似的表达式中，那它就是 Spread 操作符，它会把一个数组展开为逗号分隔的元素列表。 使用场景： Rest 参数用于创建可接收任意个参数的函数。 Spread 操作符可以在函数调用传参时，把含有参数的数组展开为函数需要的参数列表形式。这两个操作符的出现方便了我们在参数数组和参数列表间来回转换。 “旧式”的 arguments（返回所有参数的类数组对象）也依然能够帮助我们获取函数调用时的所有参数。 var 声明变量var 声明变量与 let/const 变量声明有两点主要区别： 变量没有块作用域，它们在最小函数级可见； 变量声明在函数开头处理。 全局对象里不会有 let/const 声明的变量，即用 let/const 声明的全局变量无法使用 window 对象访问 函数对象与命名函数表达式(Named Function Expression)函数就是对象。命名函数表达式,指代有名字的函数表达式的术语。 我们介绍了它们的一些属性： name – 函数的名字。不仅仅在函数定义指定时存在，而且在赋值或者对象属性中也会有。 length – 函数定义时的入参个数。余参不参与计数。 而且，函数可以有额外的自定义属性 1234属性不是变量一个被赋值的函数属性，比如 `sayHi.counter` = 0 没有在函数内定义一个局部变量 `counter`。或者说，一个 `counter` 属性与一个 `let counter` 的变量是毫不相关的两个东西。我们可以把函数当作对象，在它里面存储属性，但是这对它的执行没有任何影响。变量不会使用函数属性，反之亦然。它们是不相干的词。 函数属性有时会用来替代闭包。比如，我们可以将 闭包 章节中计数函数的例子改写为用函数属性实现： 12345678910111213141516 function makeCounter() { // 不再用： // let count = 0 function counter() { return counter.count++; }; counter.count = 0; return counter;}let counter = makeCounter();alert( counter() ); // 0alert( counter() ); // 1 count 直接被存储在函数里，而不是它外部的词法环境。 那么它和闭包谁好谁赖？ 两者最大的不同就是如果 count 的值位于外层（函数）变量中，那么外部的代码无法访问到它，只有嵌套的函数可以修改它，而如果它是绑定给函数的，那么就很容易： 12345678910111213141516function makeCounter() { function counter() { return counter.count++; }; counter.count = 0; return counter;}let counter = makeCounter();counter.count = 10;alert( counter() ); // 10 所以，如何实现取决于我们的目标。 如果函数是通过函数表达式被声明的（不是在主代码流里），它附带了名字，那么它被称为命名的函数表达式(NFE)。可以用来在函数内部引用自己，或者递归调用等诸如此类场景。有两个特殊的地方: 它允许函数在内部引用自己。 它在函数外是不可见的。 new function 语法let func = new Function ([arg1[, arg2[, ...argN]],] functionBody) 即在创建函数时，先传入函数所需的参数（准确地说是形参名），最后传入函数的函数体。传入的所有参数均为字符串。 与已知方法相比这种方法最大的不同是，它是在运行时使用描述函数的字符串来创建函数的。 之前的各种声明方法都需要我们 —— 程序员，在脚本中编写各个函数的代码。 但是 new Function 允许我们把字符串变为函数，所以现在我们完全可以从服务器获取并执行一个新的函数 使用 new Function 创建函数的应用场景非常特殊，比如需要从服务器获取代码或者动态地按模板编译函数时才会使用，在一般的程序开发中很少使用。 使用 new Function 创建出来的函数，它的 [[Environment]] 指向全局词法环境，而不是函数所在的外部词法环境。因此，我们不能在新函数中直接使用外部变量。不过这样也挺好，这有助于减少我们代码中可能出现的错误。同时使用参数显式地传值也有助于维护良好的代码结构且避免了因使用 minifier 带来的问题。 调度: setTimeout 和 setIntervalsetInterval(func, delay, ...args) 和 setTimeout(func, delay, ...args) 可以让 func 定期或经历一段延时后一次性执行。 要取消函数的执行需要调用 clearInterval/clearTimeout，只需将 setInterval/setTimeout 返回的值传入即可。 嵌套 setTimeout 比 setInterval 用起来更加灵活，同时也能保证每一轮执行的最小时间间隔。 0 延时调度 setTimeout(...,0) 用来安排在当前代码执行完时，需要尽快执行的函数。 setTimeout(...,0) 的一些用法示例： 将耗费 CPU 的任务分割成多块，这样脚本运行不会进入“挂起”状态。 进程繁忙时也能让浏览器抽身做其它事情（例如绘制进度条）。 12345678910111213141516171819202122232425&lt;!--给浏览器渲染的机会行间脚本还有个益处，可以用来向用户展示进度条等。因为浏览器在所有脚本执行完后，才会开始“重绘（repainting）”过程。所以，如果运行一个非常耗时的函数，即便在这个函数中改变了文档内容，除非这个函数执行完，那么变化是不会立刻反映到页面上的。--&gt;&lt;div id=\"progress\"&gt;&lt;/div&gt;&lt;script&gt; let i = 0; function count() { // 每次只完成一部分 (*) do { i++; progress.innerHTML = i; } while (i % 1e3 != 0); if (i &lt; 1e9) { setTimeout(count, 0); } } count();&lt;/script&gt; 有一点需要注意，所有的调度方法都不能保证延时的准确性，所以在调度代码中，万不可依赖它。 浏览器内部的定时器会因各种原因而出现降速情况，譬如： CPU 过载。 浏览器页签切换到了后台模式。 笔记本电脑用的是电池供电（译者注：使用电池会以降低性能为代价提升续航）。 如果出现以上情况，定时器的最高精度（最高精确延时）可能会降到 300 毫秒，甚至是 1000 毫秒，具体以浏览器及其设置为准。 装饰和转发 call 和 apply装饰器 1234567891011121314function decorator(func) { let catch = new Map() return function(x) { let result if (catch.has(x)) { return catch.get(x) } result = func.call(this, x) catch.set(x, result) return result }}","link":"/posts/a284be5d/"},{"title":"Js现代教程笔记 -- 原型与继承","text":"原型与继承原型链在 JavaScript 中，每个对象都有一个特殊的隐藏属性 [[Prototype]] ，该属性的值只能是 null 或者其他对象的引用(叫做 原型对象)。 [[Prototype]] 有一个“神奇”的意义。当我们想要从 object 中读取一个属性时，它就丢失了。JavaScript 会自动从原型中获取它。在编程中，这样的事情称为“原型继承”。 原型对象 [[Prototype]]原型对象 [[Prototype]] 是一个内部，而且隐藏的对象，我们可以用以下及中方法来设置它： __proto__ 方法__proto__ 是历史遗留的 [[Prototype]]对象的 getter/setter，注意，这只是一个 getter/setter。(不推荐使用在客户端，但可以用于服务器端) 我们可以手动通过 __proto__ 设置对象的原型，如下： 1234567891011121314151617181920let animal = {eats: true,walk() { alert(\"Animal walk\");}};let rabbit = {jumps: true,__proto__: animal //*};let longEar = {earLength: 10,__proto__: rabbit //*};// walk is taken from the prototype chainlongEar.walk(); // Animal walkalert(longEar.jumps); // true (from rabbit) 注意，对于 __proto__ 有两个限制： The references can’t go in circles. JavaScript will throw an error if we try to assign __proto__ in a circle. The value of __proto__ can be either an object or null, other types (like primitives) are ignored. 使用 Object.getPrototypeOf/Object.setPrototypeOf方法(推荐使用，详看下方 关于原型的方法e) 原型作用于数据属性的读取只有对象数据属性的读取会涉及到原型，对象数据属性的写入以及删除一般与原型无关。如下： 12345678910111213141516171819let animal = { eats: true, walk() { alert('animal') /* this method won't be used by rabbit */ }};let rabbit = { __proto__: animal};rabbit.walk(); // animal *rabbit.walk = function() { alert(\"Rabbit! Bounce-bounce!\");};rabbit.walk(); // Rabbit! Bounce-bounce! ** *处的 walk()方法是读取了原型中的 walk()方法，之后实例 rabbit 写入了一个新的 walk()方法，因而在 ** 处不在调用原型链的 walk()方法 原型作用于访问器属性如果一个原型对象的属性有 getter/setter， 那么我们会在原型中查找并操作它 12345678910111213141516171819202122let user = { name: \"John\", surname: \"Smith\", set fullName(value) { [this.name, this.surname] = value.split(\" \"); }, get fullName() { return `${this.name} ${this.surname}`; }};let admin = { __proto__: user, isAdmin: true};alert(admin.fullName); // John Smith (*)// setter triggers!admin.fullName = \"Alice Cooper\"; // (**) * 处的属性 admin.fullName 在原型对象 user 中有一个 getter,所以此处调用了该 getter， ** 处的属性也有一个 setter 在原型对象中，也因此调用了该 setter 上面例子中的 this 的值或许会有一些疑问，但是，无论在哪里找到方法：在对象或者原型中。调用方法时，this 始终是点之前的对象。，如下： 12345678910111213141516171819202122// animal has methodslet animal = { walk() { if (!this.isSleeping) { alert(`I walk`); } }, sleep() { this.isSleeping = true; }};let rabbit = { name: \"White Rabbit\", __proto__: animal};// modifies rabbit.isSleepingrabbit.sleep();alert(rabbit.isSleeping); // truealert(animal.isSleeping); // undefined (no such property in the prototype) 如果我们从 animal 继承像 bird、snake 等其他对象，他们也将获取 animal 的方法。但是每个方法 this 都是相应的对象，而不是 animal，在调用时（在点之前）确定。因此当我们将数据写入 this 时，它会被存储进这些对象中。 因此，方法是共享的，但对象状态不是。 总结 JavaScript 中，所有的对象都有一个隐藏的 [[Prototype]] 属性，它可以是另一个对象或者 null。 我们可以使用 obj.proto 进行访问（还有其他方法，但很快就会被覆盖）。 [[Prototype]] 引用的对象称为“原型”。 如果我们想要读取 obj 属性或者调用一个方法，而且它不存在，那么 JavaScript 就会尝试在原型中查找它。写/删除直接在对象上进行操作，它们不使用原型（除非属性实际上是一个 setter）。 如果我们调用 obj.method()，而且 method 是从原型中获取的，this 仍然会引用 obj。因此方法重视与当前对象一起工作，即使它们是继承的。 函数原型每个函数都有 &quot;prototype&quot; 属性，即使我们不设置它。 默认的 &quot;prototype&quot; 是一个只有属性 constructor 的对象，它指向函数本身。 当用 new Fn() 创建一个新对象时，该新对象的 [[Prototype]] 被设置为 Fn.prototype。 总结 Fn.prototype 属性与 [[Prototype]] 不同。Fn.prototype 唯一的作用是：当 new Fn() 被调用时，它设置新对象的 [[Prototype]]。 Fn.prototype 的值应该是一个对象或 null：其他值将不起作用。 &quot;prototype&quot; 属性仅在设置为构造函数时具有这种特殊效果，并且用 new 调用。 在常规对象上，prototype 没什么特别的： 1234let user = {name: \"John\",prototype: \"Bla-bla\" // no magic at all}; 默认情况下，所有函数都有 Fn.prototype = {constructor：Fn}，所以我们可以通过访问它的 &quot;constructor&quot; 属性来获得对象的构造函数。 注意，只有函数对象才拥有 prototype 属性能够直接操作 [[Prototype]]，其他实例对象要操作 [[Prototype]] 对象只能通过 __proto__ 方法或者 Object.getPrototypeOf/Object.setPrototypeOf等其他方法。 原生的原型所有的内置对象都遵循一样的模式： 方法都存储在原型对象上（Array.prototype、Object.prototype、Date.prototype 等）。 对象本身只存储数据（数组元素、对象属性、日期）。 基本数据类型同样在包装对象的原型上存储方法：Number.prototype、String.prototype 和 Boolean.prototype。只有 undefined 和 null 没有包装对象。 内置对象的原型可以被修改或者被新的方法填充。但是这样做是不被推荐的。只有当添加一个还没有被 JavaScript 引擎支持的新方法的时候才可能允许这样做。 方法借用： 1234567function showArgs() { // 从数组借用 join 方法并在 arguments 的上下文中调用 alert( [].join.call(arguments, \" - \") );}showArgs(\"John\", \"Pete\", \"Alice\"); // John - Pete - Alice 因为 join 方法在 Array.prototype 对象上，我们可以直接调用它并且重写上面的代码： 123function showArgs() { alert( Array.prototype.join.call(arguments, \" - \") );} 这样是更有效率的，因为它避免了一个额外数组对象 [] 的创建。另一方面，这样做，需要更长的时间来编写。 关于原型的方法上文提到的 __proto__ 方法已经开始被弃用，推荐使用以下方法操作 [[Prototype]]: Object.create(proto[, descriptors]) —— 利用 proto 作为 [[Prototype]] 和可选的属性描述来创建一个空对象。 1234567891011let animal = { eats: true};// 第二个参数传递的是 属性描述符 对象，其他 flag 默认为 falselet rabbit = Object.create(animal, { jumps: { value: true }});alert(rabbit.jumps); // true 我们可以利用 Object.create 来实现比 for..in 循环赋值属性方式更强大的对象复制功能： 12// obj 对象的浅复制let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); 这样实现了 obj 的完整复制，包含了所有属性：可枚举的和不可枚举的，数据属性以及 seeters/getters —— 所有属性，以及正确的 [[Prototype]]。 Object.getPrototypeOf(obj) —— 返回 obj 对象的 [[Prototype]]。 Object.setPrototypeOf(obj, proto) —— 将 obj 对象的 [[Prototype]] 设置为 proto。 从技术上来讲，我们可以在任何时候 get/set [[Prototype]]。但是通常我们只在创建对象的时候设置它一次，自那之后不再修改。对此 JavaScript 引擎做了高度的优化。运行中利用 Object.setPrototypeOf 或者 obj.__proto__= 来更改 prototype 是一个非常缓慢的操作。但是，这是可行的。 注意 __proto__根本不是一个对象的属性，只是 Object.prototype 的访问属性，如果 obj.__proto__ 被读取或者赋值，那么对应的 getter/setter 从它的原型被调用，它会获取/设置 [[Prototype]]。 极简对象我们可以用 Object.create(null) 创建一个空对象，这个对象没有原型（[[Prototype]] 是 null） 它没有继承 __proto__ 的 getter/setter 方法。现在它像正常的数据属性一样运行.我们可以叫这样的对象「极简」或者「纯字典对象」，因此它们甚至比通常的简单对象 {...} 还要简单。 这样的对象有一个缺点是缺少内置的对象方法，比如说 toString 123let obj = Object.create(null);alert(obj); // Error （没有 toString 方法） 请注意，和对象关系最密切的方法是 Object.something(...)，比如 Object.keys(obj) —— 它们不在 prototype 中，因此在极简对象中它们还是可以继续使用 12345let chineseDictionary = Object.create(null);chineseDictionary.hello = \"ni hao\";chineseDictionary.bye = \"zai jian\";alert(Object.keys(chineseDictionary)); // hello,bye 获取对象所有属性获取一个对象的键/值有很多种方法。 我们已知的有： -Object.keys(obj) / Object.values(obj) / Object.entries(obj) – 返回一个数组，包含所有可枚举字符串属性 名称/值/键值对。这些方法只会列出可枚举属性，而且它们键名为字符串形式。 Object.getOwnPropertySymbols(obj) —— 返回包含所有 symbol 属性名称的数组。如果我们想要非可枚举属性： Object.getOwnPropertyNames(obj) —— 返回包含所有字符串属性名的数组。如果我们想要所有属性： Reflect.ownKeys(obj) —— 返回包含所有属性名称的数组。这些方法和它们返回的属性有些不同，但它们都是对对象本身进行操作。prototype 的属性没有包含在内。 for...in 循环有所不同：它会对继承得来的属性也进行循环。 举个例子： 1234567891011121314let animal = { eats: true};let rabbit = { jumps: true, __proto__: animal};// 这里只有自身的键alert(Object.keys(rabbit)); // jumps// 这里包含了继承得来的键for(let prop in rabbit) alert(prop); // jumps，然后 eats 如果我们想要区分继承属性，有一个内置方法 obj.hasOwnProperty(key)：如果 obj 有名为 key 的自身属性（而非继承），返回值为 true。 因此我们可以找出继承属性（或者对它们进行一些操作）： 12345678910111213let animal = { eats: true};let rabbit = { jumps: true, __proto__: animal};for(let prop in rabbit) { let isOwn = rabbit.hasOwnProperty(prop); alert(`${prop}: ${isOwn}`); // jumps:true, then eats:false} 这个例子中我们有以下继承链：rabbit，然后 animal，然后 Object.prototype （因为 animal 是个字面量对象 {...}，因此默认是这样），然后最终到达 null 请注意：这里有一个有趣的现象。rabbit.hasOwnProperty 这个方法来自哪里？观察继承链我们发现这个方法由 Object.prototype.hasOwnProperty 提供。换句话说，它是继承得来的。 …但是如果说 for...in 列出了所有继承属性，为什么 hasOwnProperty 这个方法没有出现在其中？答案很简单：它是不可枚举的。就像所有其他在 Object.prototype 中的属性一样。这是为什么它们没有被列出的原因。 总结 Object.create(proto[, descriptors]) —— 利用给定的 proto 作为 [[Prototype]] 来创建一个空对象。 Object.getPrototypeOf(obj) —— 返回 obj 的 [[Prototype]]（和 __proto__ getter 相同）。 Object.setPrototypeOf(obj, proto) —— 将 obj 的 [[Prototype]] 设置为 proto（和 __proto__ setter 相同）。 Object.keys(obj) / Object.values(obj) / Object.entries(obj) —— 返回包含自身属性的名称/值/键值对的数组。 Object.getOwnPropertySymbols(obj) —— 返回包含所有自身 symbol 属性名称的数组。 Object.getOwnPropertyNames(obj) —— 返回包含所有自身字符串属性名称的数组。 Reflect.ownKeys(obj) —— 返回包含所有自身属性名称的数组。 obj.hasOwnProperty(key)：如果 obj 拥有名为 key 的自身属性（非继承得来），返回 true。 同时我们还明确了 __proto__ 是 [[Prototype]] 的 getter/setter，位置在 Object.prototype，和其他方法相同。 我们可以不借助 prototype 创建一个对象，那就是 Object.create(null)。这些对象被用作是「纯字典」，对于它们而言 &quot;__proto__&quot;作为键没有问题。 所有返回对象属性的方法（如 Object.keys 以及其他）—— 都返回「自身」属性。如果我们想继承它们，我们可以使用 for...in。","link":"/posts/7443f62b/"},{"title":"Js现代教程笔记 -- 对于函数参数的见解","text":"对于函数参数的见解function 对象的 length 属性function 对象有内置属性 “length”，它返回函数入参的个数，余参不参与计数。 function 对象的 arguments 属性函数的上下文会提供一个非常特殊的类数组对象 arguments，所有的参数被按序放置。例如： 1234567891011121314 function showName() { alert( arguments.length ); alert( arguments[0] ); alert( arguments[1] ); // 它是可遍历的 // for(let arg of arguments) alert(arg);}// 依次弹出提示：2，Julius，CaesarshowName(\"Julius\", \"Caesar\");// 依次弹出提示：1，Ilya，undefined（不存在第二个参数）showName(\"Ilya\"); 在 JavaScript 引入 Rest 参数之前，无论入参数是多是少，想获取所有的入参只能使用 arguments。 时至今日，这仍是一个可用的方法。 即使 arguments 是一个类数组且可遍历的变量，但它终究不是数组。它没有数组原型链上的函数，我们没法直接调用诸如 arguments.map(...) 等这样的函数。 同样的，因为它总是包含所有的参数，我们并不能像使用 Rest 参数一样，期望它只截取入参的一部分。 function 对象的 …rest 操作符在定义函数时使用 Rest 参数，Rest 参数的操作符表示为3个点 ...。直白地讲，它的意思就是 “把剩余的参数都放到一个数组中”。举个例子，我们需要把所有的参数都放到数组 args 中： 1234567891011 function sumAll(...args) { // 数组变量名为 args let sum = 0; for (let arg of args) sum += arg; return sum;}alert( sumAll(1) ); // 1alert( sumAll(1, 2) ); // 3alert( sumAll(1, 2, 3) ); // 6 我们也可以显式地定义和取用前面部分的参数，而把后面部分的参数收集起来。 下面的例子即把前两个参数定义为变量，同时把剩余的参数收集到 titles 数组中： 1234567891011 function showName(firstName, lastName, ...titles) { alert( firstName + ' ' + lastName ); // Julius Caesar // titles 数组中包含了剩余的参数 // 也就是有 titles = [\"Consul\", \"Imperator\"] alert( titles[0] ); // Consul alert( titles[1] ); // Imperator alert( titles.length ); // 2}showName(\"Julius\", \"Caesar\", \"Consul\", \"Imperator\");","link":"/posts/14294c2c/"},{"title":"Js现代教程笔记 -- 对象属性","text":"对象属性1 对象属性标志和描述符1.1 属性标志对象的属性除了值(value)以e外，还有通常情况下不可见的特殊属性：标志(flag)。标志的值都是布尔值 writable：为 true ,则该属性可被修改，否则为只读属性 enumerable：为 true, 则该属性可被枚举。 configurable： 为 true, 则该属性可被删除和修改。 当我们为对象添加属性时，属性的标志默认为 true。 1.1.1 writable: false //Read-only当一个属性的 wrirable 标志为 false 时, 无法改变该属性的值，除非使用 defineProperty 将writable 标志改为 true,之后才能改变该属性的值 1.1.2 enumerable: false //Non-enumerable一般来说，enumeable: false 的属性不会出现在 for-in 循环中，也不会出现在 Object.keys() 的返回值中。 1.1.3 configurable: false //Non-configurable一个 configurable: false 的属性将无法被删除，也无法使用 defineProperty 改变其 flag。这意味着将 configurable 的值改为 false 后将无法重置，必须小心。 注意，试图修改 writable:false 或者 configurable:false 的属性的操作只有在 strict 模式才会报错，在 no-strict 模式下，该操作无效，但错误将被忽略 1.1.4 读取属性标志的方法：Object.getOwnPropertyDescriptor(obj, propertyName) 该方法返回叫做 属性描述符 (property descriptor)对象，包含所有的 flag，例如： 123456789101112131415let user = { name: \"John\"};let descriptor = Object.getOwnPropertyDescriptor(user, 'name');alert( JSON.stringify(descriptor, null, 2 ) );/* property descriptor:{ \"value\": \"John\", \"writable\": true, \"enumerable\": true, \"configurable\": true}*/ 1.1.5 修改属性标志的方法:Object.defineProperty(obj, propertyName, descriptor) 如果该属性存在，那么该方法会更新它的 Flag。否则，它会根据给定的值和 flag 来新建该属性，在这种情况下，如果有一个 flag 没有提供，那么它会默认该 Flag 为 false当我们使用 描述器 创建一个属性，它的标识默认是 false 。如下： 1234567891011121314151617let user = {};Object.defineProperty(user, \"name\", { value: \"John\"});let descriptor = Object.getOwnPropertyDescriptor(user, 'name');alert( JSON.stringify(descriptor, null, 2 ) );/*{ \"value\": \"John\", \"writable\": false, \"enumerable\": false, \"configurable\": false} */ 注意，使用其他方法创建的属性，其 flag 默认为 true,与使用 defineProperty 方法创建的属性的 flag 有很大不同另一种修改或定义属性的 flag 的方法： Object.defineProperties(obj, {propertyName1:{flags}, propertyName2:{flag}, ...})该方法也可以用来一次性修改多个属性的 flag,例如: 12345Object.defineProperties(user, { name: { value: \"John\", writable: false }, surname: { value: \"Smith\", writable: false }, // ...}); 1.1.6 Object.getOwnPropertyDescriptors(obj)该方法可以一次性获得属性的所有描述符 该方法可以与 Object.defineProperties 方法来克隆一个对象let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj)); 这种克隆方法与 for..in 克隆的区别在于： for...in 方法并不复制 flags for...in 方法会忽视掉 symbolic 属性，但 Object.getOwnPropertyDescriptors 会返回包括 symbolic属性在内的所有属性描述符对象 1.1.7 设定一个全局的封闭对象属性描述符可以在各个属性的级别上工作。 还有一些限制访问整个对象的方法： Object.preventExtensions(obj)禁止向对象添加属性。 Object.seal(obj)禁止添加/删除属性，为所有现有的属性设置 configurable: false。 Object.freeze(obj)禁止添加/删除/更改属性，为所有现有属性设置 configurable: false, writable: false。 还有对他们的测试： Object.isExtensible(obj)如果添加属性被禁止，则返回 false，否则返回 true。 Object.isSealed(obj)如果禁止添加/删除属性，则返回 true，并且所有现有属性都具有 configurable: false。 Object.isFrozen(obj)如果禁止添加/删除/更改属性，并且所有当前属性都是 configurable: false, writable: false，则返回 true。 1.2 属性的访问器属性 getter 和 setterJs 有两种属性： 数据属性 访问器属性：它们本质上是获取和设置值的函数，但从外部代码来看像常规属性。 访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 get 和 set 表示： 123456789let obj = { get propName() { // getter, the code executed on getting obj.propName }, set propName(value) { // setter, the code executed on setting obj.propName = value }}; 当读取 obj.propName 时，使用 getter，当设置值时，使用 setter。 例如： 123456789101112131415161718192021let user = { name: \"John\", surname: \"Smith\", get fullName() { return `${this.name} ${this.surname}`; }, set fullName(value) { [this.name, this.surname] = value.split(\" \"); }};// get fullNamealert(user.fullName) // John Smith// set fullName is executed with the given value.user.fullName = \"Alice Cooper\";alert(user.name); // Alicealert(user.surname); // Cooper 现在我们有一个“虚拟”属性。它是可读写的，但实际上并不存在。 从外表看，访问器属性看起来像一个普通的属性。这是访问器属性的设计思想。我们不以函数的方式调用 user.fullName，我们通常读取它：getter 在幕后运行。 访问器属性只能访问 get/set。属性可以是“数据属性”或“访问器属性”，但不能同时属于两者。一旦使用 get prop() 或 set prop() 定义了一个属性，它就是一个访问器属性。所以必须有一个 getter来读取它，如果我们对它赋值，它必须是一个 setter。有时候只有一个 setter 或者只有一个 getter 是正常的。但在这种情况下，该属性将不可读或可写 1.2.1 访问器描述符访问器属性的描述符与数据属性相比是不同的。 对于访问器属性，没有 value 和 writable，但是有 get 和 set 函数。 所以访问器描述符可能有： get —— 一个没有参数的函数，在读取属性时工作， set —— 带有一个参数的函数，当属性被设置时调用， enumerable —— 与数据属性相同， configurable —— 与数据属性相同。 例如，要使用 defineProperty 创建 fullName 的访问器，我们可以使用 get 和 set 来传递描述符： 123456789101112131415161718let user = { name: \"John\", surname: \"Smith\"};Object.defineProperty(user, 'fullName', { get() { return `${this.name} ${this.surname}`; }, set(value) { [this.name, this.surname] = value.split(\" \"); }});alert(user.fullName); // John Smithfor(let key in user) alert(key); // name, surname","link":"/posts/90bdcb8c/"},{"title":"Js现代教程笔记 -- 数据类型","text":"数据类型解构赋值 解构赋值允许将对象或数组立即映射到多个变量上。 解构对象的语法： 1let {prop : varName = default, ...} = object 这表示属性 prop 会被赋值给变量 varName，如果没有这个属性的话，就会使用 default 的值。 解构数组的语法： 1let [item1 = default, item2, ...rest] = array 数组的第一个元素赋值给 item1，第二个元素赋值给 item2，剩下的所有组成另一个数组 rest。**注意，这个 rest 是一个变量名，可以更改，但前面必须有 ... 。 更多复杂的案例情况下，等号左侧必须和等号右侧有相同的结构。 日期和时间需要注意的 Date 方法Date.getTime()返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始的毫秒数。 setTime(milliseconds)（使用自 1970-01-01 00:00:00 UTC+0 开始的毫秒数来设置整个日期对象） 对一个字符串使用 Date.parseDate.parse(str) 方法可以从一个字符串中读取日期。 字符串的格式是：YYYY-MM-DDTHH:mm:ss.sssZ，其中： -YYYY-MM-DD —— 日期：年-月-日。 字符串 “T” 是一个分隔符。 HH:mm:ss.sss —— 时间：小时，分钟，秒，毫秒。 可选字符 ‘Z’ 代表时区。单个字符 Z 代表 UTC+0。简短形式也是可以的，比如 YYYY-MM-DD 或者 YYYY-MM 又或者 YYYY。 Date.parse(str) 方法会转化一个特定格式的字符串，返回一个时间戳（自 1970-01-01 00:00:00 起的毫秒数），如果格式不正确，返回 NaN。 小结 在 JavaScript 中，日期和时间使用 Date 对象来表示。不能只创建日期，或者只创建时间，Date 对象总是两个都创建。 月份从 0 开始计数（对，一月是 0）。 一周的某一天 getDay() 同样从 0 开始计算（0 代表星期天）。 当超出范围的信息被设置时，Date 会做自我校准。这一点对于日/月/小时 的加减很有效。 日期可以相减，得到的是两者的差值，用毫秒表示。因为当转化为数字时，Date 对象变为时间戳。 使用 Date.now() 可以更快地得到当前时间的时间戳。 和其他语言不同，JavaScript 中时间戳是用毫秒表示，而不是秒。 同样，有时候我们会需要更加精准的时间度量。JavaScript 自身并不能度量微秒（一秒的百万分之一），但很多环境会提供。举个例子：浏览器拥有 performance.now() 方法来提供页面加载的微秒数（毫秒的小数点再右移三位）： 1234 alert(`Loading started ${performance.now()}ms ago`);// 得到 \"Loading started 34731.26000000001ms ago\"// .26 is 微秒(260 微秒)// 小数点后超过 3 位是错误，只有前三位是正确的 Node.JS 拥有 microtime 模块以及其他方法。从技术上来说，任何设备和环境都允许获取更精确的数值，不只是 Date 对象。 JSONJSON 支持 objects，arrays，strings，numbers，booleans 和 null。 JSON.stringify(value[, replacer, spaces])将对象转换为 JSON，注意重要的限制：不得有循环引用。参数说明: value: 要 JSON 化的变量或具体值 replacer：相当于一个过滤器,接受一组数组或者一个接受 key 和 value 键值对参数的函数(replacer 函数获取包括嵌套对象和数组项的每个键/值对。)，从 value 中过滤出需要 stringify 的具体属性和值，例如 ： 123456789101112131415161718192021222324252627282930313233let room = { number: 23};let meetup = { title: \"Conference\", participants: [{name: \"John\"}, {name: \"Alice\"}], place: room // meetup references room};room.occupiedBy = meetup; // room references meetup// 接受数组参数alert( JSON.stringify(meetup, ['title', 'participants']) );// {\"title\":\"Conference\",\"participants\":[{},{}]}// 接受函数参数alert( JSON.stringify(meetup, function replacer(key, value) { alert(`${key}: ${value}`); // to see what replacer gets return (key == 'occupiedBy') ? undefined : value;}));/* key:value pairs that come to replacer: : [object Object] title: Conference participants: [object Object],[object Object] 0: [object Object] name: John 1: [object Object] name: Alice place: [object Object] number: 23*/ 第一个调用很特别。它是使用特殊的“包装对象”制作的： {&quot;&quot;: meetup}。换句话说，第一个 (key,value) 对是空键，并且该值是整个目标对象。这就是为什么上面的例子中第一行是 &quot;:[object Object]&quot; 的原因。 space：用于格式化返回的 JSON 对象，通常意味着缩进 JSON.parse()JSON.parse(str[, reviver]) 解码 JSON 字符串,将 JSON 转换回对象。参数说明： str， JSON 字符串解析。 reviver 将为每个 (key,value) 对调用的可选函数（键，值）进行转换。例如： 12345678let str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';let meetup = JSON.parse(str, function(key, value) { if (key == 'date') return new Date(value); return value;});alert( meetup.date.getDate() ); // now works! 小结 JSON 是一种数据格式，对于大多数编程语言都有自己的独立标准和库。 JSON 支持 objects，arrays，strings，numbers，booleans 和 null。 JavaScript 提供序列化成 JSON 的方法 JSON.stringify和解析 JSON 方法 JSON.parse。 这两种方法都支持用于智能读/写的转换函数。 如果一个对象具有 toJSON，那么它可被 JSON.stringify 调用。 递归、堆栈、链表递归有一个基线堆栈，递归是一个堆的过程，每当递归一次，都会新建一个堆放在最上面，当该递归完成以后，堆才会从上到下慢慢执行","link":"/posts/3e0df05/"},{"title":"Js现代教程笔记 -- DOM","text":"DOM访问节点对于一个Dom节点，可以通过导航属性来立即访问和它直接相邻的节点 这些属性主要分两组： 对于所有的节点：parentNode、childNodes、firstChild、lastChild、previousSibling 和 nextSibling。 仅用于元素节点：parentElement、children、firstElementChild、lastElementChild、previousElementSibling 和 nextElementSibling。 某些类型的 DOM 元素，比如说像 tables，提供了额外的属性和集合用于访问其内容。&lt;table&gt; 元素支持 (除了上面给出的之外) 以下这些属性: table.rows — 用于表示表中 &lt;tr&gt; 元素的集合。 table.caption/tHead/tFoot — 用于访问元素 &lt;caption&gt;、&lt;thead&gt;、&lt;tfoot&gt;。 table.tBodies — &lt;tbody&gt; 元素的集合（根据标准该元素数量可以很多）。 &lt;thead&gt;、&lt;tfoot&gt;、&lt;tbody&gt; 元素提供了 rows 属性： tbody.rows — 表内部 &lt;tr&gt; 元素的集合。 &lt;tr&gt;： tr.cells — 在给定 &lt;tr&gt; 元素下 &lt;td&gt; 和 &lt;th&gt; 单元格的集合。 tr.sectionRowIndex — 在封闭的 &lt;thead&gt;/&lt;tbody&gt; 中 &lt;tr&gt; 的编号。 tr.rowIndex — 在表中 &lt;tr&gt; 元素的编号。 &lt;td&gt; 和 &lt;th&gt;： td.cellIndex — 在封闭的 &lt;tr&gt; 中单元格的编号。 搜索指定元素有 6 种主要的方法，可以在 DOM 中进行搜素： Method Searches by… Can call on an element? Live?(动态变化 Dom) getElementById id - - getElementsByName name - ✔ getElementsByTagName tag or ‘*’ ✔ ✔ getElementsByClassName class ✔ ✔ querySelector CSS-selector ✔ - querySelectorAll CSS-selector ✔ - 请注意，只有在文档 document.getElementById(…) 的上下文中才能调用 getElementById 和 getElementsByName。但元素中没有 elem.getElementById(…) 回报错。 也可以在元素上调用其他方法，例如 elem.querySelectorAll(…) 将会在 elem（在 DOM 子树中）内部进行搜素。 除此以外： elem.matches(css) 用于检查 elem 与给定的 CSS 选择器是否匹配。 elem.closest(css) 用于查找与给定 CSS 选择器相匹配的最近的祖先。elem 本身也会被检查。最后我们在提一种检查父子关系的方法： 如果 elemB 在 elemA（elemA 的后代）中或者当 elemA==elemB 时 elemA.contains(elemB) 将返回 true。 节点属性每个 DOM 节点都属于某个类。这些类形成层次结构。完整的属性和方法集是继承的结果。 DOM 节点的属性主要有： nodeType：我们可以从 DOM 对象类中获取 nodeType，但我们通常只需要查看它是文本节点还是元素节点。nodeType 属性就可以我们的需求。它有数值，最重要的是：1 —— 是元素，3 —— 是文本。只读。 nodeName/tagName对于元素来说，就是标记名（除了 XML 模式外都要大写）。对于非元素节点，nodeName 则描述了它是什么。只读。 innerHTMLHTML 的元素文本内容。可以被修改。修改结果会实时渲染在页面上 outerHTML元素的完整 HTML。写入 elem.outerHTML 的操作不会涉及 elem 自身。相反，它会在外部上下文中被替换成新的 HTML。结果不会实时渲染，如果需要操作，需要重新查询来获取元素引用 nodeValue/data非元素节点（文本、注释）内容。两者几乎一样，我们通常使用 data。允许被修改。 textContent元素中的文本，基本上是 HTML 减去所有 &lt;tags&gt;。将文本写入元素中，并把所有特殊字符和标记完全视为文本。可以安全地插入用户生成的文本，防止不必要的 HTML 插入。 hidden当设置为 true 时，执行与 CSS display:none 相同的操作。 DOM 节点还具有其他属性，具体内容则取决于它们的类。例如，&lt;input&gt;元素（HTMLInputElement）支持 value、type，而 &lt;a&gt; 元素（HTMLAnchorElement）则支持 href 等。大多数标准 HTML 属性都具有相应的 DOM 属性。 特性和属性Attributes —— 写在 HTML 中。Properties —— 是一个 DOM 对象。 - Properties Attributes 类型 一些值，标准化的属性值在规范中有类型描述 字符串 名字 键名大小写敏感 键名大小写不敏感 当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 文本并生成 DOM 对象。对于元素节点，大多数 HTML 特性会自动变成 DOM 对象的属性。 Dom 属性DOM 上的属性和方法其实就像是一个标准的 Javascript 对象： 它可以有很多值。 它是大小写敏感的（要写成 elem.nodeType，而不是 elem.NoDeTyPe） HTML 特性在 HTML 语言中，标签可能拥有特性。当浏览器读取 HTML 文本并根据标签生成 DOM 对象，它会辨别标准化特性然后以此创建 DOM 属性。但非标准化的特性会被忽略，读取其 DOM 属性将会返回 undefined。 一下使针对元素特性的操作(可操作非标准化的特性): elem.hasAttribute(name) —— 检验是否拥这个特性。 elem.getAttribute(name) —— 获取到这个特性值。 elem.setAttribute(name, value) —— 设置这个特性值。 elem.removeAttribute(name) —— 移除这个特性。 我们可以通过 elem.attributes 读取到该元素的所有特性：这些特性都被一个名为 Attr 的内置类以 name 和 value 这样的键-值对收集起来。 特性的键名大小写不敏感。 attributes 以 name 和 value 这样的键—值对收集在一个可迭代对象里。 属性—特性的同步当一个标准化的特性被改变，相应的属性随之改变（有极个别除外），反之亦然。比如input.value，只能从特性同步到属性，反过来则不行 此外，href 特性 DOM 属性总是一个绝对路径的，而特性值只包含相对路径或者只包含 #hash 这一部分。 非标准化的特性，dataset所有以 “data-” 开头的特性值可以给编程人员正常使用，同时它还是 dataset 合法值。 例如, 如果一个 elem 有一个键名是 “data-about” 的特性，那么可以通过 elem.dataset.about 取到这个合法值。像 data-order-state 的多字特性键名可以写成驼峰式属性dataset.orderState。 修改文档内容DOM（document object model 文档对象模型，此文中全部以缩写 DOM 表示）的可修改性是网页能“实时”刷新的关键。 创建节点的方法： document.createElement(tag) —— 用给定标签创建一个节点， document.createTextNode(value) —— 创建一个文本节点（很少使用）， elem.cloneNode(boolean) —— 如果参数 为true 将元素及后代子元素进行克隆。为 false 则只克隆元素本身 插入和移除节点的方法：注意，如果我们想要移动一个元素到另一个地方 —— 不需要移除旧的元素。所有插入操作都会从节点原来的位置把节点移除掉。 从 parent parent.appendChild(node) parent.insertBefore(node, nextSibling) parent.removeChild(node) parent.replaceChild(newElem, node)这些方法都返回 node。 添加一些节点和字符串： node.append(…nodes or strings) —— 在 node 末尾位置增加， node.prepend(…nodes or strings) —— 在 node开头位置增加 ， node.before(…nodes or strings) —— 在 node 之前位置增加， node.after(…nodes or strings) —— 在 node 之后位置增加， node.replaceWith(…nodes or strings) —— 替换 node。 node.remove() —— 移除 node。把字符串当成“文本”插入。 在 HTML 中添加内容 elem.insertAdjacentHTML(where, html)，在 where 位置进行操作： “beforebegin” —— 将 html 插入 elem 到开头的前面位置， “afterbegin” —— 将 html 插入 elem 到开头的后面位置， “beforeend” —— 将 html 插入 elem 到结尾的前面位置， “afterend” —— 将 html 插入 elem 到结尾的后面位置。elem.insertAdjacentText 和 elem.insertAdjacentElement 跟 elem.insertAdjacentHTML 很相似，只不过他们一个用来插入字符串，一个用来插入元素，但是很少使用这两个方法。 在页面加载完成之前添加 HTML 到页面中： document.write(html)如果是在页面加载完成以后调用会擦除加载完毕的内容。通常在很老的脚本才会使用这个方法了。 样式和类通常有两种方式来设计元素样式： 在 CSS 中创建一个类并添加它：&lt;div class=&quot;...&quot;&gt; 将属性直接写入 style：&lt;div style=&quot;...&quot;&gt;。CSS 总是首选的方式 —— 不仅用于 HTML，在 JavaScript 中也是如此。 只有当类“无法处理时”，我们才会操作 style 属性。 在管理 class 时，有两个 DOM 属性： className —— 字符串值可以很好地管理整个类集合。 classList —— 拥有 add/remove/toggle/contains 方法的对象可以很好地支持单独的类。 改变样式： style 属性是一个带有 camelCased 样式的对象。对它的读取和修改 “style” 属性中的单个属性等价。要留意如果应用 important 和其他稀有内容 —— 在 MDN 上有一个方法列表。 style.cssText 属性对应于整个“样式”属性，即完整的样式字符串。 获取已经解析的样式（对应于所有类，在应用所有 CSS 并计算最终值后）： getComputedStyle(elem[, pseudo]) 返回与 style 对象类似且包含了所有类的对象，是只读的。 元素 (elem) 的尺寸与滚动元素具有以下几何属性： offsetParent — 是最近的有定位属性的祖先元素，或者是 td、th、table、body。 offsetLeft/offsetTop — 是相对于 offsetParent 的左上角边缘坐标。 offsetWidth/offsetHeight — 元素的“外部”宽/高 ，边框尺寸计算在内。 clientLeft/clientTop — 从元素左上角外部到内部的距离(相当于 border的宽度)，对于从左到右渲染元素的操作系统，它始终是左/顶部边界的宽度，而对于从右到左的操作系统，垂直滚动条在左边，所以 clientLeft 也包括滚动条的宽度。 clientWidth/clientHeight — 内容的宽度/高度，包括内间距，但没有滚动条。(clientWidth/clientHeight 相当于 width|height + paddingLeft|paddingTop + paddingRight|paddingBottom) scrollWidth/scrollHeight — 内容的宽度/高度，包括可滚动的可视区域外的尺寸，也包括内间距，但不包括滚动条。 scrollLeft/scrollTop — 从左上角开始的元素的滚动部分的宽度/高度。除了 scrollLeft/scrollTop 之外，所有属性都是只读的。如果更改，浏览器会使元素滚动。 不要从 CSS 中获取宽高,我们应该使用集合属性获得宽高： 首先，CSS 宽度/高度取决于另一个属性：box-sizing，它定义了 “什么是” CSS 宽度和高度。用作 CSS 样式的 box-sizing 的更改可能会破坏这样的 JavaScript 定义。 其次，CSS 的 width/height 可能是 auto 还有一个原因：滚动条。有时，没有滚动条的代码工作得很好，因为它在一些浏览器中占据了内容的一部分空间。因此，内容的实际宽度比 CSS 宽度要小。 窗口 (Window) 的尺寸和滚动窗口的几何属性: 文档可视范围的宽度/高度（内容区域的宽高）：document.documentElement.clientWidth/Height 整个文档的宽度/高度，包括滚动区域外的部分： 12345let scrollHeight = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight); 窗口的滚动： 读取当前的滚动：window.pageYOffset/pageXOffset 改变当前的滚动： window.scrollTo(pageX,pageY) — 绝对定位-window.scrollBy(x,y) — 相对当前位置的滚动 elem.scrollIntoView(true|false) — 滚动到正好 elem可视的位置（elem 与- 窗口的顶部/底部对齐） 坐标大多数 JavaScript 方法处理的是以下两种坐标系中的一个： 相对于窗口（或者另一个 viewport）顶部/左侧计算的坐标 – elem.getBoundingClientRect(),该方法返回一个 elem 的窗口坐标对象，这个对象有以下这些属性： top — 元素顶部边缘的 Y 坐标 left — 元素左边边缘的 X 坐标 right — 元素右边边缘的 X 坐标 bottom — 元素底部边缘的 Y 坐标该方法的效果相当于 position: fixed 相对于文档顶部/左侧计算的坐标 – elem.getBoundingClientRect() + 加上当前页面滚动的长度。还方法相当于 relate 到 body 中的 position: absolute 两个坐标系可以通过由公式相连接： pageY = clientY + 文档垂直部分滚动的高度。 pageX = clientX + 文档水平部分滚动的宽度。 elementFromPoint(x, y)，该方法返回该窗口坐标(x, y)所在的元素注意，当参数为负数或超出窗口 (viewport) 大小时，将会返回 null 获取一个元素文档坐标的标准方法： 123456789// 获取元素的文档坐标function getCoords(elem) { let box = elem.getBoundingClientRect(); return { top: box.top + window.pageYOffset, left: box.left + window.pageXOffset };}","link":"/posts/a1a33672/"},{"title":"DOM学习","text":"DomNODE类型： Node.ELEMENT_NODE(1) Node.ATTRIBUTE_NODE(2) Node.TEXT_NODE(3) Node.CDATA_SECTION_NODE(4) Node.ENTITY_REFERENCE_NODE(5) Node.ENTITY_NODE(6) Node.PROCESSING_INSTRUCTION_NODE(7) Node.COMMENT_NODE(8) Node.DOCUMENT_NODE(9)： Node.DOCUMENT_TYPE_NODE(10) Node.DOCUMENT_FRAGMENT_NODE(11) Node.NOTATION_NODE(12) 所有 node都有 nodeType,nodeName,nodeValue属性，nodeType用于判断 node类型,nodeName和 nodeValue取决于 Node类型，对于元素来说，nodeName值元素的标签名，nodeValue为 null 节点关系子节点(childNodes)每个节点都有一个 childNodes属性，其中保存着一个 nodeList对象，是类数组对象，可以用索引值访问该对象，有 length属性，但不是数组。访问 nodeList可以使用方括号表示法，也可以使用 item()方法someNode.childNodes[0] == someNode.childNodes.item(0) 父节点 (parentNode)每个节点都有一个 parentNode属性，指向文档树中的父节点。在 childNodes列表中的所有节点都有相同的父节点，他们的 parentNode属性都指向同一个节点。父节点的 firstChild和 lastChild属性分别指向子节点列表的第一个和最后一个节点 同胞节点(nextSibling、previousSibling)在 childNodes丽奥表中的每个节点相互之间都是同胞节点，是用列表中每个节点的 previousSibling和 nextSibling属性可以访问同一列表的其他节点 操作节点someNode.appendChild()方法，用于向 childNode列表的末尾添加一个节点，如果传入到 appendChild()中的节点是文档中的一部分，那么该节点姜葱原来的位置转移到列表的末尾。添加节点后，childNodes新增的节点，父节点以及以前的最后一个子节点的关系指针都会发生相应的变化。 someNode.insertBefore(newNode,referenceNode)方法，用于将借调放在 childNodes列表中的特定位置，接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点，同时被方法返回。如果参照节点为 null，则 insertBefore()与 appendChild()执行相同的操作。 someNode.replaceChild(newNode, replacedNode)方法，用于替换节点。接收两个参数，要插入的节点和要替换的节点，返回被替换的节点 someNode.removeChild()方法，用于移除节点，接受一个参数，即要被移除的节点，返回该节点。 以上四个方法都是操作某个节点的子节点，需要取得父节点来使用。 其他操作方法以下两个方法是所有节点都有的方法： someNode.clone()方法，用于创建调用这个方法的节点的一个完全相同的副本。接收一个布尔值，确定是否深复制。参数为 true的情况下，执行深复制，也就是复制整个节点及其整个子节点树；参数为 false的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，没有为他指定父节点，需要通过 appendChild()等方法添加到文档中。 someNode.normalize()方法，用于处理文档树中的不规范的文本节点。 Document节点Document节点的特性： nodeType= 9; nodeName= ‘#document’; nodeValue= null; parentNode的值为 null; ownerDocument的值为 null； 其子节点可能是一个 DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或 Comment document属性: document.documentElement属性指向文档的 &lt;html&gt;元素 document.body属性指向文档的 &lt;body&gt;元素 document.title属性，修改 title的值会海标 &lt;title&gt;元素 document.URL属性包含页面完整的 url,只能访问 document.referrer属性保存着连接到当前页面的那个页面的 url，只能访问，可能为空 document.domain属性，只包含页面的域名，可以修改 查找元素： document.getElementById()方法，接收一个参数，要取得的元素的 id，返回该元素或者 null document.getElementsByName()方法，会返回带有给定 name属性的所有元素，一般用于单选按钮 document.getElementsByTagName()方法，接收一个参数，要取得的元素的标签名，返回一个 HTMLCollection对象，该对象与 NodeList类似。 HTMLCollction对象有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name特性取得特定的项 HTMLCollection对象还支持方括号语法访问，例如var myImage = document.getElementsByTagName('img')['myImage']用于访问 &lt;img&gt;标签中，name属性为’myImage’的哪一个 特殊集合： document.anchors,包含文档中所有带 name特性的 a元素 document.forms，包含文档中所有 &lt;form&gt;元素 document.images，包含文档中所有’&lt;img&gt;‘元素 document.links，包含文档中所有带 href特性的 ‘&lt;a&gt;‘元素 Dom一致性检测：使用 document.implementation.hasFeature(feature, version) 文档写入: document.write()方法，接受字符串，字符串会原样写入文档，可直接写入 html代码 document.writeIn()方法，同上，但在末尾会加入一个换行符\\n Element类型Element节点的特性: nodeType= 1; nodeName的值为元素的标签名； nodeValue= null; parentNode可能是 Document或者 Element; 元素特性： Element可以通过属性访问或者赋值下列标准特性: id title lang dir classNamedocument.getElementById('wte').id|className注意，通过属性方法定义的属性不会自动变成元素的特性 123var div = document.getElementById('div')div.mycolor = 'red'alert(div.getAttribute('mycolor')); //null 对于自定义的特性，一般使用 element.getAttribute()方法访问，接受特性名作为参数；使用 element.setAttribute()方法赋值，接受两个参数：特性名和要赋的值，如果特性已存在，则以值取代原有的值。 element.removeAttribute()用于完全移除特性 Element的 attribute属性： attribute属性中包含一个 NamedNodeMap，与 NodeList类似，是一个’动态’的集合，元素的每个特性都有一个 Attribute节点表示，节点的 nodeName就是特性的名称，nodeValue就是特性的值。可以用属性或者方括号访问节点的值，如var id = element.attribute['id'].nodeValue 创建元素:可以使用 document.createElement()方法创建元素，接收一个参数，即要创建的元素名，或者完整的 HTML标签。创建的元素需要手动添加到文档树。 Text类型Text节点特征： nodeType= 3 nodeName= ‘#text’ nodeValue的值为节点所包含的文本 parentNode是一个 ELement 不支持子节点 操作文本的方法：可以通过 nodeValue属性或者 data属性访问和修改 Text节点中包含的文本，在此处的 Html代码会被转码。 创建文本节点：document.createTextNode()方法，接受一个参数，要插入节点中的文本，文本中的 html代码将会被转码。创建以后需要被加载到文档中才能被看到。 一般来说，一个元素中只能有一个文本节点，如果两个文本节点是响铃的同胞节点，那么这两个节点中的文本就会连接起来显示，中间没有空格。 分割文本节点：splitText()方法，会将一个文本节点分成两个文本节点，即按照指定的位置分割 nodeValue值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点的 parentNode与源节点的相同。 DocumentFragment类型DocumentFragment节点的特征： nodeType= 11; nodeName= ‘#document-fragment‘ nodeValue= null; parentNode= null 子节点可以使 element,processingInstruction, comment, text, CDATASection, entityReference 文档片段本身永远不会成为文档树的一部分，当可以将它作为一个仓库使用，在里面可以保存将来可能会添加到文档中的节点。当文档片段中的节点被添加到文档树中时，该节点从文档片段中消失创建方法：document.createDocumentFragment() 元素遍历对于元素间的空格，Ie9和之前版本不会反悔文本节点，而其他浏览器都会返回文本节点。这样就导致了在使用 childNode和 firstChild等属性是的行为不一致，为了弥补这一差异，而同时又保持 Dom规范不变，新定义了一组属性： childElementCount firstELementChild lastElementChild previousELementSibling nextELementSibling HTML5classList属性HTML5新增了一种操作雷鸣的方式，就是 classList属性，这个属性石心机和类型 DOMTokenList的实例。DOMTokenList有一个 length属性，可以使用 item()方法或者方括号语法访问和操作一个 class，此外，还定义了一下方法： add(value)，将给定的字符串值添加到列表中 contains(value)，表示列表中是否存在给定的值 remove(value) toggle(value) 焦点管理document.activeElement属性，会始终引用 DOM中当前获得了焦点的元素document.focus()方法，确定文档是否获得了焦点 插入标记element.innerHTML属性,在读模式的情况下，返回与调用元素的所有子节点相对应的 HTML标记。在写模式的情况下，会根据传入的参数创建新的 DOM数，这个 DOM树将完全替换调用元素原先的子节点。 element.outerHTML属性，在读模式下，返回调用它的元素和所有子节点的 HTML标签。在写模式下，outterHTML会根据指定的 HTML字符串创建新的 DOM树，然后用这个 DOM树完全替换调用元素 insertAdjacentHTML()方法，接受两个参数，插入位置和要插入的 HTML文本，第一个参数必须是以下之一： beforebegin， 在当前元素之前插入一个紧邻的同辈元素 afterbegin， 在当前元素之下插入一个新的子元素或者在第一个子元素之前再插入新的子元素 beforeend在当前元素之下插入一个新的子元素或者在最后一个子元素之前再插入新的子元素 afterend在当前元素之后插入一个紧邻的同辈元素 其他element.children属性，这个属性是 HTMLCollection的实例，只包含元素中同样还是元素的子节点，有 length属性，可以通过方括号表示法访问 someNode.contains()方法，用于测试一个节点是否包含某个子节点，接受一个参数，即要检测的后代节点 innerText属性。读模式下，会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。在写模式下，结果会删除元素的所有子节点，插入包含相应文本的文本节点 outterText属性，读模式下，与 innerText完全一致；在写模式下，会替换整个元素（包括子节点） DOM2样式访问元素的样式任何支持 style特性的 HTML元素在 javascript中都有一个对应的 style属性，这个 style对象时 CSSStyleDeclaration的实例，包含着 通过 HTML的 style特性所制定的所有样式信息 ，但不包括与外部样式表或嵌入样式表经过层叠而来的样式。在 style特性中指定的任何 CSS属性都将表现为这个 style对象的响应属性。可以通过属性或者方括号语法来进行访问或修改，如：document.getElementById('myDiv').style.width == document.getElementById('myDiv').style['width'] DOM样式的属性和方法： cssText通过它能访问到 Style特性中的 css代码 length引用给元素的 CSS属性的数量 parentRule表示 CSS的信息的 CSSRule对象 getPropertyCSSValue(propertyName) 返回包含给定属性值的 CSSValue对象，包含两个属性，cssText和 cssValueType，其中，cssText属性的值与 getpropertyValue()返回的值相同，而 cssValueType属性则是一个数值常量，表示值的类型：0表示继承的值，1表示基本的值，2表示值列表，3表示自定义的值。 getPropertyPriority(propertyName) 如果给定的属性使用了!important设置，则返回’important‘， 反则返回空字符串 getPropertyValuee(propertyName) 返回给定属性的字符串值 item(index) 返回给定位置的 CSS属性的名称 removeProperty(propertyName) 从样式中删除给定属性 setProperty(propertyName, value, priority) 将给定属性设置为相应的值，并加上优先权标志（important或者一个空字符串） 计算样式，指实际应用于浏览器中表现出来的样式，可以使用 document.defaultView.getComputedStyle()方法，取得计算样式。该方法接受两个参数，要取得计算样式的元素和一个为元素字符串（可以为空）。用法：document.defaultView.getComputedStyle(document.getElementById('mydiv'), null) 注意，计算样式不可修改，只能访问 操作样式表CSSstyleSheet类型表示的是样式表，包括通过 &lt;link&gt;元素包含的样式表和在 &lt;style&gt;元素中定义的样式表，该对象只是一套只读的接口（一个属性例外），不可修改。 应用于文档中的样式表通过 document.styleSheets集合来访问，有 length属性，可以通过方括号或者 item()方法来访问没一个样式表: 12345var sheet = null;for (var i = 0; i &lt; document.styleSheets.length; i++) { sheet = document.styleSheets[i]; alert(sheet.href)} CSSStyleSheets继承自 StyleSheet，后者可以作为一个基础借口来定义非 CSS样式表，从中继承而来的属性有： disable表示是否禁用样式表，可读写，true为禁用 href通过 &lt;link&gt;元素包含的，则是样式表的 URL，否则为 Null media当前样式表支持的所有媒体类型的集合 ownerNode指向拥有当前样式表的节点的指针,样式表可能是通过 HTML中的 &lt;link&gt;&lt;style&gt;元素引入的。如果是通过@import引入，则该属性值为 null parentStyleSheet在当前样式是通过@import导入的情况下，该属性是一个指向引入他的样式表的指针 title ownerNode中的 title属性值 type表示样式表类型的字符串。对 CSS样式表而言，这个字符串时’type/css‘ cssRules 样式表中包含的样式规则的集合，IE中为 rules属性 ownerRule如果样式表示通过@import导入的，这个属性就是一个指针，指向表示导入的规则，否则，为 null。ie不支持 deleteRule(index) 删除 cssRules集合中指定位置的规则。IE使用 removeRule() insertRule(rule, index) 向 cssRules集合中指定的位置插入 rule字符串。IE使用 addRule() CSS规则：CSSRule规则表示样式表中的每一条规则。实际上，CSSRule是一个供其他多种类型继承的基类型，其中最常见的就是 CSSStyleRule类型，表示样式信息。CSSStyleRule对象包含以下属性，常用的有 cssText selectorText ``style三个属性： cssText 返回整条规则对应的文本，只读属性。IE不支持 parentRule如果当前规则是导入的规则，这个属性引用的就是导入规则，否则为 Null，IE不支持 parentStyleSheet当前规则所属的样式表，IE不支持 selectorText 返回当前规则的选选择符文本，IE不支持 style 一个 CSSStyleDeclaration对象，可通过他设置和取得规则中特定的样式值，用法： 1234var sheet = document.styleSheets[0]var rules = sheet.cssRulesvar rule = rules[0]rule.style.backgroundColor = 'red' type表示规则类型的常量值，对于样式规则，这个值为1，IE不支持","link":"/posts/5b12dbf7/"},{"title":"Js 基本数据类型","text":"JS基本数据类型ECMAScript的基本数据类型有：undefined, Null, Boolean, Number, String, Object。typeof null //object原因：null被认为是一个空的Object undefined类型12var message;typeof message //undefined 原因： 未初始化的变量等价于 undefined,未显式赋值的变量的值默认为 undefined，但 alert(message)会抛出错误，因未初始化的变量只能进行 typeof和 delete操作 Null类型 从逻辑角度看，null值表示一个空对象指针,null值可以用来确定相应的变量是否已经保存了一个对象的引用 12var car = null;if (car !== null) {} //确定是否Car值是否为空 注意，undefined值是派生自 null值，因此，alert(null == undefined)； // ture对于两者的相等操作符总是返回 true; Boolean类型 boolean类型的值为 true和 false，但与数字值不是一回事，true不一定等于1，false也不一定等于0; ECMAScript所有类型的值都有 boolean值，可以用转型函数 Boolean()将不同类型的值转换为 Boolean值，转换规则如下: 数据类型 转换为 true的值 转换为 false的值 Boolean true false String 任何非空字符串 ‘’（空字符串） Number 任何非零数字（包括无穷大） 0和 NaN Object 任何对象 null undefined n/a undefined Number类型默认十进制，但也可以通过八进制（在严格模式下无效）或十六进制的字面值来表示: 八进制字面值的第一位必须是0，然后是八进制数字序列（0~7），如果数值超出了八进制范围，前导的0将被忽略，后面的数值被当做十进制解析; 十六进制的字面值的前两位必须是0x，后跟任何十六进制数字; 进行算数计算时，所有以八进制和十六进制表示的数值都将被转换成十进制数值。 数值范围：在大部分浏览器中，js的数值范围在5 e-324~1.797693e+308之间，超过这个数，会被转换为 Infinity值（-Infinity or Infinity），要想确定一个数是否有穷，可以使用 isInfinity()函数 NaN用来表示一个本来要返回数值的操作数未返回数值的情况。任何涉及 NaN的操作都会返回 NaN;NaN与任何值都不相等，包括 NaN本身。可以使用 isNaN()来确定该参数‘不是数值’，该函数会先将参数转换成数值再返回 true or ``false; 数值转换：Number()（可以用于任何数据类型）, parseInt(), parseFloat()（这两个专门用于将字符串转换成数值） Number()转换规则： 如果是 Boolean值，true和 false将分别被转换为1和0 如果是是数字值，只是简单的传入和返回 如果是 null值，返回0 如果是 undefined，返回 NaN 如果是字符串，遵循下列规则： 如果字符串中只包含数字，则将其转换为十进制数值，级“1”会变成1，“123”会变成123，而“011”会变成11（前面的0被忽略了） 如果字符串中只包含有效的浮点格式，如“1.1”，则将其转换为对应浮点数值（同样，也会忽略前导零） 如果字符串中只包含有效的十六进制格式，例如“0 xf”，则将其转换为相同大小的十进制整数值 如果字符串是空的（不包含任何字符），则将其转换为0 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()把各种数据类型转换为数值 对于 parseInt()和 parseFloat()，需要注意： 注意： 只有字符串中的第一个数字会被返回。 注意： 开头和结尾的空格是允许的。 注意：如果字符串的第一个字符不能被转换为数字，那么 parseInt() 会返回 NaN。 parseInt()可以传递第二个参数，代表转换时使用的基数（即多少进制），转换规则： 如果 string以 “0 x“ 开头，parseInt() 会把 string的其余部分解析为十六进制的整数。 如果 string以 0 开头，那么 ECMAScript v3允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。 如果 string以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。 parseFloat()只能传递一个参数，转换规则： 该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。 浮点数值的最高进度是17位小数，永远不要测试某个特定的浮点数值 String类型字符字面量（转义序列）可以出现在字符串中的任何位置，也被作为一个字符来解析 字符串的值 不能改变，要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量 转换字符串：toString()方法，（null和 undefined没有这个方法，需要使用 String()方法）在调用数值的 toString()方法时，可以传递一个参数：输出数值的基数String()方法 Object类型Object类型所具有的任何属性和方法也同样存在于更具体的对象中Object的每个实例都具有下列属性和方法： constructor:保存着用于创建当前对象的函数 hasOwnProperty(propertyName):用于检查给定的函数在当前对象实例中是否存在，其中作为参数的属性名必须以字符串形式指定 isPrototypeOf(object): 用于检查传入的对象是否是当前对象的原型 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in语句来枚举 toLocalString():返回对象的字符串表示，该字符串与执行环境的地区对应； toString():返回对象的字符串表示 valueOf():返回对象的字符串、数值或布尔值表示","link":"/posts/43ab4c6/"},{"title":"Js 引用类型类型引用类型类型(下)","text":"Js引用类型类型(下)引用类型(Date、RegExp、Function)Date类型Date的构造函数123456789101112131415//1.构造函数没有参数，则返回当前日期的Date对象var now=new Date();//2.构造函数的参数为日期的毫秒数，返回距离1970年1月1日经过该毫秒后对应的日期var date=new Date(1222233);//3.构造函数的参数为对应的日期字符串，返回对应的日期对象，其中年，月，日是必须的，时分秒可选//实际上，上面这种直接将表示日期的字符串传递给Date构造函数，会在后台调用Date.parsevar date1=new Date('2016-01-01');//4.构造函数的参数分别为年份，基于0的月份（0-11），月中的哪一天（1-31），小时数（0-23），分钟，秒以及毫秒。//在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1，如果省略其他参数，则统统假设为0//实际上，上面这种情况的构造函数，在后台调用了Date.UTCvar date2=new Date(2016,4,5,17,55,55); 返回日期对应的毫秒数 Date.parse():接收一个日期字符串，返回该日期对应的毫秒数。 Date.UTC():的参数参数分别为年份，基于0的月份（0-11），月中的哪一天（1-31），小时数（0-23），分钟，秒以及毫秒。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1，如果省略其他参数，则统统假设为0。返回该日期对应的毫秒数。 如果已有日期对象 date，获取它对应的毫秒数，大多采用 date.getTime()或者+date 获取当前时间对应的毫秒数这常常用在监测一段代码运行了多长时间。 方法一：var start=Date.now(); 方法二：var end=+new Date(); 方法三：var end=new Date().getTime() 常见的 Date方法123456789101112131415161718192021222324252627var date=new Date('2016-01-10');var time=date.getTime()//返回该date对象对应的毫秒数，与valueOf返回的结果相同date.setTime(1);//以毫秒数设置日期，这常常会改变整个日期对象var year=date.getFullYear();//取得四位数的年份，如2016而非16date.setFullYear(2012);//设置年份，传入的参数必须是四位数字var month=date.getMonth();//返回该date对象的月份（0-11）date.setMonth(0);//设置月份，参数必须为0-11的数字var day=date.getDate();//返回该date对象月份中的天数（1-31）date.setDate(11);//设置月份中的天数，参数必须为1-31之间的数字var week=date.getDay();//返回该date对象星期中的天数（0-6）var hours=date.getHours();//返回该date对象一天中的小时数（0-23），对应的有setHoursvar minutes=date.getMinutes();//返回日期中的分钟数（0到59），对应的有setMinutesvar seconds=date.getSeconds();//返回日期中的秒数（0-59），对应的有setSeconds Date继承的方法toString()与 toLocalString()的区别： 在浏览器中返回的日期和时间各式不同，但在显示日期和时间时没多少价值，一般用于调试代码中 valueOf() 不返回字符串，而是返回日期的毫秒表示，可以用比较操作符来比较日期值 日期格式化的方法toDateString() —— 以特定于实现的格式显示星期几、月、日和年；toTimeString() —— 以特定于实现 的格式显示时分秒和时区；toLocaleDateString() —— 以特定于地区的格式显示星期几、月、日和年；toLocaleTimeString() —— 以特定于实现的格式显示时分秒；toUTCString() —— 以特定于实现的格式完整的 UTC日期； RegExp类型ECMAScript通过 RegExp类型来支持正则表达式正则表达式创建方法： var expression = / pattern / flags;``var pattern1 = /[bc]at/i‘pattern’ 部分可以使任何简单或复杂的正则表达式；‘flags’（标志）是用以表明正则表达式的行为，支持三个标志：g:表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止 ；i:表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 var pattern = new RegExp['[bc]at', 'i']这使用构建函数创建的，等值于上例。 Functiion类型创建方式： 函数表达式 var name = function() {} 函数声明 function functionName() {}区别：函数声明会被率先解析，并使其在执行任何代码之前可以访问。函数表达式则需要解析器执行到它所在的代码行，才会被解释执行 函数名字只是一个包含指针的变量而已。 this含义，arguments.callee作用,arguments.caller属性arguments：是一个类数组的对象，包含着传入函数中的所有参数，它的主要用途是保存函数参数。这个对象有一个叫 caller的属性，该属性是一个指针，指向拥有这个 arguments对象的函数。（严格模式下使用 arguments.callee会报错），示例： 1234567functino factorial (num) { if (num &lt;= 1) { return 1; } else { return num * factorial(num - 1) } } 上例等价于此： 1234567functino factorial (num) { if (num &lt;= 1) { return 1; } else { return num * arguments.callee(num -1) } } this:是函数内部的一个特殊对象，引用的是函数执行的环境对象（也可以说是 this值（当在网页的全局作用域中调用函数时，this对象引用的就是 window））。 arguments.caller： 该属性保存着调用当前函数的函数的引用，如果实在全局作用域中调用当前函数，它的值为 Null,示例： 1234567function outer() { return (); } functino inner() { alert(inner.caller) } outer 上例等价于此： 1234567function outer() { return (); } functino inner() { alert(arguments.callee.caller) } outer 严格模式下使用`arguments.caller`会报错,非严格模式下，该属性始终是 `undefined`。定义 `arguments.callee`属性是为了分清楚 `arguments.caller`和函数的 `caller`属性。不能为函数的 `Caller`属性赋值ES6const声明使用 const声明可以防止被赋值为字符串的变量改变。但数组和对象的单个元素可以被改变。为了防止对象呗改变，可以使用 Object.freeze(对象名)方法，使用该方法，任何改变都会被无视，但不弹出错误 箭头函数箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的 this值，箭头函数会捕获其所在上下文的 this值，作为自己的 this值（即不会新产生自己作用域下的 this，arguments,super和 new.target等对象），一般都是匿名函数，当做参数传递，语法如下： 1234const myFunc = function() { const myVar = \"value\"; return myVar;} 等价于 1234const myFunc = () =&gt; { const myVar = \"value\"; return myVar;} 当函数只返回一个值时，匿名函数的return关键词和’{}‘括号都可以省略，等价于const myFunc = () =&gt; &quot;value&quot; 箭头函数不会在内部暴露 arguments对象 :arguments.length, arguments[0], arguments[1] 等等，都不会指向箭头函数的 arguments，而是指向了箭头函数所在作用域的一个名为 arguments的值(如果有的话，否则，就是 undefined)。箭头函数不能用作构造器，和 new一起用就会抛出错误。箭头函数不能用作 Generator函数 class语法 class不是新的对象继承模型，它只是原型链的语法糖表现形式。class用来取代 new+ 构造函数创建一个新的对象，但是使用 class时，需要加上一个 constructor方法。如下： 123456class SpaceShuttle { constructor(targetPlanet){ this.targetPlanet = targetPlanet; } } const zeus = new SpaceShuttle('Jupiter'); class的继承和超集，看代码： 12345678910111213141516class Car { constructor() { console.log(\"Creating a new car\"); }}class Porsche extends Car { constructor() { super(); console.log(\"Creating Porsche\"); }}let c = new Porsche();// Creating a new car// Creating Porsche extends允许一个子类继承父类，需要注意的是，子类的 constructor函数中需要执行 super() 函数。当然，你也可以在子类方法中调用父类的方法，如 super.parentMethodName()。有几点值得注意的是：类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError的错误在类中定义函数不需要使用 function关键词 对象的 get()和 set()看代码 1234567891011121314151617class Book { constructor(author) { this._author = author; } // getter get writer(){ return this._author; } // setter set writer(updatedAuthor){ this._author = updatedAuthor; }}const lol = new Book('anonymous');console.log(lol.writer); // anonymouslol.writer = 'wut';console.log(lol.writer); // wut #杂记判断数字是否整数的方法：number% 1 == 0 为整数","link":"/posts/a306f6df/"},{"title":"Js 引用类型类型(上)","text":"Js引用类型类型(上)引用类型(Object、Array)引用类型的值（对象）是引用类型的一个实例引用类型是一种数据结构，用于将数据和功能组织在一起。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。（对象是某个特定引用类型的实例） Object类型创建方式: new + 构造函数：var obj = new Object(); 对象字面量法： 123var obj = { propertyName: value,} object类型中的属性名是数字开头的，必须使用[]表示法访问，使用[]访问时，字符串属性名必须带引号，数字的不能引号访问对象属性可以使用点（.）访问法和方括号表示法（[propertyName]）,一般使用点表示法 Array类型创建方式： new + 构造函数（new可以省略）：var arr = new Array();构造函数可以接受参数，传递的参数为数字值时，创建一个length属性为该数字的数组，参数为字符串时，则创建一个包含该字符串的数组（字符串可以有多个，多少额字符串即多少个元素） 对象字面量法：var arr = [1, 2, 3] Array.length属性不是只读的，可以通过设置该属性，从数组的末尾移除项或向数组中添加新项，如下所示： 123456var arr = [1,2,3]; alert(arr.length); // 3 arr.length = 2 //移除最后一项 alert(arr[2]) // undefined arr[arr.length] = 4 //向arr的末尾添加一个元素 alert(arr) //[1, 2, 3, 4] ( 检测某个对象是否是数组，使用 Array.isArray(value)方法 toString()方法与 toLocalString()方法区别：toLocalString()是调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。 toString()方法获取的是 String(传统字符串),而 toLocaleString()方法获取的是 LocaleString(本地环境字符串)。 如果你开发的脚本在世界范围都有人使用，那么将对象转换成字符串时请使用 toString()方法来完成。 LocaleString()会根据你机器的本地环境来返回字符串，它和 toString()返回的值在不同的本地环境下使用的符号会有微妙的变化。 所以使用 toString()是保险的，返回唯一值的方法,它不会因为本地环境的改变而发生变化。如果是为了返回时间类型的数据，推荐使用 LocaleString()。若是在后台处理字符串，请务必使用 toString()。 栈（lifo数据结构）方法push\\pop方法 队列(fifo数据结构)方法shift\\push方法 重排序方法reverse() 用于翻转排序 sort() 默认情况下，将按照升序排列数组，可以接受一个比较函数作为参数进行排序，该函数可以自定义 操作方法concat()方法会先创建一个当前数组的副本，然后将接收到的参数添加到副本的末尾，并返回新构建的数组。可以接受元素以及数组，如果接受的是数组，则将数组中的每一项（不是数组）添加到副本。 slice()方法 可以接受一或者两个参数，即要返回的起始和结束位置。 splice(index,howmany,item1,…..,itemX)方法，可以进行删除、插入和替换。index(必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。),howmany(必需。要删除的项目数量。如果设置为 0，则不会删除项目。),item1, …, itemX(可选。向数组添加的新项目。) 位置方法indexOf() 从数组的开头开始往后查找该元素所在的索引值lastIndexOf() 从数组的末尾往前查找这两个方法都接受一个或两个参数：要查找的值，和开始查找的位置（可选的） 迭代方法every():对数组中的每一项执行函数，如果每一项都返回 true,则该方法返回 true。 some():对数组中的每一项执行函数，只要有一项返回了 true,则该方法返回 true。 filter():对数组中的每一项执行函数，把里面返回 true的项，组成一个数组返回。 forEach()对数组中的每一项执行函数，没有返回值。类似于 for循环。 map() 对数组中的每一项执行函数，返回（处理后的）每一项。以上5种方法，都不会改变数组本身。 归并方法reduce() 从头开始迭代数组的所有项，然后构建一个最终返回的值reduceRight()从末尾开始迭代数组的所有项，然后构建一个最终返回的值","link":"/posts/fdfe1e96/"},{"title":"Js基本包装类型与拓展运算符学习","text":"JS高级程序设计基本包装类型为了便于操作基本类型值（即 number, boolean，number等基本类型值），ECMAScript还提供了3个特殊的引用类型：Boolean， String，Number。这些类型与其他的引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值得时候，后台会创建一个对应的基本类型的对象，从而让我们能调用一些方法来操作这些数据。 包装类型，是一个专门封装原始类型的值，并提供对原始类型的值执行操作的 API对象引用类型与基本包装类型的主要区别是对象的生存期，使用 new操作符创建的引用类型的实例，在执行流离开当前作用域之前一直保存在内存中。而自动插 UN关键的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型值添加属性和方法 Boolean类型创建方法：var booleanObject = new Boolean(true)（不建议使用该对象） Number类型创建方法：var numberObject = new Number(10) （不建议使用该对象）该类型重写了 valueOf(), toLocaleString(), toString()方法重写后的 valueOf()方法返回对象标识的基本类型的数值，另外两个方法则返回字符串形式的数值。 Number类型除继承的方法，还提供了一些其他方法：numberObject.toFixed()方法：传入一个数字参数，返回保留多少位小数的数值（字符串形式），多的小数会自动舎入 numberObject.toExponential()方法： 接受一个参数，指定输出结果中的小数位数。返回以指数表示法表示的熟知的字符串形式 numberObject.toPrecision()方法返回 fixed格式或 exponential格式的字符串形式的数值。接受一个参数，表示数字的所有位数 String类型创建方法：var stringObject = new String('') 1 .String类型的字符方法.charAt():接收一个参数，即字符位置的索引值，以单字符字符串的返回该索引值所在的字符.charCodeAt()： 接收一个参数，即字符位置的索引值，回该索引值所在的字符编码还可以使用[]方法访问索引值字符 2。字符串操作方法concat(): 用于将一个或多个字符串拼接起来，返回拼接得到的新字符串。（可以接收多个参数，拼接任意多个字符串）slice(), substr(), substring():这三个方法都是基于子字符串创建新字符串的方法，都会返回备操作字符串的一个子字符串，都接受一或两个参数。第一个参数指定字符串的开始位置，第二个参数（在指定情况下）表示字符串到哪里结束。具体来说，slice()和 substring()的第二个参数制定的是子字符串最后一个字符后面的位置。二 substr()的第二个参数指定的是返回的字符的个数。这些方法都不会对原始字符串造成影响 3. 字符串位置方法indexOf():可接受一个或两个参数给定字符串，第一个参数为需哟查找的字符串，第二个为可选参数，为开始查找的索引值。返回索引值，从头开始查找，lastIndexOf()：可接受一个或两个参数给定字符串，第一个参数为需哟查找的字符串，第二个为可选参数，为开始查找的索引值。给定字符串，返回索引值，从尾开始查找 4 .trim()方法创建一个字符串的副本，删除前置机后缀的所有空格，然后返回结果，还有延伸出来的 trimLeft()和 trimRight()方法，删除开头或结尾的空格。不改变原始字符串。 5.字符串大小写转换方法toLowerCase()toUpperCase()toLocaleLowerCase():针对特定地区的大小写转换方法toLocaleUpperCase() 6.字符换的模式匹配方法match(): 接受一个参数，要么是正则表达式，要么是 RegExp对象。，返回匹配的数组 search():与 match()类似，但是返回的是匹配的索引值，若果没有匹配到，则返回-1 replace():这个方法用于在字符串中用一些字符替换特定的字符，或替换一个与正则表达式匹配的字符，这个方法可以接受两个参数，第一个参数是字符串或者是正则表达式，第二个参数可以是一个字符串或者一个函数，如果第一个参数是字符串，那么只会替换第一个子字符串，如果第一个参数是正则表达式，则可以替换全部子字符串，前提是指定全局(g)标志。 splite():可以给予指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以使字符串，也可以是一个 RegExp对象（该方法不会将字符串看成正则表达式）。可以接受可选的第二个参数，用于指定数组的大小，以确保返回的数组不会超过既定大小。 7 .localeCompare()方法比较两个字符串，并返回下列之中的一个： 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的只要是实现而定） 如果字符串等于字符串参数，返回0 如果字符串在字母表中应该排在字符串参数之后，则返回一个整数（大多数情况下是1） 8 .fromCharCode()方法接收一或多个字符编码，然后将他们转换成一个字符串。 单体内置对象指由 ECMAScropt事先提供的，不依赖于宿主环境的对象，这种对象在 ECMAScript程序执行之前就已经存在了。开发人云不必显式的实例化内置对象，因为它们已经实例化了。之前已经介绍过 Object，String，Array等，下面是其他的单体内置对象：Global对象Math对象 拓展运算符（…）在数组中可以当做 slice使用，用于完全复制一个数组123var thisArr = [1,2,3,4,5]var thatArr = [...thisArr]console.log(thatArr) //[1,2,3,4,5] 还可以用于组合数组 123var thisArr = [1,2,3,4,5]var thatArr = [6, 7, 8, 9, ...thisArr, 10]console.log(thatArr) //[6, 7, 8, 9, 1, 2, 3, 4, 5, 10] splice()第三个参数可以接受数组，单数是将数组作为一个元素，加入需要将数组中的每个元素编程 this的元素，需要将数组中的每个元素进行 splice()插入进去","link":"/posts/116542a5/"},{"title":"Post 和 Get区别","text":"2018.10.13学习日志GET和 POST区别 post更安全（不会作为 url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中） post发送的数据更大（get有 url长度限制） post能发送更多的数据类型（get只能发送 ASCII字符） post比 get慢 post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是 get提交），目的是资源的获取，读取数据 post比 get慢原因 post请求包含更多的请求头因为 post需要在请求的 body部分包含数据，所以会多了几个数据描述部分的首部字段（如：content-type）等。 post在真正接收数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据 Post和 Get请求过程 post请求的过程：1. 浏览器请求`tcp`连接（第一次握手） 2. 服务器答应进行 `tcp`连接（第二次握手） 3. 浏览器确认，并发送 `post`请求头（第三次握手，这个报文比较小，所以 `http`会在此时进行第一次数据发送） 4. 服务器返回100 `Continue`响应 5. 浏览器发送数据 6. 服务器返回200 `OK`响应.get请求的过程： 浏览器请求 tcp连接（第一次握手） 服务器答应进行 tcp连接（第二次握手） 浏览器确认，并发送 get请求头和数据（第三次握手，这个报文比较小，所以 http会在此时进行第一次数据发送） 服务器返回200 OK响应 作者：确认过眼神cxy来源：CSDN原文：https://blog.csdn.net/zzk220106/article/details/78595108?utm_source=copy","link":"/posts/97b4845e/"},{"title":"React基础","text":"react 基础react的核心是组件(component),React内的任何东西都是组件。 React元素元素是构成 React应用的最小单位，它用于描述屏幕上输出的内容。React元素都是不可变的。当元素被创建之后，你是无法改变其内容或属性的。目前更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render() 方法，例如; 12345678910111213141516171819class Clock extends React.Component { render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 {this.props.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); }}function tick() { ReactDOM.render( &lt;Clock date={new Date()} /&gt;, document.getElementById('example') );}setInterval(tick, 1000); 以上实例通过 setInterval() 方法，每秒钟调用一次 ReactDOM.render()。 Jsxjsx属于 js的扩展语言，允许在 jsx代码内使用 html代码，但 jsx的 html与传统的 html有区别，同时，使用 jsx需要用 babel转码器将 jsx转为 js才可被编译，在 jsx中使用 js代码，需要将 js写在 {}内。 html与 js的区别： JSX中的 html没有 class属性，换成了 className属性 ，for属性需要写成 htmlFor，此外，其他的 html属性和event都被换成了驼峰式命名，如:onclick =&gt; onClick, onchange =&gt; onChange等。 自闭标签，如 &lt;div&gt;&lt;/div&gt;可以写成 &lt;div /&gt;，但这种写法的 div内部无法嵌套其他内容 React的 JSX使用大、小写的约定来区分本地组件的类和 HTML标签。 JSX不能使用 if/else语句，但能使用三元表达式 JSX允许在模板中插入数组，数组会自动展开所有成员 jsx写的 html代码，必须只返回一个元素（可以由父元素嵌套这多个子元素，但不允许多个同胞元素，多个通报元素将不被编译），当返回的是父元素嵌套这子元素时，可以选择使用括号 ()将父元素括起来，示例： 1234567891011//validconst JSX = (&lt;div&gt; &lt;p&gt;Paragraph One&lt;/p&gt; &lt;p&gt;Paragraph Two&lt;/p&gt; &lt;p&gt;Paragraph Three&lt;/p&gt; &lt;/div&gt;)//invalidconst JSX = &lt;p&gt;Paragraph One&lt;/p&gt; &lt;p&gt;Paragraph Two&lt;/p&gt; &lt;p&gt;Paragraph Three&lt;/p&gt; JSX的注释使用 {/* */ }，即相当于使用{}，在里面使用js的注释方法：/* */ 创建组件的两种方法： 使用 js的 function方法，创建一个无状态的功能性组件，无状态组件也是拓展自 React.Component，但是并不适用内在的 state，没有生命周期的说法，也不支持’ref‘。注意，该方法创建的组件，名字开头的字母必须为大写，且必须返回 JSX or null。示例： 1234567// 被编译以后，&lt;div&gt;标签有一个属性'customClass'const DemoComponent = function() {{/* 因为jsx组件代表着html，所以可以将多个组件嵌套，组成一个复杂的组件，允许你将一系列分隔的孤立的组件组合成你的ui，意味着可以更简单的建立复杂的ui */} return ( &lt;div className='customClass' /&gt; );}; 使用 class语法创建组件，class组件，有内在的 state，支持’ref‘，一般来说，尽量少使用 class组件，尽可能使用无状态组件，有利于在应用内管理使用state的特殊区域。示例： 1234567891011class Kitten extends React.Component { constructor(props) { super(props); } render() { return ( &lt;h1&gt;Hi&lt;/h1&gt; ); }} 组合组件的方法： 使用一个父组件来包含子组件，当 React遇到 &lt; /&gt;时，会自动渲染该组件，代码： 123456789101112131415161718192021222324252627282930const ChildComponent1 = () =&gt; { return ( &lt;div&gt; &lt;p&gt;I am the child1&lt;/p&gt; &lt;/div&gt; );};const ChildComponent2 = () =&gt; { return ( &lt;div&gt; &lt;p&gt;I am the child2&lt;/p&gt; &lt;/div&gt; )}class ParentComponent extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; &lt;h1&gt;I am the parent&lt;/h1&gt; {/* 在此 以自闭标签 写入子组件 */} &lt;ChildComponent1 /&gt; &lt;ChildComponent2 /&gt; &lt;/div&gt; ); }}; 使用嵌套元素，进行组件组合，代码： 123456789101112131415161718192021222324252627282930313233343536373839// 将一个嵌套元素构成组件const TypesOfFruit = () =&gt; { return ( &lt;div&gt; &lt;h2&gt;Fruits:&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Blueberries&lt;/li&gt; &lt;li&gt;Strawberries&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );};// 组合组件，构成父组件Fruit（嵌套子组件TypeOfFruit）const Fruits = () =&gt; { return ( &lt;div&gt; &lt;TypesOfFruit /&gt; &lt;/div&gt; );};//在此组合组件，形成父组件TypesOfFood嵌套子组件Fruits（Fruit再嵌套子组件TypeOfFruit）的形式class TypesOfFood extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; &lt;h1&gt;Types of Food:&lt;/h1&gt; &lt;Fruits /&gt; &lt;/div&gt; ); }}; 复合组件：我们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。 1234567891011121314151617181920212223function Name(props) { return &lt;h1&gt;网站名称：{props.name}&lt;/h1&gt;;}function Url(props) { return &lt;h1&gt;网站地址：{props.url}&lt;/h1&gt;;}function Nickname(props) { return &lt;h1&gt;网站小名：{props.nickname}&lt;/h1&gt;;}function App() { return ( &lt;div&gt; &lt;Name name=\"菜鸟教程\" /&gt; &lt;Url url=\"http://www.runoob.com\" /&gt; &lt;Nickname nickname=\"Runoob\" /&gt; &lt;/div&gt; );}ReactDOM.render( &lt;App /&gt;, document.getElementById('example')); 实例中 App组件使用了 Name、Url和 Nickname组件来输出对应的信息。 渲染元素：使用 ReactDOM.render(componentToRender, targetNode)：第一个参数是准备渲染的元素或 react对象，第二个参数是要放置的被渲染对象的 Dom节点。 对于第一个参数，如果是定义的 jsx元素，可以直接使用 jsx变量，如果是组件(class组件或 function组件)，则需要使用 &lt;component /&gt;的形式传递，如 ReactDOM.render(&lt;componentToRender /&gt;, targetNode) 阻止组件渲染:在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render方法返回 null而不是它的渲染结果即可实现。组件的 render方法返回 null并不会影响该组件生命周期方法的回调。 属性参数(props|properties): 可以传递参数给子组件(可以传递单个参数，也可以传递一个数组 array),对于function组件：代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//传递单个参数const CurrentDate = (props) =&gt; { return ( &lt;div&gt;/* 确定将被父组件使用的属性名date*/ &lt;p&gt;The current date is: {props.date}&lt;/p&gt; &lt;/div&gt; );};class Calendar extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; &lt;h3&gt;What date is it?&lt;/h3&gt; {/* 为子组件属性赋值 */} &lt;CurrentDate date={Date()} /&gt; &lt;/div&gt; ); }};//传递一个array，这里定义一个组件Listconst List= (props) =&gt; { /* 确定将被父组件使用的属性名tasks,并定义了对该属性值的操作join(', ')*/ return &lt;p&gt;{props.tasks.join(', ')}&lt;/p&gt;};class ToDo extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; &lt;h1&gt;To Do Lists&lt;/h1&gt; &lt;h2&gt;Today&lt;/h2&gt; /* 为子组件的tasks属性赋值，因为是js代码，需要用{}括起来 */ &lt;List tasks={['a', 'b', 'c']} /&gt; &lt;h2&gt;Tomorrow&lt;/h2&gt; &lt;List tasks={['a', 'b','b' ,'c']} /&gt; &lt;/div&gt; ); }}; 对于class组件，使用 this.props对象访问属性 1234567891011121314151617181920212223242526272829303132class ReturnTempPassword extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; {/* 在此处设置将在父组件被使用的属性temPassWord*/} &lt;p&gt;Your temporary password is: &lt;strong&gt;{this.props.tempPassword}&lt;/strong&gt;&lt;/p&gt; &lt;/div&gt; ); }};class ResetPassword extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; &lt;h2&gt;Reset Password&lt;/h2&gt; &lt;h3&gt;We've generated a new temporary password for you.&lt;/h3&gt; &lt;h3&gt;Please reset this password from your account settings ASAP.&lt;/h3&gt; {/* 为属性temPassword赋值*/} &lt;ReturnTempPassword tempPassword={'abcdefghij'} /&gt; &lt;/div&gt; ); }}; 可以给组件指定一个默认参数，但当给参数赋值为 null时，任然显示为 null。： 123456789101112131415161718const Items = (props) =&gt; { return &lt;h1&gt;Current Quantity of Items in Cart: {props.quantity}&lt;/h1&gt;}//为Items组件的quantity赋默认值0Items.defaultProps = { quantity: 0}class ShoppingCart extends React.Component { constructor(props) { super(props); } render() { {/* 重写quantity的值*/} return &lt;Items quantity={10}/&gt; }}; 可以指定组件的参数类型（在react 15.5.0 版本中，使用 PropType方法需要导入，如import React, { PropTypes } from 'react'; 或&lt;script src=&quot;https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js&quot;&gt;&lt;/script&gt;，代码如下：MyComponent.propTypes = { handleClick: PropTypes.func.isRequired }其中的 PropTypes.func用来检查参数 handleClick是否是 function类型，isRequired是告诉React，这个参数是组件所必须的。在 js的7中基本类型中，只用 fuc和 bool是特殊的写法，其他的都是正常的(如 number|string等 ) state（状态）state和 props主要的区别在于 props是不可变的，而 state可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state来更新和修改数据。 而子组件只能通过 props来传递数据。 创建 state:在组件的 constructor函数中初始化 state（是 js的 object对象），state存在于组件的整个生命周期，可以更新、渲染、甚至传递给子组件。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839//访问state的方法1：class StatefulComponent extends React.Component { constructor(props) { super(props); /*声明并初始化state*/ this.state = { name: 'asd' } } render() { return ( &lt;div&gt; /*访问state.name*/ &lt;h1&gt;{this.state.name}&lt;/h1&gt; &lt;/div&gt; ); }};//访问state的方法2：//I在render()方法里面，return语句之前，可以直接写js代码class MyComponent extends React.Component { constructor(props) { super(props); this.state = { name: 'freeCodeCamp' } } render() { /* 声明一个变量name，在render()的return语句之前，可以不用{}写js代码,所以可以在此写需要在return中被引用的变量，在return中使用{}引用 */ const name = this.state.name return ( &lt;div&gt; /* 调用render()中，return之前声明的变量*/ &lt;h1&gt; {name}&lt;/h1&gt; &lt;/div&gt; ); }}; 当 state改变时，ui也会改变，react使用虚拟的 dom来跟踪 state的状态，react只会在必要的时候改变真正的 dom，所以，不必担心正在的 dom的变化。注意：state相当于是一个私有对象，只能在原有组件中访问，或者被传递到子组件。 改变 state的方法: 在组件内使用 this.setState()方法，传递键值对。React不建议直接修改 state，且 React对 setState的处理是异步的，具体用法如下: 12345678910111213141516171819202122class MyComponent extends React.Component { constructor(props) { super(props); this.state = { name: 'Initial State' }; //给handleClick方法绑定this this.handleClick = this.handleClick.bind(this); } handleClick() { //this.setState用法。this.setState()会覆盖之前的数据 this.setState({name: 'React Rocks!'}) } render() { return ( &lt;div&gt; &lt;button onClick={this.handleClick}&gt;Click Me&lt;/button&gt; &lt;h1&gt;{this.state.name}&lt;/h1&gt; &lt;/div&gt; ); }}; 在 class组件 constructor函数中定义的的 class方法中绑定’this‘来改变 state或 props 12345678910111213141516171819202122232425class MyComponent extends React.Component { constructor(props) { super(props); this.state = { itemCount: 0 }; //为方法绑定this，声明this this.addItem = this.addItem.bind(this) } //定义方法来改变state的值 addItem() { this.setState({ itemCount: this.state.itemCount + 1 }); } render() { return ( &lt;div&gt; /* 调用方法，改变state*/ &lt;button onClick={this.addItem}&gt;Click Me&lt;/button&gt; &lt;h1&gt;Current Item Count: {this.state.itemCount}&lt;/h1&gt; &lt;/div&gt; ); }}; 使用 state控制表单元素，例如 input等 textarea,下列代码创建了一个随着输入返回输入字符的 input 123456789101112131415161718192021222324252627class ControlledInput extends React.Component { constructor(props) { super(props); this.state = { //先声明了一个空字符作为作为input的初始值 input: '' }; //为input 的onChange的函数绑定this this.handleChange = this.handleChange.bind(this) } //定义onChange时调用的函数，其中event.target.value用于获取输入的字符 handleChange(event) { this.setState({ input: event.target.value }) } render() { return ( &lt;div&gt; &lt;input value={this.state.input} onChange={this.handleChange} /&gt; &lt;h4&gt;Controlled Input:&lt;/h4&gt; /*渲染p元素，得到input的值*/ &lt;p&gt;{this.state.input}&lt;/p&gt; &lt;/div&gt; ); }}; 给子组件传递 state： 自顶向下的数据流 父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI只能影响树中下方的组件。如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。在 React应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。我们可以在有状态组件中使用无状态组件，也可以在无状态组件中使用有状态组件。 复杂的状态组件可以被拆分成单个状态组件，其他的组件可以像接收属性一般从父组件接收 state，并渲染 ui。具体用法如下： 1234567891011121314151617181920212223242526272829class Navbar extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; /* 设定将被调用的属性name */ &lt;h1&gt;Hello, my name is:{this.props.name} &lt;/h1&gt; &lt;/div&gt; ); }};class MyApp extends React.Component { constructor(props) { super(props); this.state = { name: 'CamperBot' } } render() { return ( &lt;div&gt; /* 传递state.name给name属性*/ &lt;Navbar name={this.state.name} /&gt; &lt;/div&gt; ); }}; 传递 callback 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class GetInput extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; &lt;h3&gt;Get Input:&lt;/h3&gt; &lt;!--/* 在此处将从父组件的得到的属性值赋值给value*/--&gt; &lt;input value={this.props.input} onChange={this.props.handleChange}/&gt; &lt;/div&gt; ); }};class RenderInput extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; &lt;h3&gt;Input Render:&lt;/h3&gt; &lt;p&gt;{this.props.input}&lt;/p&gt; &lt;/div&gt; ); }};class MyApp extends React.Component { constructor(props) { super(props); this.state = { inputValue: '' } this.handleChange = this.handleChange.bind(this); } /*定义handleChange方法，并把输入的值赋值给state.inputValue*/ handleChange(event) { this.setState({ inputValue: event.target.value }); } render() { return ( &lt;div&gt; /* 传递参数，为属性input handleChange 赋值*/ &lt;GetInput input={this.state.inputValue} handleChange={this.handleChange} /&gt; &lt;RenderInput input={this.state.inputValue} /&gt; &lt;/div&gt; ); }}; React组件的主要 API 设置状态：setState ``setState( nextState[, callback])，参数： nextState，表示将要设置的新状态，该状态会和当前的 state合并， callback，为可选参数，回调函数。该函数会在 setState设置成功，且组件重新渲染后调用。 setState()总是会触发一次组件重绘，除非在 shouldComponentUpdate()中实现了一些条件渲染逻辑。 替换状态：replaceState ``replaceState( nextState[, callback]) 参数： nextState，将要设置的新状态，该状态会替换当前的 state。 callback，可选参数，回调函数。该函数会在 replaceState设置成功，且组件重新渲染后调用。 replaceState()方法与 setState()类似，但是方法只会保留 nextState中状态，原 state不在 nextState中的状态都会被删除。 设置属性：setPropssetProps( nextProps[, callback]) 参数： nextProps，将要设置的新属性，该状态会和当前的 props合并 callback，可选参数，回调函数。该函数会在 setProps设置成功，且组件重新渲染后调用。 设置组件属性，并重新渲染组件。 注意： props相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。当和一个外部的 JavaScript应用集成时，我们可能会需要向组件传递数据或通知 React.render()组件需要重新渲染，可以使用 setProps()。 更新组件，我可以在节点上再次调用 React.render()，也可以通过 setProps()方法改变组件属性，触发组件重新渲染。 替换属性：replacePropsreplaceProps( nextProps[,callback]).参数： nextProps，将要设置的新属性，该属性会替换当前的 props。 callback，可选参数，回调函数。该函数会在 replaceProps设置成功，且组件重新渲染后调用。 注意：replaceProps()方法与 setProps类似，但它会删除原有 props。 强制更新：forceUpdate ``forceUpdate(callback) ，参数说明： callback，可选参数，回调函数。该函数会在组件 render()方法调用后调用。 注意： forceUpdate()方法会使组件调用自身的 render()方法重新渲染组件，组件的子组件也会调用自己的 render()。但是，组件重新渲染时，依然会读取 this.props和 this.state，如果状态没有改变，那么 React只会更新 DOM。 forceUpdate()方法适用于 this.props和 this.state之外的组件重绘（如：修改了 this.state后），通过该方法通知 React需要调用 render() 一般来说，应该尽量避免使用 forceUpdate()，而仅从 this.props和 this.state中读取状态并由 React触发 render()调用。 获取 DOM节点：findDOMNodefindDOMNode()返回值：DOM元素 DOMElement注意： 如果组件已经挂载到 DOM中，该方法返回对应的本地浏览器 DOM元素。当 render返回 null或 false时，this.findDOMNode()也会返回 null。从 DOM中读取值的时候，该方法很有用，如：获取表单字段的值和做一些 DOM操作。 判断组件挂载状态：isMounted：返回值：true或 false，表示组件是否已挂载到 DOM中注意：isMounted()方法用于判断组件是否已挂载到 DOM中。可以使用该方法保证了 setState()和 forceUpdate()在异步场景下的调用不会出错。 组件的生命周期：一般来说，组件在页面刚加载时即开始生命周期的初始化，即 willmount和 DidMount发生在页面加载阶段。在此之后，当 state改变时，组件就进行了重新渲染 生命周期： 初始化 getDefaultProps()：设置默认的 props，也可以用 dufaultProps设置组件的默认属性. getInitialState():在使用 es6的 class语法时是没有这个钩子函数的，可以直接在 constructor中定义 this.state。此时可以访问 this.props componentWillMount():组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，在进行``render ()之前，此时可以修改 state。 render():react最重要的步骤，创建虚拟 dom，进行 diff算法，更新 dom树都在此进行。此时就不能更改 state了。 componentDidMount():组件渲染之后调用，在此处的 setState()将会重新渲染你的组件，只调用一次。 更新 componentWillReceiveProps(nextProps ):组件初始化时不调用，组件接受新的props时调用。 shouldComponentUpdate(nextProps, nextState):react性能优化非常重要的一环。组件接受新的 state或者 props时调用，我们可以设置在此对比前后两个 props和 state是否相同，如果相同则返回 false阻止更新，因为相同的属性状态一定会生成相同的 dom树，这样就不需要创造新的 dom树和旧的 dom树进行 diff算法对比，节省大量性能，尤其是在 dom结构复杂的时候 componentWillUpdata(nextProps, nextState):组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改 state render():组件渲染 componentDidUpdate():组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 卸载 componentWillUnmount():组件将要卸载时调用，一些事件监听和定时器需要在此时清除。 基本生命周期方法： componentWillMount在渲染前调用,在客户端也在服务端。 componentDidMount :在第一次渲染后调用，只在客户端。之后组件已经生成了对应的 DOM结构，可以通过 this.getDOMNode()来进行访问。 如果你想和其他 JavaScript框架一起使用，可以在这个方法中调用 setTimeout, setInterval或者发送 AJAX请求等操作(防止异步操作阻塞 UI)。 componentWillReceiveProps在组件接收到一个新的 prop(更新后)时被调用。这个方法在初始化 render时不会被调用。 shouldComponentUpdate返回一个布尔值。在组件接收到新的 props或者 state时被调用。在初始化时或者使用 forceUpdate时不被调用。可以在你确认不需要更新组件时使用。 componentWillUpdate在组件接收到新的 props或者 state但还没有 render时被调用。在初始化时不会被调用。 componentDidUpdate在组件完成更新后立即调用。在初始化时不会被调用。 componentWillUnmount在组件从 DOM中移除之前立刻被调用。 componentWillMount()、componentDidMount()用于初始化阶段，其中：WillMount只在组件初始化时调用，以后组件更新不调用，整个生命周期只调用一次。DidMount在组件渲染之后调用，在此处的 setState()将会重新渲染你的组件，只调用一次。两个方法都可在其中使用 addEventListener()方法添加事件，第一个参数为事件名’eventName‘,第二个参数为回调函数(不进行调用，不加括号)，用法:addEventListener('keydown', this.callback)也可以使用 removeEventListener()删除事件，参数同上 React的 style设置 inline方法： 1&lt;div style={{color: \"yellow\", fontSize: 16}}&gt;Hellow Yellow&lt;/div&gt; - 注意，`style={{}}`是两个中括号，样式与样式之间使用的是&apos;,&apos;而不是&apos;;&apos;而且 `fontSize`与 `html`中 `font-size`的区别，而且他们的值没有单位，默认为px,如果想用其他单位，例如&apos;em&apos;需要如下使用 `{fontSize: &apos;4em&apos;}`。除了px以外，其他的值都需要用引号。 调用变量方法：直接定义一个 style对象变量，将 css属性赋值，在 inline引用,类似于 123456//效果同上const styles = { color: 'yellow', fontSize: 16 }const jsx = &lt;div style={styles}&gt;Hellow Yellow&lt;/div&gt;` 在 react中进行条件判断： 在 render()的 return语句之前，可以不用 {}写 js代码,所以可以在此写需要在 return中被引用的变量，在 return中使用 {}引用。 也可以在 return前使用 if/else语句 可以再 jsx和 return中使用&amp;&amp;进行逻辑判断，条件为 true则返回对应的值，false则不返回。用法:{condition &amp;&amp; &lt;p&gt;markup&lt;/p&gt;}，在此，condition为 true则渲染 markup。此外， 也可以使用条件判断语句，condition ? expressionIfTrue : expressionIfFalse。条件判断语句也可以嵌套，如下括号中的语句可以看做是 condition1的 false结果condition1? true: (condition2? true:false)false 在 React创建列表可以使用 js的 map方法创建列表，示例如下，组件接收数组参数，每个列表元素分配一个 key，不然会出现警告 a key should be provided for list items，意思就是需要包含 key。一个元素的 key最好是这个元素在列表中拥有的一个独一无二的字符串 1234567891011121314151617function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key={number.toString()}&gt; {number} &lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; );}const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById('example')); React refReact支持一种非常特殊的属性 Ref，你可以用来绑定到 render() 输出的任何组件上。这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance）。这样就可以确保在任何时间总是拿到正确的实例。 使用方法:绑定一个 ref属性到 render的返回值上：&lt;input ref=&quot;myInput&quot; /&gt; 可以通过使用 this来获取当前 React组件，或使用 ref来获取组件的引用,示例： 123456789101112131415161718192021222324class MyComponent extends React.Component { handleClick() { // 使用原生的 DOM API 获取焦点 this.refs.myInput.focus(); } render() { // 当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs return ( &lt;div&gt; &lt;input type=\"text\" ref=\"myInput\" /&gt; &lt;input type=\"button\" value=\"点我输入框获取焦点\" onClick={this.handleClick.bind(this)} /&gt; &lt;/div&gt; ); }}ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example')); 渲染服务器中的组件：使用 renderToString()方法-渲染服务器中组件的目的：1.方便搜索引擎搜索 2.更快的加载速度。原因：被渲染过后##的 HTML远小于 javascript所写的 html文件。renderToString()由 ReactDOMServer提供，是一个全局对象，之接受一个参数，即 react元素，用法 ReactDOMServer.renderToString(&lt;component /&gt;)","link":"/posts/e0d98019/"},{"title":"Scss基础","text":"Scss使用Scss文件就是普通的文本文件，里面可以使用 css语法。文件后缀名使 .scss。以下命令用于在屏幕上显示 .scss文件转化的 css代码(假设文件名为test)：Scss test.scss如果要将显示结果保存成文件，后面再跟一个css文件名：Scss test.scss test.css生产环境中一般使用以下命令 Scss --style compressed test.Scss test.css Scss提供四个编译风格的选项：nested:嵌套缩进的 css代码，它是默认值expanded:没有缩进的、扩展的 css代码compact:简洁格式的 css代码compressed:压缩后的 css代码 你也可以让 Scss监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。 基本用法变量Scss变量以 $开头 12345$blue: #1875e7; div { color : $blue;} 变量需要写在 #{}中才能镶嵌在字符串中12345$side : left; .rounded { border-#{$side}-radius: 5px; } Scss允许在代码中使用算式12345body { margin: (14px/2); top: 50px + 100px; right: $var * 10%; } 允许嵌套允许元素嵌套，如下面的 css代码 123div hi { color: red;} 可以写成 12345div { h1{ color: red; }} 也允许属性嵌套，如 border-color属性，可以写成： 12345p { border: { color: red }} 注意，border后面必须加上冒号 在嵌套的代码块内，可以使用 &amp;引用父元素。比如 a:hover类，可以写成： 12345a { &amp;:hover { color: #fff }} 注释标准的 CSS注释 /* comment */ ，会保留到编译后的文件。 单行注释 // comment，只保留在 Scss源文件中，编译后被省略。 在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 代码的重用继承Scss允许一个选择器，继承另一个选择器。比如，现有 class1： 123 .class1 { border: 1px solid #ddd; } class2要继承 class1，就要使用 @extend命令： 1234 .class2 { @extend .class1; font-size:120%; } Mixin使用 @mixin命令，定义一个代码块 1234@mixin left { float: left; margin-left: 10px; } 使用 @include命令，调用这个 mixin。 123 div { @include left; } mixin的强大之处，在于可以指定参数和缺省值。 1234 @mixin left($value: 10px) { float: left; margin-right: $value; } 使用的时候，根据需要加入参数： 123 div { @include left(20px); } 下面是一个 mixin的实例，用来生成浏览器前缀。 12345 @mixin rounded($vert, $horz, $radius: 10px) { border-#{$vert}-#{$horz}-radius: $radius; -moz-border-radius-#{$vert}#{$horz}: $radius; -webkit-border-#{$vert}-#{$horz}-radius: $radius; } 使用的时候，可以像下面这样调用： 123 #navbar li { @include rounded(top, left); } #footer { @include rounded(top, left, 5px); } 颜色参数Scss提供了一些内置的颜色参数 1234lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 插入文件@import命令，用来哈如外部文件@import 'path/filename.scss' 如果插入的使 .css文件，则等同于 css的 import命令 高级用法条件语句@if可以用来判断 1234p { @if 1 + 1 == 2 {border: 1px solid;} @if 5 &lt; 3 {border: 2px dotted;}} 配套的还有 @else命令 12345@if lightness($color) &gt; 30% { background-color: #000;} @else { background-color: #fff;} 循环语句Scss支持 for循环 12345@for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; }} 也支持 while循环： 12345$i: 6;@while $i &gt; 0 { .item-#{$i} {width: 2em * $i;} $i: $i - 2;} each命令，作用于 for类似 12345@each $member in a, b, c, d { .#{$member} { background-img: url('/image/#{$member}.jpg') }} 自定义函数Scss允许用户编写自己的函数 123456789101112131415161718@function double($n) { @return $n * 2;}#sidebar { width: double(5px)}## `Scss`, or \"`Syntactically Awesome StyleSheets`\" `Css`的扩展语言变量声明： `$variableName: value`,如下：```css$main-fonts: Arial, sans-serif;$headings-color: green;//To use variables:h1 { font-family: $main-fonts; color: $headings-color;} Scss也可以使用嵌套的方式如 1234567parent { color: red; child { color: yellow; }} Mixins类似于 CSS的函数，代码如下,定义一个用于显示 box-shadow的 css函数： 12345678910111213&lt;style type='text/Scss'&gt; //定义函数 @mixin box-shadow($x, $y, $blur, $c){ -webkit-box-shadow: $x, $y, $blur, $c; -moz-box-shadow: $x, $y, $blur, $c; -ms-box-shadow: $x, $y, $blur, $c; box-shadow: $x, $y, $blur, $c; } 使用函数 div { @include box-shadow(0px, 0px, 4px, #fff); }&lt;/style&gt; @if and @else,像js的逻辑语句，代码如下 1234567891011121314@mixin text-effect($val) { @if $val == danger { color: red; } @else if $val == alert { color: yellow; } @else if $val == success { color: green; } @else { color: black; }} @for 像js的 for循环语句，有两种形式，一是”start through end” ,包括了最后的，或者 “start to end”，不包括最后的。代码如下： 1234567891011121314151617181920//through|to两种方式// #{$i} part is the syntax to combine a variable (i) with text to make a string@for $i from 1 through|to 12 { .col-#{$i} { width: 100%/12 * $i; }}//转换成CSS如下.col-1 { width: 8.33333%;}.col-2 { width: 16.66667%;}....col-12 { width: 100%;} @each 用来循环在 list或 map对象中的每一项，代码如下： 1234567891011121314151617181920212223//@each在map的使用方法,$key和$value就是对应map类型的建和值$colors: (color1: blue, color2: red, color3: green);@each $key, $value in $colors { .#{$value}-text {color: $value;}}//@each 在list中的使用方法@each $color in blue, red, green { .#{$color}-text {color: $color;}}//以上两种转换成CSS都如下.blue-text { color: blue;}.red-text { color: red;}.green-text { color: green;} 什么是 map对象：在 Scss中，map代表一种数据类型，可以包含若干键值对的对象类型，使用()包围一个 map，里面的键值对用逗号隔开，键和值可以是任何的 Scss数据类型，尽管一个值可以用在多个键上，但是通过一个键我们必须只能找到一个值。map不能直接在 css中使用，如果你把一个 map赋值给一个元素将会报错，代码如下: 12345$map: ( key1: value1, key2: value2, key3: value3); @while 类似于js的 while循环语句，在符合条件之前一直生成CSS规则，示例： 12345$x: 1;@while $x &lt; 13 { .col-#{$x} { width: 100%/12 * $x;} $x: $x + 1;} 分音 (Partials)Partials in Scss are separate files that hold segments of CSS code. These are imported and used in other Scss files. This is a great way to group similar code into a module to keep it organized.Names for partials start with the underscore (_) character, which tells Scss it is a small segment of CSS and not to convert it into a CSS file.如果需要导入 SCSS 或者 Scss 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Scss 不要编译这些文件，但导入语句中却不需要添加下划线。例如，将文件命名为 _colors.scss，便不会编译 _colours.css 文件。使用partials文件的方法如下： 123// 需要导入_mixins.scss文件In the main.scss file@import 'mixins' @extend 告诉 Scss 将一个选择器下的所有样式继承给另一个选择器。代码如下： 12345678910111213//基本样式.panel{ background-color: red; height: 70px; border: 2px solid green;}//@extend继承.big-panel{ @extend .panel; //看这里，通过该方法直接继承.panel的样式 width: 150px; font-size: 2em;}","link":"/posts/ba01e83a/"},{"title":"个人 dota2 项目","text":"此文档用于备份，防止 Github 仓库无法访问Github仓库地址 项目介绍 本项目是基于 dota2 中文官网以及 17173 网站中关于 dota2 的数据创建的全栈项目，仅用于个人练习。 项目使用了 flex 布局，主要支持使用移动端浏览。 项目支持登录和注销操作，大部分功能需要登录使用，账号密码为 admin。 英雄页面可以点击查看英雄具体内容，包括背景故事、昵称、阵营、技能（技能详情需要进一步的数据）等，支持筛选过滤，可在详情页面收藏该英雄 物品界面模拟网上商城，可以进行购物、结算等操作，有点击加入购物车的动画（小球抛物线）。 用户界面处理登录和注册事宜，且可查看已购买和已收藏。 后端使用 jwt 校验用户是否登录 用户数据保存在 server\\routes\\data 中 物品界面 个人中心界面 技术栈前端 使用了 Vue 全家桶(Vue，Vue-Router，Vuex)，cube-ui 组件库以及 CSS 预处理器 stylus 进行前端的开发以及样式的书写。 使用 axios 进行进行数据的请求 后端 使用 express 框架构建了基础的后台服务，通过前端发出请求进行数据的交流 使用 JSON Web Token 进行跨域认证，校验用户是否登录 使用说明部署项目1npm install 修改原始配置字体因为在使用 cube-ui 是使用了 amfe-flexibale，文档字体大小 rem 被固定，修改需要到找到 node_modules\\amfe-flexible\\index.js 文件，修改函数 setRemUnit，重新设置其 rem 的单位大小，本人修改如下： 1234function setRemUnit () { var rem = docEl.clientWidth / 20 docEl.style.fontSize = rem + 'px' } 启用后台服务1npm start 启用开发环境1npm run serve 启用生产环境1npm run build","link":"/posts/f4f838c8/"},{"title":"HEAD FIRST HTML & CSS 布局与定位","text":"在一个页面上设置两栏的方法1.使用 Css的 float属性（使用该属性必须给该元素设定宽度）：float:right(left) 这种方法会把使用该属性的元素独立出来，不在正常的元素流(flow)中，会覆盖在其他块元素上面,其他内联元素则会环绕在周围。 关于流动元素界面完善： 1.1 可设置在元素流中的元素的外边距，使其与 float的元素看起来更像两栏； 1.2 对页脚使用 css的 clear:right属性，指出页脚右边不允许有浮动内容； 1.3 流体与冻结设计以及凝胶设计：给整个页面设置一个 width属性，则该页面如何伸缩，其内容宽度均为该宽度，可给该元素的左右外边距(margin)设置为 auto[凝胶设置]，则伴随着浏览器伸缩，外边距会自动调整宽度，从而是页面更加完善；2.使用绝对定位(position:absolute)： 使用该属性后，设置方向属性（top`left \\right \\bottom ），该元素从元素流中被删除，覆盖在正常元素流之上（与float 不同，内联元素不会环绕在绝对定位的元素周围）。流元素中的页脚无法使用clear`属性处理被覆盖问题。 3.使用 CSS表格：具体如下，主要根据 css的 display属性进行设置，table表示表格,table-row表示表格的行；table-cell表示表格的单元格； 123456&lt;div id=\"tableContainer\"&gt; &lt;div id=\"tableRow\"&gt; &lt;div id=\"drinks\"&gt;&lt;/div&gt; &lt;div id=\"main\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132#tableContainer {display: table;border-spacing: 10px;}#tableRow {display: table-row;}#drinks { display: table-cell; background-color: #efe5d0; width: 20%; padding: 15px; vertical-align: top;}#main { display: table-cell; background: #efe5d0 url(images/background.gif) top left; font-size: 105%; padding: 15px; vertical-align: top;}#sidebar { display: table-cell; background: #efe5d0 url(images/background.gif) bottom right; font-size: 105%; padding: 15px; vertical-align: top;} 表格的 border-spacing和外边距的空间不会折叠，需注意。————————————————————————————————————————————————————————————————————————————————ref1ref2","link":"/posts/504cd380/"},{"title":"HTML5 语义化标签笔记","text":"HTML5 语义化标签笔记HTML5 语义化标签笔记&lt;ruby&gt;标签&lt;ruby&gt;标签：用于注音或类似操作于注释文本上方，一般与 &lt;rt&gt;和 &lt;rp&gt;标签连用语法如下 ：&lt;ruby&gt; — 用它将需要注释或注音标的文字内容包围住。&lt;rt&gt; — 这里面放置音标或注释，这个标记要跟在需要注释的文本后边。&lt;rp&gt; — 这个标记是防备那些不支持ruby标记的浏览器，主要用来放置括弧。对于支持这个标记的浏览器，rp标记的CSS样式是{display:none;}，也就是不可见。示例： 1234&lt;ruby&gt;北&lt;rp&gt;（&lt;/rp&gt;&lt;rt&gt;bei&lt;/rt&gt;&lt;rp&gt;）&lt;/rp&gt;京&lt;rp&gt;（&lt;/rp&gt;&lt;rt&gt;jing&lt;/rt&gt;&lt;rp&gt;）&lt;/rp&gt;&lt;/ruby&gt; 上方代码显示如下：&lt;ruby&gt;北&lt;rp&gt;（&lt;/rp&gt;&lt;rt&gt;bei&lt;/rt&gt;&lt;rp&gt;）&lt;/rp&gt;京&lt;rp&gt;（&lt;/rp&gt;&lt;rt&gt;jing&lt;/rt&gt;&lt;rp&gt;）&lt;/rp&gt;&lt;/ruby&gt; 树形结构的标题标签可以在 &lt;section&gt;标签中嵌套标题标签 &lt;h1&gt;-&lt;h6&gt;，在section中的标题标签会自动降级，从而形成树形结构 12345678910111213141516&lt;section&gt; &lt;!-- 一级标签 --&gt; &lt;h1&gt;HTML 语义 &lt;/h1&gt; &lt;p&gt;balah balah balah balah&lt;/p&gt; &lt;section&gt; &lt;!-- 二级标签 --&gt; &lt;h1&gt; 弱语义 &lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;!-- 三级标签 --&gt; &lt;h1&gt; 结构性元素 &lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt;......&lt;/section&gt; 上述代码自动形成如下的情况： HTML 语义 balah balah balah balah 弱语义 balah balah 结构性元素 balah balah ...... 此外，也可以使用``标签嵌套标题标签，形成标签的树状结构 其他常用的语义化标签&lt;article&gt;:是一种特别的结构，它表示具有一定独立性质的文章，和body标签类似，一个html页面中可以有多个article存在&lt;header&gt;:通常出现在前部，标识导航或介绍性的内容&lt;footer&gt;:通常出现在尾部，包含一些作者信息、相关连接、版权信息等&lt;aside&gt;:表示跟文章主题不那么相关的部分，可能包含导航、广告等工具性质的内容 注意，aside和header中都可能出现导航(nav标签)，区别在于header中的导航多数是到文章自己的目录，二aside中的导航多数是到关联页面或者是整站地图 &lt;abbr&gt;:表示缩写，其title属性为鼠标hover时显示的内容&lt;hr&gt;:表示故事走向的转变或话题的转变的长横线&lt;blockquote&gt;、&lt;q&gt;、&lt;cite&gt;:这三个标签都是引用类的标签，blockquote 表示段落级引述内容，q 表示行内的引用，cite表示引述的作品名&lt;time&gt;:表示日期，在datatime属性赋值，格式为’xxxx-xx-xx’，内容为具体日期&lt;figure&gt;、&lt;figcaption&gt;:figure用于表示与著文章相关的图像、照片等流内容，figcaption为内容标题，可以省略，语法： 1234&lt;figure&gt; &lt;img src=\"xxx.jpg\"/&gt; &lt;figcaption&gt;The NeXT Computer used by Tim Berners-Lee at CERN.&lt;/figcaption&gt;&lt;/figure&gt; &lt;dfn&gt;：表示定义的名词&lt;pre&gt;、&lt;samp&gt;、&lt;code&gt;: pre表示预先排版过的内容，不需要浏览器进行排版；samp表示计算机程序的示例输出；code表示页面内的代码其他：","link":"/posts/166c81c3/"},{"title":"Css与HTML基础","text":"Css与HTML基础cssfont-family(用来设置字体，可以接收多个参数，第一个为首要字体，第二个为备用自体，方便第一个字体无法使用时，自动降级为第二个字体，如):font-family:Lobster, Monospace css优先级：外联样式中：不同层面的选择器:id级的优先级高于 Class级同一层面（比如同样是 id|同样是 class）的选择器，后加入的覆盖先加入的；内联样式的优先级高于外联样式的优先级无论什么情况,!important优先级最高 html使用 HTML来构建可以跟服务器交互的 Web表单(form)，通过给你的 form元素添加一个 action属性来达到此目的。action属性的值指定了表单提交到服务器的地址。submit的 button则是进行提交的元素&lt;form action=&quot;/url-where-you-want-to-submit-form-data&quot;&gt;&lt;/form&gt; 在 form中，如果你想把一个文本输入字段设置为必填项，在你的 input元素中加上 required属性就可以了，form中的其他的元素也类似，(注意:不适用于 safari浏览器) 每一个单选按钮都应该嵌套在它自己的 label(标签)元素中。注意：所有关联的单选按钮应该使用相同的name属性。下面是一个单选按钮的例子：&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;indoor-outdoor&quot;&gt; Indoor&lt;/label&gt; 使用 checked属性，你可以设置复选按钮和单选按钮默认被选中。为此，只需在 input元素中添加属性 checked,&lt;input type=&quot;radio&quot; name=&quot;test-name&quot; checked&gt; button、input等元素的 disabled属性，用来将该元素设置为不可点选，默认为 false","link":"/posts/518e48f6/"},{"title":"Symbol 与前端架构图","text":"前端架构图 与 Symbol前端知识架构图 JavaScript架构图 HTML与CSS架构图 浏览器知识架构图 ES6中新的原始数据类型–Symbol概述ES6引入了一种新的原始数据类型 Symbol，表示独一无二的值。Symbol值通过 Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol类型。凡是属性名属于 Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。注意，symbol函数前不能用 new命令，因为它不是对象，只是一个类似于字符串的数据类型 Symbol函数可以接受一个字符串作为参数，表示对 Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 注意 Symbol函数的参数只是表示对当前 Symbol值的描述，因此相同参数的 Symbol函数的返回值是不相等的。 symbol值不能与其他类型的值进行运算，否则会报错，但是 symbol值可以显式转为字符串或布尔值，但不能转化为数值 作为属性名的 Symbol由于每一个 Symbol值都是不相等的，这意味着 Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。如下所示通过方括号结构和 Object.defineProperty,将对象的属性名指定为一个 Symbol值： 1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = 'Hello!';// 第二种写法let a = { [mySymbol]: 'Hello!'};// 第三种写法let a = {};Object.defineProperty(a, mySymbol, { value: 'Hello!' });// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" 注意，Symbol值作为对象属性名时，不能用点运算符,因为点运算符后面总是字符串，所以不会读取作为 Symbol类的标识名所指代的那个值，导致它的属性名实际上是一个字符串，而不是一个 Symbol值。","link":"/posts/3b73b175/"},{"title":"webpack学习","text":"Webpack 是一个打包工具，可以在主目录创建 webpack.config.js 配置文件对其进行配置。 配置内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//webpack.config.js 配置const path = require('path')const HtmlWebpackPlugin = require('html-weback-plugin')const MiniExtractPlugin = require('mini-css-extract-plugin');// css 文件提取插件，无此插件，css 与 js 被编译到同一个文件const { CleanWebpackPlugin } = require('clean-webpack-plugin'); //打包前清理输出目录// 没有以下插件的情况下，在 webpack 提取出的 js 和 css 文件中，只会压缩 js 文件，不会压缩 css 文件，因此，需要手动配置插件压缩 css 文件，但是手动压缩 css 文件后， js 文件也需要手动压缩const TerserJSPlugin = require('terser-webpack-plugin'); //压缩jsconst OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin'); // 压缩 cssmodule.exports = { entry: entrfile.js // 配置总的入口文件 output ：{ filename: output.js,// 配置创建的出口文件名 path: path.resolve(__dirname, 'output.js') // 输出文件的路径， path.resolve 是 node.js 的 path 库自带的api, 用于拼接绝对路径，__dirname 表示当前目录 }, //以下是可选项 devServer: {// 配置 webpack 的开发服务器，使用该服务器需要在 package.json 中设置命令调用 \"webpack-dev-server\" port: 8080,//端口号 open: true, //布尔值，是否自动打开页面 compress: true, //布尔值。是否启动gzip压缩 contentBase: 'aa' //放置静态资源文件文件夹的路径，可在服务器上直接访问 }, optimization: { // 优化方法 // 注册压缩器 minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})], }, plugins: [ // 注册并配置 webpack 相关插件 new HtmlWebpackPlugin({ //插件，用于自动将模板文件内的 js 路径编译为打包后的 js 文件路径，该插件需要使用 require('html-webpack-plugin') 引用 template: 'index.js', //模板文件绝对路径， filename: 'bundle.js' //输出替换换后的文件名 }), new CleanWebpackPlugin(), new MiniExtractPlugin({ filename:\"css/main.css\" // 设置提取出来的 css 名称 }), ], module: { // 确定哪些文件需要转换，需要使用什么 loader 去进行转化 rules: [ // 需要注意 loader 配置的顺序，按数组反向加载，即从后往前 { test: /\\.css$/使用正则表达式匹配需要转换的文件， use: [ { // 使用 css 提取插件以后，css 不再使用 style 标签引用，而是使用 link 标签引用，因此需要使用以下 loader loader:MiniExtractPlugin.loader }, { // 此处是为了解析 在 css 文件内引用了 less 文件的嵌套的情况 loader: 'css-loader', options: { importLoaders: 1 // 表示用后面的 1 个 loader 去解析 } }, \"postcss-loader\", //使用 postcss loader 'less-loader'] }, { test: /\\.less$/, //使用正则表达式 匹配需要转换的文件 use: ['style-loader',\"css-loader\", 'less-loader'] // 配置对应的loader,需要注意 loader 配置的顺序， } ] }} postcss-loader 样式处理工具，可以借助自定义的插件重新定义 css 比如加私有前缀的插件 autoprefixer 12345//postcss.config.jsmodule.exports = { //配置插件 plugins: [require('autoprefixer')]}","link":"/posts/f13afe2d/"},{"title":"个人作品集","text":"个人作品集以下是个人作品集: Todo应用基于 vue-cli3 和 cube-ui 搭建的一个todo应用，支持新建、编辑、完成、删除任务，，支持对任务的批量处理，可记录任务用时。项目难点：对于页面刷新和关闭时，对于任务的保存，发现使用 beforeDestoryed 钩子函数。解决方法：在stack overflow 查询后，发现 beforeDestoryed 钩子只在 vue 实例被销毁前调用，但是刷新页面并没有触发 vue 的销毁，它仅仅是浏览器的主动行为。我们可以使用 window.onbeforeunload 属性实现需要的功能。 dota2英雄页面:请求本地 json 文件获得数据，使用 vue 框架和 BootstrapVue组件库 构建的Dota2英雄界面难点: 部署时，使用 v-bind 指令动态加载静态图片，无法指定到目标路径解决方法: 因为 webpack 是是在编译时打包文件，动态加载的路径是在运行时被执行，我们可以使用 require 或者 require.context 方法，强制 webpack 解析路径。 护眼计时器小程序:根据20-20-20原则设计的小程序，旨在提醒人们用眼20分钟以后，用20秒往20英尺(6米)以外的地方望一望，缓解用眼疲劳。 选课系统demo:无后台，使用原生JS实现，兼容IE8 原生JS实现一系列效果:使用原生的JavaScript实现的一系列效果，可点击进入网页查看 浏览器组件：使用原生JS实现的展开收起文字、鼠标滑过图片高亮、夜间模式、弹窗以及轮播图组件 dota2英雄背景故事页面:利用cheerio和require制作爬虫，从dota2官方网站爬取英雄信息保存到本地，利用bootstrap4制作的dota2英雄背景故事页面。 todo页面：使用jQuey实现todo的添加、删除、更改和完成，统计todo的完成情况 MarkDown编辑器：使用Vue框架搭建了一个MarkDown编辑器 使用Node.Js实现的爬虫爬取taptap评论:使用编辑器打开文件，给_main函数传入参数：需要爬取的网址和需要的条目数，调用函数，使用node打开爬虫文件，等待片刻即可。点击进入页面查看源码","link":"/posts/bb14fc85/"},{"title":"基于HTTP网络层的前端性能优化","text":"从输入 URL 地址到看到页面，HTTP 应用层都经历了什么1. url 解析url 会包含这些东西：一个 url 会类似这种： https://asdbc.com:443/index.html?key=value#anchor对上述的 url 进行解释：协议//域名（服务器地址）：端口号/请求资源的文件路径/?查询字符(key)=值(value)#片段标识符 url 编码根据规定，只有字母和数字 [0-9a-zA-Z]、一些特殊符号”$-_.+!*‘(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于 URL。因此，我们需要对 url 进行编码。 encodeURI(url):它着眼于对整个 URL 进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码。 encodeURIComponent(url):与 encodeURI()的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个 URL 进行编码。因此，”; / ? : @ &amp; = + $ , #”，这些在 encodeURI()中不被编码的符号，在 encodeURIComponent()中统统会被编码。 2. 缓存检查 在解析 DNS 之前，会先判断是否存在强缓存 若命中则直接返回缓存内容， 若无则进行正常流程，进行 DNS 解析，建立 TCP 连接，发送 HTTP 请求 发送请求时回去验证协商缓存，若命中则返回 304，拿取缓存资源 强缓存（强缓存命中后是不会发送 http 请求的）浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的 Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1.0） Cache-Control：cache-control: max-age=2592000 第一次拿到资源后的 2592000 秒内（30 天），再次发送请求，读取缓存中的信息（HTTP/1.1） 两者同时存在的话，Cache-Control 优先级高于 Expires 强缓存问题： 服务器文件更新，但本地有缓存，则无法拿到最新文件 HTML 文件一般不做强缓存 解决方法： 服务器更新资源后，让资源名称变更，这样页面将导入全新的资源（webpack 打包文件带 hash 值） 当文件更新后，在 Html 导入时，设置一个后缀（时间戳） 协商缓存 Last-Modified / ETag协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程 协商缓存流程： 第一次向服务器发送请求 没有协商缓存，向服务器发送请求（未传递任何标识） 服务请收到请求准备内容 Last-Modified：资源文件最后更新的时间 ETag：记录的是一个标识（即根据资源文件更新生成的，每次资源更新都会重新生成一个） 客户端拿到信息后渲染，将信息和标识缓存到本地 第二次发请求 客户端发送 If-Modified-Since 与 If-None-Match If-Modified-Since 对应 Last-Modified 值 If-None-Match 对应 ETag 值 发送给服务器 服务器根据标识判断文件是否更新 Last-Modified 与 ETag 区别Last-Modified 只能精确到秒，而 ETag 只要有改变就会重新生成 强缓存和协商好缓存一般只应用于静态资源文件数据的缓存，一般由我们自己保存到客户端存储中，根据自己设置的过期时间判断是否需要更新协商缓存与强缓存区别： 协商缓存总会和服务器协商，所以一定会发 http 请求 3. DNS 解析我们需要对 dns 进行解析才能找到域名对应的 ip 地址，但是 dns 解析也是一个耗时的操作，好在我们也存在 dns 缓存 对 DNS 缓存进行查询的时候，我们会按照 客户端 =&gt; 浏览器缓存 =&gt; 本地的 hosts 文件 =&gt; 本地 DNS 解析器缓存 =&gt; 本地 DNS 服务器 的方式进行迭代查询 若无法命中对应的 DNS 缓存，我们就需要对 DNS 服务器进行递归查询了 优化 DNS 解析过程： 减少 DNS 请求，一个页面尽可能少用不同的域名，资源都放在相同的服务器中（很少用，因为资源存放的服务器很多，不同服务器压力不同） 使用 link 标签实现 dns 预解析： 12&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\" /&gt;&lt;link rel=\"dns-prefetch\" href=\"&lt;url&gt;\" /&gt; 服务器拆分优势： 资源的合理利用 抗压能力加强 提高 HTTP 并发、 4. TCP 三次握手TCP 名词介绍： seq 序号，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记 ack 确认序号，只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1 标志位 ACK：确认序号有效 RST：重置连接 SYN：发起一个新连接 FIN：释放一个连接 三次握手为什么不用两次，或者四次? TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率！ 我们可以模拟一下三次握手客户端和服务端的应答： 客户端：你好（发送后等待服务端应答，确定服务端可以接收和发送数据） 服务端：你好（发送后等待客户端应答，确定客户端可以接受到数据） 客户端： 我要发信息了（发送后，双方已经确定对方能够正常收发数据，连接成功建立） 因此，两次握手无法判断客户端可以正常接收到数据，而四次握手则会浪费资源 5. 数据传输发送 HTTP 请求发送请求报文 HTTP 请求返回返回 HTTP 响应 常见响应状态码 200 OK 202 Accepted ：服务器已接受请求，但尚未处理（异步） 204 No Content：服务器成功处理了请求，但不需要返回任何实体内容 206 Partial Content：服务器已经成功处理了部分 GET 请求（断点续传 Range/If-Range/Content-Range/Content-Type:”multipart/byteranges”/Content-Length….） 301 Moved Permanently 302 Move Temporarily 304 Not Modified 305 Use Proxy 400 Bad Request : 请求参数有误 401 Unauthorized：权限（Authorization） 404 Not Found 405 Method Not Allowed 408 Request Timeout 500 Internal Server Error 503 Service Unavailable 505 HTTP Version Not Supported 6. TCP 四次挥手 为什么连接的时候是三次握手，关闭的时候却是四次握手？ 服务器端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文 但关闭连接时，当服务器端收到 FIN 报文时，很可能并不会立即关闭链接，所以只能先回复一个 ACK 报文，告诉客户端：“你发的 FIN 报文我收到了”，只有等到服务器端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要四步握手。 HTTP1.0/1.1/2 区别HTTP 1.0 与 1.1 的一些区别 缓存处理，HTTP1.0 中主要使用 Last-Modified，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略：ETag，Cache-Control… 带宽优化及网络连接的使用，HTTP1.1 支持断点续传，即返回码是 206（Partial Content） 错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除… Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request） 长连接，HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点 HTTP2.0和HTTP1.X相比的新特性 新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合，基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮 header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小 服务端推送（server push），例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了 12// 通过在应用生成HTTP响应头信息中设置Link命令Link: &lt;/styles.css&gt;; rel=preload; as=style, &lt;/example.png&gt;; rel=preload; as=image 多路复用（MultiPlexing） HTTP/1.0 每次请求响应，建立一个TCP连接，用完关闭 HTTP/1.1 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； HTTP/2.0 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；总结 利用缓存 对于静态资源文件实现强缓存和协商缓存（扩展：文件有更新，如何保证及时刷新？） 对于不经常更新的接口数据采用本地存储做数据缓存（扩展：cookie / localStorage / vuex|redux 区别？） DNS 优化 分服务器部署，增加 HTTP 并发性（导致 DNS 解析变慢） DNS Prefetch TCP 的三次握手和四次挥手 利用 Connection:keep-alive 来避免频繁开关 TCP 连接 数据传输 - 减少数据传输的大小 - 内容或者数据压缩（webpack 等） - 服务器端一定要开启 GZIP 压缩（一般能压缩 60%左右） - 大批量数据分批次请求（例如：下拉刷新或者分页，保证首次加载请求数据少） - 减少 HTTP 请求的次数 - 资源文件合并处理 - 字体图标 - 雪碧图 CSS-Sprit - 图片的 BASE64…… CDN 服务器“地域分布式” 采用 HTTP2.0","link":"/posts/b8c7ab12/"},{"title":"异步迭代器与生成器","text":"Async iterator and generators翻译自Morden Javascript Tutorial-Async Iterators and Generators 异步 iterator 可以迭代异步请求得到的数据。例如，我们从网络分段下载的数据。异步 generators 使这一步骤更加方便。 首先，让我们来看一个简单的示例来掌握句法，然后再去看一看现实生活中的例子。 Async iteratorAsync iterator 与常规的 iterator 类似，不过有一点语法上的区别。 一个“常规的” iterables 对象，即我们在 info:iterable 章节中提到的，是这样的： 123456789101112131415161718192021222324252627282930313233let range = { from: 1, to: 5, // 使用 for..of 语句的时候就会调用一次这个方法*!* [Symbol.iterator]() {*/!* // ... 它返回一个 iterator 对象： // 进一步说, for..of 只能作用于可迭代对象, // 使用 next() 方法访问下一个 values return { current: this.from, last: this.to, // next() 被 for..of 循环在每一次迭代过程中调用 *!* next() { // (2) // 它应该返回一个类似 {done:.., value :...} 的对象*/!* if (this.current &lt;= this.last) { return { done: false, value: this.current++ }; } else { return { done: true }; } } }; }};for(let value of range) { alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5} 有需要的话，您可以返回关于 info:iterable 的章节查看常规的 iterators 的详细内容。 为了使对象可以异步地迭代： 我们需要使用 Symbol.asyncIterator 取代 Symbol.iterator。 next() 方法应该返回一个 promise。 我们应该使用 for await (let item of iterable) 循环来迭代这样的对象 接下来，让我们创建一个类似于之前的，可迭代的 range 对象，不过现在它会按照每秒一个的速度，异步地返回 values： 123456789101112131415161718192021222324252627282930313233343536373839404142434445let range = { from: 1, to: 5, // 使用 for await..of 语句的时候就会调用一次这个方法*!* [Symbol.asyncIterator]() { // (1)*/!* // ... 它返回一个 iterator 对象： // 进一步说, for await..of 只能作用于可迭代对象, // 使用 next() 方法访问下一个 values return { current: this.from, last: this.to, // next() 被 for await..of 循环在每一次迭代过程中调用 *!* async next() { // (2) // 它应该返回一个类似 {done:.., value :...} 的对象 // (会被 async 关键字自动包装成一个 promise)*/!**!* // 可以在内部使用 await 关键字来执行异步任务: await new Promise(resolve =&gt; setTimeout(resolve, 1000)); // (3)*/!* if (this.current &lt;= this.last) { return { done: false, value: this.current++ }; } else { return { done: true }; } } }; }};(async () =&gt; {*!* for await (let value of range) { // (4) alert(value); // 1,2,3,4,5 }*/!*})() 正如我们看到的，其结构类似于常规的 iterators: 为了异步地迭代一个对象，这个对象必须有 Symbol.asyncIterator 方法 (1) 这个方法必须返回一个带有 next() 方法的对象，该方法会返回一个 promise。(2) 这个 next() 方法可以不使用 async 关键字，它可以是一个常规的方法返回一个 promise，但是使用 async 关键字允许在方法内部使用 await，所以会更加方便。这里我们只是用来延迟 1 秒操作。(3) 我们使用 for await(let value of range) (4)，也就是在 for 后面增加 await。它会调用一次 range[Symbol.asyncIterator]() 方法一次然后调用它的 next() 方法访问 values 这里有一个备忘单表示： Iterators Async iterators 提供 iterator 的对象方法 Symbol.iterator Symbol.asyncIterator next() 返回的值是 任意值 Promise 使用的循环语法是 for..of for await..of header123456789展开运算符要求常规的，同步的 `iterators`，无法工作于异步的 `iterators`。例如，展开运算符在以下代码无法执行：```jsalert( [...range] ); // 错误，没有 Symbol.iterator```这很正常，因为它要找到 `Symbol.iterator`，正如 `for..of` 没有 `await`，而非 `Symbol.asyncIterator`。 1234567891011121314151617## Async generators正如我们所知，JavaScript 也支持 `generators`，并且他们也是可迭代的。让我们来回顾一下 `generators` 所在的章节 [info:generators](info:generators)。它从 `start` 到 `end` 生成了一系列的值：```jsfunction* generateSequence(start, end) { for (let i = start; i &lt;= end; i++) { yield i; }}for(let value of generateSequence(1, 5)) { alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5} 在常规的 generators 中，我们无法使用 await， 所有的值都必须同步获得：无法在 for..of 循环中延迟执行，这是一个同步的结构。 但如果我们在 generator 内使用 await 呢？我们可以以网络请求为例子。 很简单，只需要在前面加上 async，就像这样： 12345678910111213141516171819202122*!*async*/!* function* generateSequence(start, end) { for (let i = start; i &lt;= end; i++) {*!* // 很好，可以使用 await! await new Promise(resolve =&gt; setTimeout(resolve, 1000));*/!* yield i; }}(async () =&gt; { let generator = generateSequence(1, 5); for *!*await*/!* (let value of generator) { alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5 }})(); 现在，我们有了 async generator，可以使用 for await...of 迭代。 这实际上非常简单。我们加了 async 关键字，然后我们就能在 generator 内部使用 await，来执行 promise 和其他异步函数。 从技术上来讲，async generator 的另一个不同之处在于，它的 generatr.next() 方法现在也是异步地，它返回一个 promise 在一个常规的 generator 中，我们使用 result = generator.next() 来获得值。但在一个 async generator 中，我们应该添加 await 关键字，如下： 1result = await generator.next(); // result = {value: ..., done: true/false} Async iterables如我们所知道的，要是一个对象可迭代，我们需要给它添加 Symbol.iterator。 123456789let range = { from: 1, to: 5,*!* [Symbol.iterator]() { return &lt;object with next to make range iterable&gt; }*/!*} 对于 Symbol.iterator 来说，一个通常的做法是返回一个 generator，这好过返回一个带有 next() 方法的简单对象。 让我们来回想一下之前章节中的一个示例： 1234567891011121314let range = { from: 1, to: 5, *[Symbol.iterator]() { // 是 [Symbol.iterator]: function*() 的简写 for(let value = this.from; value &lt;= this.to; value++) { yield value; } }};for(let value of range) { alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5} 这有一个可迭代的对象 range，并且它的 generator *[Symbol.iterator] 实现了列出 value 的逻辑 如果们想要给 generator 加上异步操作，那么我们应该将 Symbol.iterator 带换成异步的 Symbol.asyncIterator： 123456789101112131415161718192021222324let range = { from: 1, to: 5,*!* async *[Symbol.asyncIterator]() { // 等价于 [Symbol.asyncIterator]: async function*()*/!* for(let value = this.from; value &lt;= this.to; value++) { // 在获得 value 之间暂停，执行其他任务 await new Promise(resolve =&gt; setTimeout(resolve, 1000)); yield value; } }};(async () =&gt; { for *!*await*/!* (let value of range) { alert(value); // 弹出 1, 然后 2, 然后 3, 然后 4, 然后 5 }})(); 现在 value 都是延迟 1 秒后才弹出 真实例子到目前为止，我们为了获得基础的了解，看到的都是简单的例子。接下来，我们就看一下真实应用的例子。 目前，有很多网络服务都是传递分页的数据。例如，当我们需要一个用户的清单，一个请求只返回了一个预定义数量的用户（例如：100 个用户） - “一页”，并且提供了一个前往下一页的 URL。 这种模式非常常见。不只是用户，基本所有数据都是。例如， GitHub 允许使用相同的，分页的方式找回提交记录： 我们应该提交一个请求到这种格式的 URL： https://api.github.com/repos/&lt;repo&gt;/commits。 它返回一个包含 30 条提交记录的 JSON 对象，并且在返回头的 Link 中提供了一个前往下一页的链接 然后我们可以使用那个链接作为下一个请求地址，获得更多的提交记录。 但是我们可以有一个更简单的 API：一个带有提交记录的可迭代对象，然后我们可以像这样来访问它们： 12345let repo = 'javascript-tutorial/en.javascript.info'; // 获得提交记录的 GitHub 仓库for await (let commit of fetchCommits(repo)) { // 处理提交记录} 我们可以使用一个函数 fetchCommits(repo) ，用来在任何需要的时候，为我们获取提交记录，发送请求等。并且让它关注于所有分页的数据。对于我们来说，它就是一个简单的 for await..of。 通过使用 async generator，我们可以很简单的实现它： 123456789101112131415161718192021async function* fetchCommits(repo) { let url = `https://api.github.com/repos/${repo}/commits`; while (url) { const response = await fetch(url, { // (1) headers: {'User-Agent': 'Our script'}, // github 要求 user-agent 头部 }); const body = await response.json(); // (2) 返回的数据是一个 JSON (提交记录的列表) // (3) 前往下一页的 URL 在头部，需要将其提取出来 let nextPage = response.headers.get('Link').match(/&lt;(.*?)&gt;; rel=\"next\"/); nextPage = nextPage &amp;&amp; nextPage[1]; url = nextPage; for(let commit of body) { // (4) 一个接一个地 yield 提交记录，直到最后一页 yield commit; } }} 我们使用浏览器的 info:fetch 方法从 URL 下载数据。它允许我们提供授权和其他需要的头部，这里 GitHub 需要的是 User-Agent fetch 的结果作为 JSON 被解析，那也是一个 fetch 的特殊方法 我们应该从返回头的 Link 中获得前往下一页的 URL。它有一个特殊的格式，所以我们可以使用正则表达式得到它。前往下一页的 URL 看起来像：https://api.github.com/repositories/93253246/commits?page=2，这是由 GitHub 自己生成的。 然后我们将接收的提交记录 yield 出来，当它结束的时候 – 下一个 while(url) 迭代将会触发，从而发送下一个请求 这是一个使用的例子（将会在用户的控制台显示） 1234567891011121314(async () =&gt; { let count = 0; for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) { console.log(commit.author.login); if (++count == 100) { // let's stop at 100 commits break; } }})(); 这就是我们想要的。从外面无法看到内部的是如何处理分页数据的请求的。对我们来说，那只是一个返回提交记录的 async generator 总结对于无需花费很长时间生成的数据，常规的 iterators 和 generators 工作良好。 当我们需要异步获得数据的时候，它们的异步的同行则有了发挥的机会，for await..of 会去替代 for..of。 异步与常规 iterator 的语法区别： Iterable Async Iterable 提供 iterator 的方法 Symbol.iterator Symbol.asyncIterator next() 返回的值是 {value:…, done: true/false} 被 resolves 成 {value:…, done: true/false} 的 Promise 异步与常规 generator 的语法区别： Generators Async generators 声明方式 function* async function* next() 返回的值是 {value:…, done: true/false} 被 resolves 成 {value:…, done: true/false} 的 Promise 在网络开发中，我们经常会遇到数据流，例如下载或者上传大文件。 我们可以使用 async generator 来处理类似的数据。值得注意的是，在一些环境，例如浏览器环境下，还有另外一个 API 被叫做 Streams，它提供一些特殊的接口来操作类似的数据流，来传输数据或将其从一个数据流传递到另一个数据流（例如，从一个地方下载后立刻将其发送到其他地方）","link":"/posts/3346a9db/"},{"title":"手写 promise","text":"极简版12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 常量const PENDING = \"pending\", // 待定 FULFILLED = \"fulfilled\", // 成功 REJECTED = \"rejected\"; // 失败class MyPromise { constructor(executor) { this.state = PENDING; // promise 的初始状态 this.value = undefined; // resolve后获得的值 this.reason = undefined; // reject 后获得的值 // executor 的函数参数，将 state 转为 fulfilled let resolve = (value) =&gt; { if (this.state === PENDING) { this.state = FULFILLED; this.value = value; } }; // executor 的函数参数，将 state 转为 rejected let reject = (reason) =&gt; { if (this.state === PENDING) { this.state = REJECTED; this.reason = reason; } }; // 执行 executor try { executor(resolve, reject); } catch (e) { // 报错则直接将 promise 置为 rejected reject(e); } } // 重头戏 then(onFulfilled, onRejected) { if (this.state === FULFILLED) { onFulfilled(this.value); } else if (this.state === REJECTED) { onRejected(this.reason); } }} 以上代码实现了同步情况下的 promise 我们可以看一下以下的测试代码 1234567891011121314151617181920212223// 测试// 同步let promise = new MyPromise((resolve, reject) =&gt; { resolve(100);});promise.then((val) =&gt; { console.log(val);});// 结果 : 100// 异步let promise1 = new MyPromise((resolve, reject) =&gt; { setTimeout(() =&gt; { // setTimeout 异步执行，执行到 then 的时候， promise 中的 value 尚未得到 resolve(100); console.log(\"didResolve\"); }, 0);});promise1.then((val) =&gt; { console.log(val); // undefined});// 结果： undefined -&gt; didResolve 通过以上测试代码，我们可以知道，我们定义的 MyPromise 目前只能处理同步的情况。当遇到异步(上述的 setTimeout 宏任务)的时候，会先执行同步代码，即先执行 then() 方法，此时的 val 为 undefined。 因此返回一个 undefined，而后才执行 resolve，因此，我们的 MyPromise 还需要升级。 简单版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyPromise { constructor(executor) { this.status = PENDING; this.value = undefined; this.reason = undefined; this.onResolveFuncs = []; // *1 this.onRejectedFuncs = []; // *2 let resolve = (value) =&gt; { if (this.status === PENDING) { this.value = value; this.status = FULFILLED; this.onResolveFuncs.forEach((onResolveFunc) =&gt; onResolveFunc()); // *3 } }; let reject = (reason) =&gt; { if (this.status === PENDING) { this.reason = reason; this.status = REJECTED; this.onRejectedFuncs.forEach((onRejectedFunc) =&gt; onRejectedFunc()); // *4 } }; try { executor(resolve, reject); } catch (e) { reject(e); } } then(onFulfilled, onRejected) { // 返回一个 promise let promise = new Promise((resolve, reject) =&gt; { if (this.status === FULFILLED) { let x = onFulfilled(this.value); } else if (this.status === REJECTED) { onRejected(this.reason); } else { this.onResolveFuncs.push(() =&gt; onFulfilled(this.value)); // *5 this.onRejectedFuncs.push(() =&gt; onRejected(this.reason)); // *6 } }); return promise; }}// testlet promise1 = new MyPromise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(100); console.log(\"didResolve\"); }, 0);});promise1.then((val) =&gt; { console.log(val);});// 100 -&gt; didResolve 如上，我们新增加了 6 段代码，让我们一一来说明一下： *1 和 *2： 新建了 MyPromise 的两个原型属性 onResolveFuncs 和 onRejectedFuncs； *5 和 *6： 当我们执行到 then 方法，而 MyPromise 的状态还是 pending 时（即当 MyPromise 是异步的时候），将 then 方法中的回调函数（参数）都注册到 onResolveFuncs 和 onRejectedFuncs 中，来接收将来 resolve 或者 reject 掉的 value 或者 reason； *3 和 *4： 当 MyPromise 实例执行了 resolve 或 reject 方法时，遍历执行注册（储存）在 onResolveFuncs 和 onRejectedFuncs 的所有函数 以上可以解决 MyPromise 异步导致的 then 方法的函数参数无法顺利执行问题。 我们可以知道，resolve 和 reject 方法其实很简单，只是用于改变 promise 的状态，获得 executor 赋予的 value 或者 reason，并最终调用注册在 onResolveFuncs 和 onRejectedFuncs 的所有函数。 但是，问题它又来了，因为仅按照上面的代码，无法实现 then 方法的链式调用，而链式调用时怎么做的呢？ 根据 Promises/A+ 规范，then 方法必须返回一个新的 promise，接下来我们可以看一下升级版是如何实现的 升级版简单来说，要实现 promise 的链式调用，则在 then 方法中需要返回一个新的 Promise 实例，在触发 then 方法的回调函数时，根据函数返回的结果，分情况将结果 resolve 或者 reject 出去，从而返回一个 settled 的 Promise 用于继续调用 then 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** promise: then 方法返回的新的 Promise 实例* x: then 方法的函数参数调用后返回的结果* resolve, reject：Promise 内声明的方法*/// then 方法调用就会调用此方法// 此方法用于将 then 返回的 新的 promise 进行 resolve 或者 rejectfunction resolvePromise(promise, x, resolve, reject) { // *1 if (x === promise) { // 阻止 promise 的循环引用 throw new TypeError(\"Chaining cycle detected for promise\"); } // 声明一个变量用于防止重复 resolve 或者 reject let called; // 规范规定，带有 then 方法的对象或者函数都是 promise if (x !== null &amp;&amp; (typeof x === \"object\" || typeof x === \"function\")) { try { let then = x.then; // 若原始实例的 then 方法的函数参数返回了一个 promise，则将继续调用此方法， 将该 promise 状态变为 settled，并将获得的值 resolve 或 reject 掉 if (typeof then === \"function\") { then.call( x, (y) =&gt; { if (called) return; called = true; resolvePromise(promise, y, resolve, reject) }, (err) =&gt; { if (called) return; called = true; reject(err) } ) else { resolve(x) } } } catch(e) { if(called) return called = true reject(e) } } else { // 若是普通值，则直接 resolve 出去 resolve(x); }}class MyPromise { constructor(executor) { // ... 同上 } then(onFulfilled, onRejected) { // 返回一个 新的promise let promise = new Promise((resolve, reject) =&gt; { if (this.status === FULFILLED) { // resolvePromise 中的 promise 是由 MyPromise 创建的 // setTimeout 用于保证可以获取到 MyPromise 的实例 promise setTimeout(()=&gt; { // *2 try { let x = onFulfilled(this.value); resolvePromise(promise, x, resolve, reject); } catch(e) { reject(e) } }, 0) } else if (this.status === REJECTED) { setTimeout(()=&gt; { try { let x = onRejected(this.reason); resolvePromise(promise, x, resolve, reject); } catch(e) { reject(e) } }, 0) } else { this.onResolveFuncs.push(() =&gt; { setTimeout(()=&gt; { try { let x = onFulfilled(this.value); resolvePromise(promise, x, resolve, reject); } catch(e) { reject(e) } }, 0) }); this.onRejectedFuncs.push(() =&gt; { setTimeout(()=&gt; { try { let x = onRejected(this.reason); resolvePromise(promise, x, resolve, reject); } catch(e) { reject(e) } }, 0) }); } }); return promise; } catch(onReject) { return this.then(null, onReject) }} Promise 的静态方法Promise.all我们知道， Promise.all 接受一个 promise 数组作为参数（从技术上讲，它可以是任何可迭代的，但通常是一个数组）并返回一个新的 promise。 当所有给定的 promise 都被 settled 时，新的 promise 才会 resolve，并且其结果数组将成为新的 promise 的结果。 如果任意一个 promise 被 reject，由 Promise.all 返回的 promise 就会立即 reject，并且带有的就是这个 error。 123456789101112131415161718192021222324252627282930313233// 判断参数是否为 promise 对象function isPromise(obj) { if ((typeof obj === \"object\" &amp;&amp; obj !== null) || typeof obj === \"function\") { if (typeof obj.then === \"function\") { return true; } } else { return false; }}// 定义 promise.allPromise.all = function (arr) { return new MyPromise((resolve, reject) =&gt; { let results = []; let length = 0; // 计数器，判断何时 resolve 整个结果 arr.forEach((value, i) =&gt; { // 将数组内的元素都 promise 化，以拥有 then 方法 Promise.resolve(value).then( (v) =&gt; { results[i] = v; if (++length === arr.length) { resolve(results); } }, (e) =&gt; { reject(e); } ); }); });}; Promise.allSettledPromise.allSettled 与 Promise.all 类似，也接收一个 Promise 数组，但其返回一个数组，包括 fulfilled 和 rejected 的值，返回值格式： 'fulfilled', value: ...}, {status:'rejected', reason: ...}]12 手写如下： 12345678910111213141516171819202122232425262728293031const FULFILLED = \"fulfilled\", // 成功 REJECTED = \"rejected\"; // 失败MyPromise.allSettled = function (array) { return new Promise((resolve, reject) =&gt; { let results = []; let length = 0; // 定义一个函数用于处理数据，根据状态 status 将数据包装成对象 function resolveData(state, item, index) { results[index] = { status: state, value: item }; if (++length === array.length) { resolve(results); } } array.forEach((item, i) =&gt; { if (isPromise(item)) { item.then( (v) =&gt; { resolveData(FULFILLED, v, i); }, (e) =&gt; { resolveData(REJECTED, e, i); } ); } else { resolveData(FULFILLED, item, i); } }); });}; 根据大佬的 Polyfill， 发现可以写成这样: 1234567const resolveHandler = val =&gt; {status: 'fulfilled', value: val}, rejectHandler = err =&gt; {status: 'rejected', reason: err}MyPromise.allSettled = function(arr) { let toSettled = arr.map(promise =&gt; Promise.resolve(promise).then(resolveHandler, rejectHandler)) // *1 return Promise.all(toSettled)} 注意 *1 中先将 arr v 中的所有元素转变为 promise 对象，从而可以使用 then 方法。而后使用 Promise.all 方法等待结果返回。 Promise.race与 Promise.all 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。 当第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略。 12345678MyPromise.race = function (arr) { return new Promise((resolve, reject) =&gt; { arr.forEach((item) =&gt; { // 给所有元素都注册 then 方法，then 方法调用回调函数，则立刻resolve 或 reject Promise.resolve(item).then(resolve, reject); }); });}; Promise.resolve / Promise.reject1234567891011MyPromise.resolve = function (promise) { return new Promise((resolve, reject) =&gt; { resolve(promise); });};MyPromise.reject = function (promise) { return new Promise((resolve, reject) =&gt; { reject(promise); });}; 参考文章：史上最最最详细的手写Promise教程现代JavaScript教程","link":"/posts/3424aad5/"},{"title":"正则表达式","text":"FreeCodeCamp正则表达式创建方式： var reg = \\ pattern \\ flags var reg = new RegExp(pattern,flags) // pattern和flags都是字符串格式 正则表达式区分大小写正则表达式默认为“贪婪”匹配，使用限定符?可转变为‘lazy‘匹配正则表达式中的 pattern可以使用‘|’进行’或’匹配 .test()方法检测字符串中是否有正则表达式表达的值,返回 true或 false,语法：reg.text(string) .match() 返回正则表达式表达的值，语法： string.match(reg) 通配符 /./ 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 /[]/ 表示即将匹配的字符从[]里面的选一个组成 /+/限定符， 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 /*/ 限定符，匹配前面的子表达式零次或多次 /?/ 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 /[^]/ ^后面的字符表示不备匹配的 /^/定位符，表示字符集开头 /$/ 定位符, 匹配输入字符串的结尾位置。 /\\w/ 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 /\\W/ 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 {n}n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 $1-$9存放着正则表达式中最近的9个正则表达式的匹配结果，这些结果按照子匹配的出现顺序依次排列,需要使用引号引用功能：$1-$9存放着正则表达式中最近的9个正则表达式的匹配结果，这些结果按照子匹配的出现顺序依次排列。 基本语法 RegExp.$n 注意：这些属性是静态的，除了replace中的第二个参数可以省略RegExp之外，其他地方使用都要加上RegExp。","link":"/posts/2f57a694/"},{"title":"浏览器是如何渲染网页的？——DOM,CSSOM以及渲染","text":"翻译自 Uday Hiwarale 的 How the browser renders a web page? — DOM, CSSOM, and Rendering 前言当你开发一个网站的时候，有些东西对于良好的用户体验来说是非常必要的。网站可能遇到的一些常见问题可能是资源加载缓慢，在初始渲染时等待不必要的文件下载，样式未应用的内容闪烁(flash of unstyled content (FOUC))等。为了避免类似问题，我们需要了解浏览器渲染典型网页的生命周期。 首先，我们需要了解什么是 DOM。当浏览器相服务器发送请求，获取一个 HTML 文档的时候，服务器会返回一个二进制流格式的 HTML 页面，它基本就是一个文本文件，其响应头的 Content-Type 设置为 text/html;charset-UTF-8。这里的 text/html ·是一个 MIME 类型，它告诉浏览器这是一个 HTML 文档，charset=UTF-8 告诉浏览器它是以 UTF-8 字符编码的。利用这些信息，浏览器剋将二进制格式转换为可读的文本文件。如下图所示。 如果该 header 缺失，浏览器将无法理解如何处理该文件，它将以纯文本格式呈现。但如果一切正常，经过这次转换后，浏览器就可以开始阅读 HTML 文档了。一个典型的 HTML 文档大致如下: 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Rendering Test&lt;/title&gt; &lt;!-- stylesheet --&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;This is a sample paragraph.&lt;/p&gt; &lt;/div&gt; &lt;!-- script --&gt; &lt;script src=\"./main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在上面的文档中，我们的网页依赖 style.css 给 HTML 元素提供样式，main.js 来执行一些 JavaScript 操作。通过一些 CSS 样式，我们上面的网页就会变成这样： 但问题还是在于，浏览器是如何从一个简单的，只包含文本的 HTML 文件渲染出这个好看的网页呢？为此，我们需要了解什么是 DOM、CSSOM 和 Render Tree Document Object Model (DOM)当浏览器读取 HTML 代码时，只要遇到 body、div 等 HTML 元素，就会创建一个名为 Node 的 JavaScript 对象。 由于每个 HTML 元素都有不同的属性，所以 Node 对象将从不同的类(构造函数)中创建。例如，div 元素的 Node 对象是由继承自 Node 类的 HTMLDivElement 创建的。对于我们前面的 HTML 文档，我们可以用一个简单的测试来可视化这些节点，如下图： 浏览器自带了 HTMLDivElement、HTMLScriptElement、Node 等内置类。 浏览器从 HTML 文档中创建了 Node 之后，就要把这些节点对象创建成树状结构。由于我们在 HTML 文件中的 HTML 元素是互相嵌套的，所以浏览器需要使用之前创建的 Node 对象复制它们。这将帮助浏览器在网页的整个生命周期中高效地渲染和管理网页。 我们之前的 HTML 文档的 DOM 树就像上面一样。一棵 DOM 树从最上面的 html 元素开始，根据 HTML 元素在文档中的出现和嵌套情况进行分支。每当发现一个 HTML 元素时，它就会从其各自的类中创建一个 DOM 节点（Node）对象（构造函数）。 一个 DOM 节点并不总是必须是一个 HTML 元素。当浏览器创建 DOM 树时，它也会将注释、属性、文本等内容作为树中的单独节点保存。但为了简单起见，我们只考虑 HTML 元素的 DOM 节点，也就是 DOM 元素。这里是所有 DOM 节点类型的列表。 你可以在 Google Chrome DevTools Console 中看到 DOM 树，如下所示。这将显示 DOM 元素的层次结构（DOM 树的高级视图）以及每个 DOM 元素的属性。 JavaScript 不明白 DOM 是什么，它不是 JavaScript 规范的一部分。DOM 是浏览器提供的一种高级 Web API，用于高效地渲染网页，供开发者动态操作 DOM 元素以达到各种目的。 使用 DOM API，开发者可以添加或删除 HTML 元素，改变其外观或绑定事件监听器。使用 DOM API，可以在内存中创建或克隆 HTML 元素，并在不影响 DOM 树的情况下进行修改。这使得开发者有能力构建高度动态的网页，并提供丰富的用户体验。 CSS Object Model (CSSOM)当我们设计一个网站时，我们的目的是让它尽可能的好看。而我们通过为 HTML 元素提供一些样式来实现。在 HTML 页面中，我们使用 CSS(Cascading Style Sheets，即层叠样式表) 为 HTML 元素提供样式。使用 CSS 选择器，我们可以针对 DOM 元素，为样式属性设置一个值，比如颜色或字体大小。 将样式应用到 HTML 元素上有不同的方法，比如使用外部 CSS 文件、使用 &lt;style&gt; 标签嵌入 CSS、使用 HTML 元素上的 style 属性的内联方法或使用 JavaScript。但最终，浏览器还是要担起将 CSS 样式应用到 DOM 元素上的重任。 比方说，对于我们前面的例子，我们将使用下面的 CSS 样式（这不是截图中显示的卡片所使用的 CSS）。为了简单起见，我们不打算理会如何在 HTML 页面中导入 CSS 样式。 1234567891011121314151617181920212223html { padding: 0; margin: 0;}body { font-size: 14px;}.container { width: 300px; height: 200px; color: black;}.container &gt; h1 { color: gray;}.container &gt; p { font-size: 12px; display: none;} 在构建了 DOM 之后，浏览器从所有的源头（外部的、嵌入式的、内嵌的、用户代理的等）读取 CSS ，并构建一个 CSSOM。CSSOM 是 CSS 对象模型的缩写，它和 DOM 一样是一个树状结构。 这个树中的每个节点都包含 CSS 样式信息，这些信息将被应用到它所针对的 DOM 元素上（由选择器指定）。然而，CSSOM 并不包含那些不能在屏幕上打印的 DOM 元素，如&lt;meta&gt;、&lt;script&gt;、&lt;title&gt;等。 我们知道，大多数浏览器都自带样式表，这个样式表被称为用户代理样式表，浏览器首先用开发者属性提供的 CSS 覆盖用户代理样式（使用特定性的规则），计算出 DOM 元素的最终 CSS 属性，然后构造一个节点。 即使某个 HTML 元素的 CSS 属性（如 display ）没有被开发者或浏览器定义，其值也会被设置为 W3C CSS 标准规定的该属性的默认值。在选择 CSS 属性的默认值时，如果某个属性符合 W3C 文档中提到的继承规则，则会使用一些继承规则。 例如，如果一个 HTML 元素缺少颜色和字体大小等属性，那么这些属性就会继承父元素的值。所以你可以想象一下，在一个 HTML 元素上有这些属性，它的所有子元素都会继承它。这就是所谓的样式层叠，这也是为什么 CSS 是层叠样式表的缩写。这也正是浏览器构建一个树状结构的CSSOM 的原因，用于根据 CSS 层叠规则计算样式。 您可以在 Element 面板中使用 Chrome DevTools 控制台查看 HTML 元素的计算样式。从左侧面板中选择任意一个 HTML 元素，然后点击右侧面板中的计算选项卡。 我们可以用下图来使前面例子的 CSSOM 树可视化。为了简单起见，我们将忽略用户代理样式，而专注于前面提到的 CSS 样式。 从上图中可以看出，我们的 CSSOM 树中不包含&lt;link&gt;、&lt;title&gt;、&lt;script&gt;等不会被打印到屏幕上的元素。红色的 CSS 属性值是从顶部层叠下来的，而灰色的属性值则是覆盖了继承的值。 Render TreeRender-Tree 也是一个将 DOM 树和 CSSOM 树组合在一起构建的树状结构。浏览器要计算每个可见元素的布局，并把它们画在屏幕上，为此浏览器使用了这个 Render-Tree。因此，如果没有构建 Render-Tree，那么任何东西都不会被打印在屏幕上，这就是为什么我们同时需要 DOM 和 CSSOM 树。 由于 Render-Tree 是对最终将被打印在屏幕上的内容的低级表示，它不会包含在像素矩阵(页面)中不包含任何区域(一定情况下可认为是：不占空间)的节点。例如，display:none;元素的尺寸为0px X 0px，因此它们不会出现在 Render-Tree 中。 从上图可以看出，Render-Tree 结合了 DOM 和 CSSOM，生成了一个树状结构，其中只包含了要打印在屏幕上的元素。 因为在 CSSOM 中，位于 div 内的 p 元素被设置了 display:none; 样式，所以它和它的子元素不会出现在 Render-Tree 中，因为它在屏幕上不占空间。但是，如果你有 visibility:hidden 或 opacity:0 的元素，它们将占据屏幕空间，因此它们将出现在 Render-Tree 中。 与 DOM API 不同的是，DOM API 可以访问浏览器构建的 DOM 树中的 DOM 元素，而 CSSOM 则是对用户隐藏的。但由于浏览器将 DOM 和 CSSOM 结合在一起形成了 Render Tree，所以浏览器通过在 DOM 元素本身提供高级 API 来暴露 DOM 元素的 CSSOM 节点。这样开发者就可以访问或改变 CSSOM 节点的 CSS 属性。 由于使用 JavaScript 操作元素的样式超出了本文的范围，所以这里有一个 CSS Tricks 文章的链接，它涵盖了 CSSOM API 的广泛范围。我们还有新的 JavaScript 中的 CSS Typed Object API，它可以更准确地操纵元素的样式。 渲染顺序现在我们已经很好地理解了什么是 DOM、CSSOM和 Render-Tree，让我们了解一下浏览如何使用它们来渲染一个典型的网页。对这个过程有一个最起码的了解对任何 Web 开发人员来说都是至关重要的，因为它将帮助我们设计我们的网站以获得最大的用户体验（UX）和性能。 当一个网页被加载时，浏览器首先读取 HTML 文本并从中构建 DOM 树。然后它处理 CSS，无论是内嵌的、嵌入式的、还是外部的 CSS，并从中构建 CSSOM 树。 构建完这些树后，它再从中构建 Render-Tree。一旦构建了 Render-Tree，浏览器就会开始在屏幕上打印各个元素。 布局操作首先浏览器创建每个单独的 Render-Tree 节点的布局。布局包括每个节点的大小（以像素为单位）和它将被打印在屏幕上的位置。这个过程被称为布局，因为浏览器正在计算每个节点的布局信息。 这个过程也被称为回流或浏览器回流(reflow)，当你滚动、调整窗口大小或操作 DOM 元素时，也会发生这个过程。这里是可以触发元素布局/回流的事件列表。 我们应该避免网页因为微不足道的原因进行多次布局操作，因为这是一种昂贵的操作。这里是 Paul Lewis 的一篇文章，他讲述了我们如何避免复杂而昂贵的布局操作以及布局打乱。 绘制操作直到现在，我们还有一个需要打印在屏幕上的几何体列表。由于 Render-Tree 中的元素（或子树）可以相互重叠，而且它们可以具有 CSS 属性，使它们经常改变外观、位置或几何显示（如动画），因此浏览器会为它创建一个图层。 创建图层可以帮助浏览器在网页的整个生命周期中高效地执行绘制操作，比如在滚动或调整浏览器窗口大小的时候。拥有图层还可以帮助浏览器按照开发者的意图，正确地按照堆叠顺序（沿 z 轴）绘制元素。 现在我们有了图层，我们可以将它们组合起来，并在屏幕上绘制。但是浏览器并不是一次性绘制所有的图层。每个图层都是先单独绘制的。 在每个图层里面，浏览器会对元素的任何可见属性，如边框、背景色、阴影、文字等进行单独的像素填充。这个过程也被称为栅格化。为了提高性能，浏览器可以使用不同的线程来执行栅格化。 Photoshop 中图层的类比也可以应用到浏览器渲染网页的方式。您可以从 Chrome DevTools 中看到网页上的不同图层。打开 DevTools，从更多工具选项中选择 “Layers”。您还可以从 “Rendering” 面板中看到图层边框。 栅格化通常是在 CPU 中完成的，这使得它的速度很慢，而且成本很高，但是我们现在有了新的技术，可以在 GPU 中进行性能提升。这篇 intel 文章 详细介绍了绘画主题，这是一篇必读的文章。要想详细了解图层的概念，这是一篇必读的文章。 合成操作到目前为止，我们还没有在屏幕上绘制一个像素。我们拥有的是不同的图层（位图图像），它们应该按照特定的顺序绘制在屏幕上。在合成操作中，这些图层会被发送到 GPU 上，最终将其绘制在屏幕上。 每次回流（布局）或重绘时都要将整个图层送去绘制，这显然是很低效的。因此，一个图层被分解成不同的块，然后将其绘制在屏幕上。你也可以在 Chrome 的 DevTool Rendering 面板中看到这些块。 从上面的信息中，我们可以从简单的 HTML 和 CSS 文本内容中，构建出一整个 浏览器从一个网页到在屏幕上渲染出事物所经历的事件顺序。 这个事件顺序也被称为 关键渲染路径 Mariko Kosaka 为这个流程写了一篇漂亮的文章，有酷炫的插图和对每个概念的更广泛的解释。强烈推荐。 浏览器引擎创建 DOM 树、CSSOM 树和处理渲染逻辑的工作是由一个叫做浏览器引擎（也称为渲染引擎或布局引擎）的浏览器进程来完成的，它位于浏览器内部。这个浏览器引擎包含了，将一个网页从 HTML 代码，渲染到屏幕上的实际像素的，所有必要的元素和逻辑。 如果你听到人们谈论 WebKit，他们说的是一个浏览器引擎。WebKit 被苹果的 Safari 浏览器使用，也是谷歌 Chrome 浏览器的默认渲染引擎。截至目前， Chromium 项目使用 Blink 作为默认渲染引擎。这里是一些顶级网络浏览器使用的不同浏览器引擎的列表。 浏览器的渲染流程我们都知道 JavaScript 语言是通过 ECMAScript 标准来实现标准化的，其实由于 JavaScript 被注册为商标，所以我们现在只叫它 ECMAScript。因此，每一个 JavaScript 引擎提供商，如 V8、Chakra、Spider Monkey 等都要遵守这个标准的规则。 有了标准，我们就可以在所有 JavaScript 运行时，如浏览器、Node、Deno 等，获得一致的 JavaScript 体验。这对于多平台的 JavaScript（和 Web）应用的一致和完美的开发是非常好的。 然而，浏览器的渲染方式却并非如此。HTML、CSS 或 JavaScript，这些语言都是由某个实体或某个组织标准化的。然而，浏览器如何将它们管理在一起，在屏幕上呈现东西，却不是标准化的。谷歌 Chrome 的浏览器引擎可能会与 Safari 的浏览器引擎做不同的事情。 因此，很难预测特定浏览器的渲染顺序及其背后的机制。然而，HTML5 规范已经做出了一些努力，在理论上标准化渲染应该如何工作，但浏览器如何遵守这一标准完全取决于它们。 尽管存在这些不一致的地方，但所有浏览器之间通常都有一些共同的原则。让我们来了解一下浏览器在屏幕上渲染事物的常见方法，以及这个过程的生命周期事件。 解析和外部资源解析是指读取 HTML 内容并从中构建 DOM 树的过程。因此，这个过程也被称为 DOM 解析，完成这个过程的程序被称为 DOM 解析器。 大多数浏览器都提供了 DOMParser Web API 来从 HTML 代码中构建 DOM 树。 DOMParser 类的一个实例代表了一个 DOM 解析器，使用 parseFromString 原型方法，我们可以将原始的 HTML 文本（代码）解析成一棵 DOM 树（如下图所示）。 当浏览器请求一个网页，服务器响应一些 HTML 文本（Content-Type 头设置为 text/html）时，浏览器可能会在整个文档的几个字符或几行字可用时就开始解析 HTML。因此，浏览器可以逐步建立 DOM 树，一次一个节点。浏览器从上到下解析 HTML，而不是中间的任何地方，因为 HTML 代表了一个嵌套的树状结构。 在上面的例子中，我们从 Node 服务器访问了 incremental.html 文件，并将网络速度设置为只有 10kbps（从网络面板）。由于浏览器加载（下载）这个文件需要很长的时间（因为它包含 1000 个 h1 元素），所以浏览器从最初的几个字节构建了一个 DOM 树，并将它们打印在屏幕上（因为它在后台下载 HTML 文件的剩余内容）。 如果你看一下上面请求的性能图，你就能在 Timing 行看到一些事件。这些事件通常被称为 性能指标。当这些事件放在尽可能近的地方，并且尽可能早的发生，用户体验会更好。 FP 是 First Paint 的缩写，意思是浏览器开始在屏幕上打印东西的时间（可以简单到正文背景色的第一个像素）。 FCP 是 First Contentful Paint 的缩写，意思是浏览器渲染出文字或图片等内容的第一个像素的时间。LCP 是 Largest Contentful Paint 的缩写，是指浏览器渲染大块文字或图片的时间。 L 代表 onload 事件，它是由浏览器在 window 对象上发出的。同样，DCL 代表 DOMContentLoaded 事件，它是在 document 对象上发出的，但会冒泡到 window 上，因此你也可以在 window 上监听它。这些事件理解起来有点复杂，所以我们稍后会讨论它们。 每当浏览器遇到一个外部资源，如通过 &lt;script src=&quot;url&quot;&gt;&lt;/script&gt; 元素的脚本文件（JavaScript）、通过 &lt;link rel=&quot;stylesheet&quot; href=&quot;url&quot;/&gt; 标签的样式表文件（CSS）、通过 &lt;img src=&quot;url&quot; /&gt; 元素的图像文件或任何其他外部资源，浏览器将在后台（JavaScript 执行的主线程之外）开始下载该文件。 最重要的一点是，DOM 解析通常发生在主线程上。因此，如果主 JavaScript 执行线程很忙，DOM 解析将无法进行，直到该线程空闲下来。你可能会问为什么这么重要？因为脚本元素是会阻塞解析器的。除了脚本(.js)文件请求外，每一个外部文件请求，如图片、样式表、pdf、视频等都不会阻塞 DOM 的构建(解析)。 解析器阻塞型脚本(Parser-Blocking Scripts)解析器阻塞型脚本是一个 script（JavaScript）文件/代码，它可以停止对 HTML 的解析。当浏览器遇到一个 script 元素时，如果它是一个嵌入式 script，那么它将首先执行该 script，然后继续解析 HTML，构建 DOM 树。所以所有的嵌入式 script都是解析器阻塞型的，讨论结束。 如果 script 元素是外部 script 文件，浏览器会在主线程之外开始下载外部 script 文件，但在该文件下载完毕之前，会停止主线程的执行。这意味着在 script 文件下载之前，不会再进行 DOM 解析。 一旦 script 文件下载完毕，浏览器将首先在主线程上执行下载好的 script 文件，然后继续进行 DOM 解析。如果浏览器再次发现 HTML 中的其他 script 元素，就会执行同样的操作。那么为什么浏览器要停止 DOM 解析，直到 JavaScript 被下载并执行？ 浏览器将 DOM API 暴露给 JavaScript 运行时，这意味着我们可以从 JavaScript 中访问和操作 DOM 元素。这就是 React 和 Angular 等动态 Web 框架的工作方式。但如果浏览器希望并行运行 DOM 解析和 script 执行，那么 DOM 解析线程和主线程之间可能会出现竞赛条件，这就是为什么 DOM 解析必须在主线程上进行。 然而，在后台下载 script 文件时停止 DOM 解析，在大多数情况下是完全没有必要的。因此，HTML5 为我们提供了 script 标签的 async 属性。当 DOM 解析器遇到一个带有 async 属性的外部 script 元素时，它不会在后台下载 script 文件时停止解析过程。但是一旦文件下载完毕，解析过程就会停止，script（代码）就会被执行。 我们还为 script 元素设置了一个神奇的 defer 属性，它的工作原理与 async 属性类似，但与 async 属性不同的是，即使文件完全下载完毕，script 也不会执行。一旦解析器解析了所有的 HTML，也就是说 DOM 树已经完全构建完成，所有的 defer script就会被执行。与异步 script 不同的是，所有的延迟 script 是按照它们在 HTML 文档（或 DOM 树）中出现的顺序来执行的。 所有普通的 script（嵌入式或外部）都是解析器阻塞型的，因为它们停止了 DOM 的构建。所有异步 script 在下载之前不会阻塞解析器。一旦一个异步 script 被下载，它就变成了阻断解析器的 script。然而，所有的 defer 脚本都是非阻断解析器型的脚本，因为它们不阻断解析器，并且在 DOM 树完全构建完成后执行。 在上面的例子中，parser-blocking.html 文件在 30 个元素后包含了一个阻塞解析的脚本，这就是为什么浏览器一开始显示 30 个元素，停止 DOM 解析，并开始加载脚本文件的原因。第二个脚本文件由于有 defer 属性，所以不会阻止解析，所以一旦 DOM 树完全构建完成，它就会执行。 如果我们看一下 Performance 面板，FP 和 FCP 会尽快发生（隐藏在 Timings 标签后面），因为浏览器一有 HTML 内容就开始建立 DOM 树，因此可以在屏幕上渲染一些像素。 LCP 发生在 5 秒后，因为阻塞解析器的脚本已经阻断了 5 秒的 DOM 解析（它的下载时间），当 DOM 解析器被阻断时，屏幕上只呈现了 30 个文本元素，这不足以被称为最大的内容绘制（根据 Google Chrome 标准）。但是一旦下载并执行该脚本，DOM 解析就恢复了，并且在屏幕上呈现了大量的内容，这导致了 LCP 事件的触发。 Parser-blocking 也被称为 render-blocking，因为除非 DOM 树被构造出来，否则渲染是不会发生的，但这两者是完全不同的事情，我们稍后会看到 一些浏览器可能会包含一个推测性解析策略，即 HTML 解析（但不包括 DOM 树的构建）被挂载到一个单独的线程中，这样浏览器就可以读取链接（CSS）、script、img 等元素，并更早地下载这些资源。 这对于以下这种情况来说是很有用的，比如你有三个紧贴的 script 元素，但由于 DOM 解析器无法读取第二个 script 元素，所以在第一个 script 下载完毕之前，浏览器无法开始下载第二个 script。我们可以通过使用 async 标签轻松解决这个问题，但是异步脚本不能保证按顺序执行。 之所以叫推测性解析，是因为浏览器在做一个推测，预计未来会加载某个资源，所以最好现在就在后台加载。但是，如果某些 JavaScript 操作 DOM，或用外部资源删除/隐藏元素，那么推测就失败了，这些文件就白白加载了。 每个浏览器都有自己的规范，所以不能保证何时或是否会发生推测性解析。不过，你可以使用 &lt;link rel=&quot;preload&quot;&gt; 元素要求浏览器提前加载一些资源。 渲染阻塞型 CSS正如我们所了解到的，除了阻塞解析器的 script 文件外，任何外部资源请求都不会阻塞 DOM 解析过程。因此，CSS（包括嵌入式）不会直接阻塞 DOM 解析器。等等，是的，CSS 可以阻止 DOM 解析，但在此之前，我们需要了解渲染过程。 浏览器内部的浏览器引擎使用从服务器接收到的 HTML 内容作为文本文档来构建 DOM 树。同样，它也会根据外部 CSS 文件或 HTML 中嵌入（以及内联）的 CSS 样式表内容来构建 CSSOM 树。 DOM 和 CSSOM 树的构建都发生在主线程上，而且这些树的构建是同时进行的。它们共同构成了用于在屏幕上打印东西的 Render Tree，而 Render Tree 也随着 DOM 树的构建而逐步构建。 我们已经了解到，DOM 树的生成是增量的，这意味着当浏览器读取 HTML 时，它会将 DOM 元素添加到 DOM 树中。但 CSSOM 树却不是这样。与 DOM 树不同，CSSOM 树的构建不是递增的，必须以特定的方式进行。 当浏览器找到 &lt;style&gt; 块时，它会解析所有嵌入的 CSS，并以新的 CSS （样式）规则更新 CSSOM 树。之后，它将继续以正常方式解析 HTML。内联样式也是如此。 然而，当浏览器遇到一个外部样式表文件时，事情就会发生巨大的变化。与外部 script 文件不同的是，外部样式表文件不是解析器阻塞型的资源，因此浏览器可以在后台静默地下载它，DOM 解析也会继续进行。 但与 HTML 文件（用于 DOM 构建）不同，浏览器不会一个字节一个字节地处理样式表文件内容。这是因为浏览器在读取 CSS 内容时，不能增量地构建 CSSOM 树。原因是，文件最后的 CSS 规则可能会覆盖写在文件顶部的 CSS 规则。 因此，如果浏览器在解析样式表内容时开始递增地构建 CSSOM，就会导致渲染树的多次渲染，因为样式覆盖规则会使同样的 CSSOM 节点，因后面新出现的样式表文件而导致更新。当 CSS 被解析时，可以在屏幕上看到元素样式的改变，这将是一种不愉快的用户体验。由于 CSS 样式是层叠的，一个规则的改变可能会影响许多元素。 因此，浏览器不会逐步处理外部 CSS 文件，CSSOM 树更新是在样式表中所有 CSS 规则处理完毕后一次性完成的。CSSOM 树更新完成后，再更新渲染树，然后渲染到屏幕上。 CSS 是一种渲染阻塞型资源。一旦浏览器提出获取外部样式表的请求，Render Tree 的构建就会停止。因此，关键渲染路径（CRP）也被卡住了，没有任何东西被渲染到屏幕上，如下图所示。然而，在后台下载样式表时，DOM 树的构建仍在进行中。 浏览器可以使用 CSSOM 树的旧状态来生成 Render Tree，因为 HTML 正在被解析，以递增的方式在屏幕上呈现事物。但这有一个巨大的缺点。在这种情况下，一旦样式表被下载和解析，CSSOM 被更新，Render Tree 就会被更新并呈现在屏幕上。现在，用旧 CSSOM 生成的 Render Tree 节点将重绘新的样式，这也可能导致 Flash of Unstyled Content (FOUC)，这对用户体验非常不利。 因此，浏览器会等到样式表被加载和解析。一旦样式表被解析，CSSOM 被更新，Render Tree 就会被更新，CRP 就会继续进行，从而使 Render Tree 绘制在屏幕上。由于这个原因，建议尽早加载所有外部样式表。 让我们想象一下这样一个场景：浏览器已经开始解析 HTML，并且遇到了一个外部样式表文件。它将在后台开始下载文件，阻塞 CRP，并继续进行 DOM 解析。但是它又遇到了一个 script 标签，于是它就会在后台开始下载外部脚本文件，并阻止 DOM 解析。现在浏览器是坐等样式表和脚本文件完全下载完毕。 但这次外部脚本文件已经完全下载完毕，而样式表还在后台下载。浏览器要不要执行这个脚本文件？这样做有什么危害吗？ 我们知道，CSSOM 提供了一个高级的 JavaScript API 来与 DOM 元素的样式进行交互。例如，你可以使用 elem.style.backgroundColor 属性来读取或更新一个 DOM 元素的背景颜色。与 elem 元素相关联的样式对象暴露了 CSSOM 的 API，还有很多其他的 API 可以做同样的事情（请阅读这篇 css-tricks 文章）。 当一个样式表被后台下载时，JavaScript 仍然可以执行，因为主线程没有被加载的样式表所阻挡。如果我们的 JavaScript 程序访问 DOM 元素的 CSS 属性（通过 CSSOM API），我们会得到一个合适的值（根据 CSSOM 的当前状态）。 但是一旦样式表被下载和解析，导致 CSSOM 更新，我们的 JavaScript 现在有一个过时的元素的 CSS 值，因为新的 CSSOM 更新可能已经改变了该 DOM 元素的 CSS 属性。由于这个原因，在下载样式表的时候执行 JavaScript 是不安全的。 根据 HTML5 规范，浏览器可以下载一个脚本文件，但不会执行它，除非之前所有的样式表都被解析了。当一个样式表阻止脚本的执行时，它被称为脚本阻塞型样式表(script-blocking stylesheet)或脚本阻塞型 CSS(script-blocking CSS)。 在上面的例子中，script-blocking.html 包含了一个link 标签（用于外部的样式表），后面是一个 script 标签（用于外部 JavaScript）。这里的 script 下载速度非常快，没有任何延迟，但样式表需要 6 秒才能下载完。因此，尽管我们可以从网络面板上看到，脚本已经完全下载，但浏览器并没有立即执行。只有在样式表加载后，我们看到脚本打印的 Hello World 消息。 就像 async 或 defer 属性使 script 元素不阻塞解析一样，外部的样式表也可以通过 media 属性使其不阻塞渲染。使用 media 属性值，浏览器可以智能地决定何时去加载样式表 文档的 DOMContentLoader 事件DOMContentLoaded(DCL)事件标志着，浏览器从所有可用的 HTML 中，构建出了一个完整的DOM树的时间点。但 DCL 事件被触发时，有很多涉及到的因素会发生变化。 123document.addEventListener(\"DOMContentLoaded\", function (e) { console.log(\"DOM is fully parsed!\");}); 如果我们的 HTML 中不包含任何脚本，DOM 解析就不会被阻塞，DCL 就会随着浏览器解析完整个 HTML 而触发。如果我们有解析器阻塞型脚本，那么 DCL 必须等待所有解析器阻塞型脚本被下载并执行。 当样式表被扔进页面时，事情就变得有点复杂了。即使你没有外部脚本，DCL 也会等到所有样式表被加载。因 DCL 标志着整个 DOM 树已经准备好的时间点，但是在 CSSOM 也被完全构建之前，访问 DOM 都是不太安全的（对于样式信息）。因此，大多数浏览器都会等到所有外部样式表被加载和解析。 脚本阻塞型样式表显然会延迟 DCL。在这种情况下，由于脚本在等待样式表的加载，DOM 树没有被构造出来。 DCL 是网站性能指标之一。我们应该优化 DCL，使其尽可能的小（发生的时间）。其中一个最好的做法是尽可能地使用 defer 和 async 标签来处理 script 元素，这样当脚本在后台下载时，浏览器可以执行其他事情。其次，我们应该优化脚本阻塞型和渲染阻塞型的样式表。 窗口的 load 事件我们知道 JavaScript 可以阻止 DOM 树的生成，但是对于外部的样式表和文件，如图片、视频等就不是这样了。 DOMContentLoaded 事件标志着 DOM 树已经完全构造完成，可以安全访问，window.onload 事件标志着外部样式表和文件下载完毕，我们的Web应用已经完成下载的时间点。 123window.addEventListener( 'load', function(e) { console.log( 'Page is fully loaded!' );} ) 在上面的例子中，rendering.html 文件的头部有一个外部样式表，下载时间大约为5秒。由于它在头部部分，FP 和 FCP 发生在5秒之后，因为样式表会阻止它下面的任何内容的渲染（也就是它阻止了CRP）。 在这之后，我们有一个 img 元素，加载一个需要10秒左右下载的图片。所以浏览器会在后台一直下载这个文件，然后继续进行 DOM 的解析和渲染（因为外部图片资源既不阻挡解析器，也不阻挡渲染）。 接下来，我们有三个外部 JavaScript 文件，它们的下载时间分别为 3s、6s 和 9s，最重要的是，它们不是异步的。这意味着总的加载时间应该接近 18秒，因为在前一个脚本执行之前，后续的脚本不会开始下载。然而，从 DCL 事件来看，我们的浏览器似乎采用了推测性策略，预先下载脚本文件，所以总加载时间接近 9秒。 由于能够影响 DCL 的最后一个下载的文件是最后一个脚本文件，加载时间为9秒（因为样式表已经在 5 秒内下载完毕），所以DCL事件发生在 9.1 秒左右。 我们还有一个外部资源是图片文件，它一直在后台加载。当它完全下载完毕后（需要 10 秒），窗口的 load 事件在10.2秒后被启动，这标志着网页（应用程序）已经完全加载完毕。","link":"/posts/65f9e7b2/"},{"title":"VUE深入学习","text":"深入了解VUE来源：Vue官方中文文档 深入了解组件组件注册组件名在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了： Vue.component('my-component-name', { /* ... */ })该组件名就是 Vue.component 的第一个参数。 你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。 你可以在风格指南中查阅到关于组件名的其它建议。 组件名大小写定义组件名的方式有两种： 使用 kebab-case:Vue.component('my-component-name', { /* ... */ })当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 &lt;my-component-name&gt;。 使用 PascalCase:Vue.component('MyComponentName', { /* ... */ })当使用 PascalCase (驼峰式命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 全局注册到目前为止，我们只用过 Vue.component 来创建组件： 123Vue.component('my-component-name', { // ... 选项 ...}) 这些组件是全局注册的。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中。比如： 12345Vue.component('component-a', { /* ... */ })Vue.component('component-b', { /* ... */ })Vue.component('component-c', { /* ... */ })new Vue({ el: '#app' }) 12345&lt;div id=\"app\"&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;component-b&gt;&lt;/component-b&gt; &lt;component-c&gt;&lt;/component-c&gt;&lt;/div&gt; 在所有子组件中也是如此，也就是说这三个组件在各自内部也都可以相互使用。 局部注册全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。 在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件： 123var ComponentA = { /* ... */ }var ComponentB = { /* ... */ }var ComponentC = { /* ... */ } 然后在 components 选项中定义你想要使用的组件： 1234567new Vue({ el: '#app', components: { 'component-a': ComponentA, 'component-b': ComponentB }}) 对于 components 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。 注意 局部注册的组件在其子组件中不可用。例如，如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写： 12345678var ComponentA = { /* ... */ }var ComponentB = { components: { 'component-a': ComponentA }, // ...} 或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像： 12345678import ComponentA from './ComponentA.vue'export default { components: { ComponentA }, // ...} 注意在 ES2015+ 中，在对象中放一个类似 ComponentA 的变量名其实是 ComponentA: ComponentA 的缩写，即这个变量名同时是： 用在模板中的自定义元素的名称 包含了这个组件选项的变量名 模块系统如果你没有通过 import/require 使用一个模块系统，也许可以暂且跳过这个章节。如果你使用了，那么我们会为你提供一些特殊的使用说明和注意事项。 在模块系统中局部注册如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。 然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 ComponentB.js 或 ComponentB.vue 文件中： 12345678910import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default { components: { ComponentA, ComponentC }, // ...} 现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了。 基础组件的自动化全局注册可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。 所以会导致很多组件里都会有一个包含基础组件的长列表： 1234567891011import BaseButton from './BaseButton.vue'import BaseIcon from './BaseIcon.vue'import BaseInput from './BaseInput.vue'export default { components: { BaseButton, BaseIcon, BaseInput }} 而只是用于模板中的一小部分： 1234567&lt;BaseInput v-model=\"searchText\" @keydown.enter=\"search\"/&gt;&lt;BaseButton @click=\"search\"&gt; &lt;BaseIcon name=\"search\"/&gt;&lt;/BaseButton&gt; 幸好如果你使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码： 12345678910111213141516171819202122232425262728293031323334import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context( // 其组件目录的相对路径 './components', // 是否查询其子目录 false, // 匹配基础组件文件名的正则表达式 /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; { // 获取组件配置 const componentConfig = requireComponent(fileName) // 获取组件的 PascalCase 命名 const componentName = upperFirst( camelCase( // 剥去文件名开头的 `./` 和结尾的扩展名 fileName.replace(/^\\.\\/(.*)\\.\\w+$/, '$1') ) ) // 全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )}) 记住全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生。这里有一个真实项目情景下的示例。 PropProp 的大小写 (camelCase vs kebab-case)HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名： 12345Vue.component('blog-post', { // 在 JavaScript 中是 camelCase 的 props: ['postTitle'], template: '&lt;h3&gt;{{ postTitle }}&lt;/h3&gt;'}) 12&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;&lt;blog-post post-title=\"hello!\"&gt;&lt;/blog-post&gt; 重申一次，如果你使用字符串模板，那么这个限制就不存在了。 Prop 类型到这里，我们只看到了以字符串数组形式列出的 prop： props: ['title', 'likes', 'isPublished', 'commentIds', 'author']但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的名称和类型： props: { title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object }这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到类型检查和其它 prop 验证。 传递静态或动态 Prop像这样，你已经知道了可以像这样给 prop 传入一个静态的值： &lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;你也知道 prop 可以通过 v-bind 动态赋值，例如： 12345&lt;!-- 动态赋予一个变量的值 --&gt;&lt;blog-post v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt;&lt;!-- 动态赋予一个复杂表达式的值 --&gt;&lt;blog-post v-bind:title=\"post.title + ' by ' + post.author.name\"&gt;&lt;/blog-post&gt; 在上述两个示例中，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 prop。 传入一个数字123456&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes=\"42\"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes=\"post.likes\"&gt;&lt;/blog-post&gt; 传入一个布尔值123456789&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;&lt;blog-post is-published&gt;&lt;/blog-post&gt;&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:is-published=\"false\"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:is-published=\"post.isPublished\"&gt;&lt;/blog-post&gt; 传入一个数组123456&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:comment-ids=\"[234, 266, 273]\"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:comment-ids=\"post.commentIds\"&gt;&lt;/blog-post&gt; 传入一个对象123456&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:author=\"{ name: 'Veronica', company: 'Veridian Dynamics' }\"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:author=\"post.author\"&gt;&lt;/blog-post&gt; 传入一个对象的所有属性如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post： 1234post: { id: 1, title: 'My Journey with Vue'} 下面的模板： &lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;等价于： 1234&lt;blog-post v-bind:id=\"post.id\" v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt; 单向数据流所有的 prop 都使得其父子 prop 之间形成了一个 单向下行绑定 ：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你 不应该 在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 这里有两种常见的试图改变一个 prop 的情形：不懂 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 123456props: ['initialCounter'],data: function () { return { counter: this.initialCounter }} 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性： 123456props: ['size'],computed: { normalizedSize: function () { return this.size.trim().toLowerCase() }} 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。 Prop 验证我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。 为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如： 123456789101112131415161718192021222324252627282930313233Vue.component('my-component', { props: { // 基础的类型检查 (`null` 匹配任何类型) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: 'hello' } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 } } }}) 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的属性 (如 data、computed 等) 在 default 或 validator 函数中是不可用的。 类型检查type 可以是下列原生构造函数中的一个： String Number Boolean Array Object Date Function Symbol 额外的，type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认。例如，给定下列现成的构造函数： 1234function Person (firstName, lastName) { this.firstName = firstName this.lastName = lastName} 你可以使用： 12345Vue.component('blog-post', { props: { author: Person }}) 来验证 author prop 的值是否是通过 new Person 创建的。 非 Prop 的特性一个非 prop 特性是指传向一个组件，但是该组件并没有相应 prop 定义的特性。 因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的特性，而这些特性会被添加到这个组件的根元素上。 例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 &lt;bootstrap-date-input&gt; 组件，这个插件需要在其 &lt;input&gt; 上用到一个 data-date-picker 特性。我们可以将这个特性添加到你的组件实例上： &lt;bootstrap-date-input data-date-picker=&quot;activated&quot;&gt;&lt;/bootstrap-date-input&gt;然后这个 data-date-picker=”activated” 特性就会自动添加到 &lt;bootstrap-date-input&gt; 的根元素上。 替换/合并已有的特性想象一下 &lt;bootstrap-date-input&gt; 的模板是这样的： &lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名： 1234&lt;bootstrap-date-input data-date-picker=\"activated\" class=\"date-picker-theme-dark\"&gt;&lt;/bootstrap-date-input&gt; 在这种情况下，我们定义了两个不同的 class 的值： form-control，这是在组件的模板内设置好的 date-picker-theme-dark，这是从组件的父级传入的对于绝大多数特性来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type=”text” 就会替换掉 type=”date” 并把它破坏！庆幸的是，class 和 style 特性会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：form-control date-picker-theme-dark。 禁用特性继承 不懂如果你不希望组件的根元素继承特性，你可以在组件的选项中设置 inheritAttrs: false。例如： 1234Vue.component('my-component', { inheritAttrs: false, // ...}) 这尤其适合配合实例的 $attrs 属性使用，该属性包含了传递给一个组件的特性名和特性值，例如： 1234{ class: 'username-input', placeholder: 'Enter your username'} 有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些特性会被赋予哪个元素。在撰写基础组件的时候是常会用到的： 1234567891011121314Vue.component('base-input', { inheritAttrs: false, props: ['label', 'value'], template: ` &lt;label&gt; {{ label }} &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt; &lt;/label&gt; `}) 这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素： 12345&lt;base-input v-model=\"username\" class=\"username-input\" placeholder=\"Enter your username\"&gt;&lt;/base-input&gt; 自定义事件事件名不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要 完全匹配 监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件： this.$emit('myEvent')则监听这个名字的 kebab-case 版本是不会有任何效果的： &lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或属性名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。 因此，我们推荐你 始终使用 kebab-case 的事件名。 自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突： 12345678910111213141516Vue.component('base-checkbox', { model: { prop: 'checked', event: 'change' }, props: { checked: Boolean }, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; `}) 现在在这个组件上使用 v-model 的时候： &lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 &lt;base-checkbox&gt; 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新。 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。 将原生事件绑定到组件 不懂你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符： &lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt;在有的时候这是很有用的，不过在你尝试监听一个类似 &lt;input&gt; 的非常特定的元素时，这并不是个好主意。比如上述 &lt;base-input&gt; 组件可能做了如下重构，所以根元素实际上是一个 &lt;label&gt; 元素： 12345678&lt;label&gt; {{ label }} &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt;&lt;/label&gt; 这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用。 为了解决这个问题，Vue 提供了一个 $listeners 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如： 1234{ focus: function (event) { /* ... */ } input: function (value) { /* ... */ },} 有了这个 $listeners 属性，你就可以配合 v-on=”$listeners” 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 &lt;input&gt; 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的： 1234567891011121314151617181920212223242526272829303132Vue.component('base-input', { inheritAttrs: false, props: ['label', 'value'], computed: { inputListeners: function () { var vm = this // `Object.assign` 将所有的对象合并为一个新对象 return Object.assign({}, // 我们从父级添加所有的监听器 this.$listeners, // 然后我们添加自定义监听器， // 或覆写一些监听器的行为 { // 这里确保组件配合 `v-model` 的工作 input: function (event) { vm.$emit('input', event.target.value) } } ) } }, template: ` &lt;label&gt; {{ label }} &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on=\"inputListeners\" &gt; &lt;/label&gt; `}) 现在 &lt;base-input&gt; 组件是一个 完全透明的包裹器了，也就是说它可以完全像一个普通的 &lt;input&gt; 元素一样使用了：所有跟它相同的特性和监听器的都可以工作。 .sync 修饰符在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。 这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图： this.$emit('update:title', newTitle)然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如： 1234&lt;text-document v-bind:title=\"doc.title\" v-on:update:title=\"doc.title = $event\"&gt;&lt;/text-document&gt; 为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符： &lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。 当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用： &lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;这样会把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。 插槽插槽内容Vue 实现了一套内容分发的 API，这套 API 基于当前的 Web Components 规范草案，将 &lt;slot&gt; 元素作为承载分发内容的出口。 它允许你像这样合成组件： 123&lt;navigation-link url=\"/profile\"&gt; Your Profile&lt;/navigation-link&gt; 然后你在 &lt;navigation-link&gt; 的模板中可能会写为： 123456&lt;a v-bind:href=\"url\" class=\"nav-link\"&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; 当组件渲染的时候，这个 &lt;slot&gt; 元素将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML： 12345&lt;navigation-link url=\"/profile\"&gt; &lt;!-- 添加一个 Font Awesome 图标 --&gt; &lt;span class=\"fa fa-user\"&gt;&lt;/span&gt; Your Profile&lt;/navigation-link&gt; 甚至其它的组件： 12345&lt;navigation-link url=\"/profile\"&gt; &lt;!-- 添加一个图标的组件 --&gt; &lt;font-awesome-icon name=\"user\"&gt;&lt;/font-awesome-icon&gt; Your Profile&lt;/navigation-link&gt; 如果 &lt;navigation-link&gt; 没有包含一个 &lt;slot&gt; 元素，则任何传入它的内容都会被抛弃。 具名插槽有些时候我们需要多个插槽。例如，一个假设的 &lt;base-layout&gt; 组件的模板如下： 1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;!-- 我们希望把页头放这里 --&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 我们希望把主要内容放这里 --&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 我们希望把页脚放这里 --&gt; &lt;/footer&gt;&lt;/div&gt; 对于这样的情况，&lt;slot&gt; 元素有一个特殊的特性：name。这个特性可以用来定义额外的插槽： 1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 在向具名插槽提供内容的时候，我们可以在一个父组件的 &lt;template&gt; 元素上使用 slot 特性： 123456789101112&lt;base-layout&gt; &lt;template slot=\"header\"&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template slot=\"footer\"&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 另一种 slot 特性的用法是直接用在一个普通的元素上： 12345678&lt;base-layout&gt; &lt;h1 slot=\"header\"&gt;Here might be a page title&lt;/h1&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;p slot=\"footer\"&gt;Here's some contact info&lt;/p&gt;&lt;/base-layout&gt; 我们还是可以保留一个未命名插槽，这个插槽是默认插槽，也就是说它会作为所有未匹配到插槽的内容的统一出口。上述两个示例渲染出来的 HTML 都将会是： 123456789101112&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 插槽的默认内容有的时候为插槽提供默认的内容是很有用的。例如，一个 &lt;submit-button&gt; 组件可能希望这个按钮的默认内容是“Submit”，但是同时允许用户覆写为“Save”、“Upload”或别的内容。 你可以在组件模板里的 &lt;slot&gt; 标签内部指定默认的内容来做到这一点。 123&lt;button type=\"submit\"&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; 如果父组件为这个插槽提供了内容，则默认的内容会被替换掉。 编译作用域当你想在插槽内使用数据时，例如： 123&lt;navigation-link url=\"/profile\"&gt; Logged in as {{ user.name }}&lt;/navigation-link&gt; 该插槽可以访问跟这个模板的其它地方相同的实例属性 (也就是说“作用域”是相同的)。但这个插槽 不能访问 &lt;navigation-link&gt; 的作用域。例如尝试访问 url 是不会工作的。牢记一条准则： 父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。 作用域插槽有的时候你希望提供的组件带有一个可从子组件获取数据的可复用的插槽。例如一个简单的 &lt;todo-list&gt; 组件的模板可能包含了如下代码： 12345678&lt;ul&gt; &lt;li v-for=\"todo in todos\" v-bind:key=\"todo.id\" &gt; {{ todo.text }} &lt;/li&gt;&lt;/ul&gt; 但是在我们应用的某些部分，我们希望每个独立的待办项渲染出和 todo.text 不太一样的东西。这也是作用域插槽的用武之地。 为了让这个特性成为可能，你需要做的全部事情就是将待办项内容包裹在一个 &lt;slot&gt; 元素上，然后将所有和其上下文相关的数据传递给这个插槽：在这个例子中，这个数据是 todo 对象： 12345678910111213&lt;ul&gt; &lt;li v-for=\"todo in todos\" v-bind:key=\"todo.id\" &gt; &lt;!-- 我们为每个 todo 准备了一个插槽，--&gt; &lt;!-- 将 `todo` 对象作为一个插槽的 prop 传入。--&gt; &lt;slot v-bind:todo=\"todo\"&gt; &lt;!-- 回退的内容 --&gt; {{ todo.text }} &lt;/slot&gt; &lt;/li&gt;&lt;/ul&gt; 现在当我们使用 &lt;todo-list&gt; 组件的时候，我们可以选择为待办项定义一个不一样的 &lt;template&gt; 作为替代方案，并且可以通过 slot-scope 特性从子组件获取数据： 123456789&lt;todo-list v-bind:todos=\"todos\"&gt; &lt;!-- 将 `slotProps` 定义为插槽作用域的名字 --&gt; &lt;template slot-scope=\"slotProps\"&gt; &lt;!-- 为待办项自定义一个模板，--&gt; &lt;!-- 通过 `slotProps` 定制每个待办项。--&gt; &lt;span v-if=\"slotProps.todo.isComplete\"&gt;✓&lt;/span&gt; {{ slotProps.todo.text }} &lt;/template&gt;&lt;/todo-list&gt; 解构 slot-scope如果一个 JavaScript 表达式在一个函数定义的参数位置有效，那么这个表达式实际上就可以被 slot-scope 接受。也就是说你可以在支持的环境下 (单文件组件或现代浏览器)，在这些表达式中使用 ES2015 解构语法。例如： 123456&lt;todo-list v-bind:todos=\"todos\"&gt; &lt;template slot-scope=\"{ todo }\"&gt; &lt;span v-if=\"todo.isComplete\"&gt;✓&lt;/span&gt; {{ todo.text }} &lt;/template&gt;&lt;/todo-list&gt; 这会使作用域插槽变得更干净一些。 动态组件 &amp; 异步组件在动态组件上使用 keep-alive我们之前曾经在一个多标签的界面中使用 is 特性来切换不同的组件： &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。例如我们来展开说一说多标签界面 你会注意到，如果你选择了一篇文章，切换到 Archive 标签，然后再切换回 Posts，是不会继续展示你之前选择的文章的。这是因为你每次切换新标签的时候，Vue 都创建了一个新的 currentTabComponent 实例。 重新创建动态组件的行为通常是非常有用的，但是在这个案例中，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 &lt;keep-alive&gt; 元素将其动态组件包裹起来。 1234&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 现在这个 Posts 标签保持了它的状态 (被选中的文章) 甚至当它未被渲染时也是如此。你可以在这个 fiddle 查阅到完整的代码。 注意这个 &lt;keep-alive&gt; 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部/全局注册。 异步组件在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如： 12345678Vue.component('async-example', function (resolve, reject) { setTimeout(function () { // 向 `resolve` 回调传递组件定义 resolve({ template: '&lt;div&gt;I am async!&lt;/div&gt;' }) }, 1000)}) 如你所见，这个工厂函数会收到一个 resolve 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 reject(reason) 来表示加载失败。这里的 setTimeout 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用： 123456Vue.component('async-webpack-example', function (resolve) { // 这个特殊的 `require` 语法将会告诉 webpack // 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require(['./my-async-component'], resolve)}) 你也可以在工厂函数中返回一个 Promise，所以把 webpack 2 和 ES2015 语法加在一起，我们可以写成这样： 12345Vue.component( 'async-webpack-example', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component')) 当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数： 123456new Vue({ // ... components: { 'my-component': () =&gt; import('./my-async-component') }}) 如果你是一个 Browserify 用户同时喜欢使用异步组件，很不幸这个工具的作者明确表示异步加载“并不会被 Browserify 支持”，至少官方不会。Browserify 社区已经找到了一些变通方案，这些方案可能会对已存在的复杂应用有帮助。对于其它的场景，我们推荐直接使用 webpack，以拥有内建的被作为第一公民的异步支持。 处理加载状态这里的异步组件工厂函数也可以返回一个如下格式的对象： 12345678910111213const AsyncComponent = () =&gt; ({ // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000}) 处理边界情况这里记录的都是和处理边界情况有关的功能，即一些需要对 Vue 的规则做一些小调整的特殊情况。不过注意这些功能都是有劣势或危险的场景的。我们会在每个案例中注明，所以当你使用每个功能的时候请稍加留意。 访问元素 &amp; 组件在绝大多数情况下，我们最好不要触达另一个组件实例内部或手动操作 DOM 元素。不过也确实在一些情况下做这些事情是合适的。 访问根实例在每个 new Vue 实例的子组件中，其根实例可以通过 $root 属性进行访问。例如，在这个根实例中： 123456789101112// Vue 根实例new Vue({ data: { foo: 1 }, computed: { bar: function () { /* ... */ } }, methods: { baz: function () { /* ... */ } }}) 所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。 1234567891011// 获取根组件的数据this.$root.foo// 写入根组件的数据this.$root.foo = 2// 访问根组件的计算属性this.$root.bar// 调用根组件的方法this.$root.baz() 对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 Vuex 来管理应用的状态。 访问父级组件实例和 $root 类似，$parent 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。 在绝大多数情况下，触达父级组件会使得你的应用更难调试和理解，尤其是当你变更了父级组件的数据的时候。当我们稍后回看那个组件的时候，很难找出那个变更是从哪里发起的。 另外在一些可能适当的时候，你需要特别地共享一些组件库。举个例子，在和 JavaScript API 进行交互而不渲染 HTML 的抽象组件内，诸如这些假设性的 Google 地图组件一样： 123&lt;google-map&gt; &lt;google-map-markers v-bind:places=\"iceCreamShops\"&gt;&lt;/google-map-markers&gt;&lt;/google-map&gt; 这个 &lt;google-map&gt; 组件可以定义一个 map 属性，所有的子组件都需要访问它。在这种情况下 &lt;google-map-markers&gt; 可能想要通过类似 this.$parent.getMap 的方式访问那个地图，以便为其添加一组标记。你可以在这里查阅这种模式。 请留意，尽管如此，通过这种模式构建出来的那个组件的内部仍然是容易出现问题的。比如，设想一下我们添加一个新的 &lt;google-map-region&gt; 组件，当 &lt;google-map-markers&gt;在其内部出现的时候，只会渲染那个区域内的标记： 12345&lt;google-map&gt; &lt;google-map-region v-bind:shape=\"cityBoundaries\"&gt; &lt;google-map-markers v-bind:places=\"iceCreamShops\"&gt;&lt;/google-map-markers&gt; &lt;/google-map-region&gt;&lt;/google-map&gt; 那么在 &lt;google-map-markers&gt; 内部你可能发现自己需要一些类似这样的 hack： var map = this.$parent.map || this.$parent.$parent.map很快它就会失控。这也是我们针对需要向任意更深层级的组件提供上下文信息时推荐依赖注入的原因。 访问子组件实例或子元素尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 特性为这个子组件赋予一个 ID 引用。例如： &lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;现在在你已经定义了这个 ref 的组件里，你可以使用： this.$refs.usernameInput来访问这个 &lt;base-input&gt; 实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该 &lt;base-input&gt; 组件也可以使用一个类似的 ref 提供对内部这个指定元素的访问，例如： &lt;input ref=&quot;input&quot;&gt;甚至可以通过其父级组件定义方法： 123456methods: { // 用来从父级组件聚焦输入框 focus: function () { this.$refs.input.focus() }} 这样就允许父级组件通过下面的代码聚焦 &lt;base-input&gt; 里的输入框： this.$refs.usernameInput.focus()当 ref 和 v-for 一起使用的时候，你得到的引用将会是一个包含了对应数据源的这些子组件的数组。 $refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这只意味着一个直接的子组件封装的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。 依赖注入在此之前，在我们描述访问父级组件实例的时候，展示过一个类似这样的例子： 12345&lt;google-map&gt; &lt;google-map-region v-bind:shape=\"cityBoundaries\"&gt; &lt;google-map-markers v-bind:places=\"iceCreamShops\"&gt;&lt;/google-map-markers&gt; &lt;/google-map-region&gt;&lt;/google-map&gt; 在这个组件里，所有 &lt;google-map&gt; 的后代都需要访问一个 getMap 方法，以便知道要跟那个地图进行交互。不幸的是，使用 $parent 属性无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：provide 和 inject。 provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 &lt;google-map&gt; 内部的 getMap 方法： 12345provide: function () { return { getMap: this.getMap }} 然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的属性： inject: ['getMap']相比 $parent 来说，这个用法可以让我们在任意后代组件中访问 getMap，而不需要暴露整个 &lt;google-map&gt; 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变/移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 props 一样。 实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了： 祖先组件不需要知道哪些后代组件使用它提供的属性 后代组件不需要知道被注入的属性来自哪里 然而，依赖注入还是有负面影响的。它将你的应用以目前的组件组织方式耦合了起来，使重构变得更加困难。同时所提供的属性是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root做这件事都是不够好的。如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。 你可以在 API 参考文档学习更多关于依赖注入的知识。 程序化的事件侦听器现在，你已经知道了 $emit 的用法，它可以被 v-on 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以： 通过 $on(eventName, eventHandler) 侦听一个事件 通过 $once(eventName, eventHandler) 一次性侦听一个事件 通过 $off(eventName, eventHandler) 停止侦听一个事件你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式： 1234567891011121314// 一次性将这个日期选择器附加到一个输入框上// 它会被挂载到 DOM 上。mounted: function () { // Pikaday 是一个第三方日期选择器的库 this.picker = new Pikaday({ field: this.$refs.input, format: 'YYYY-MM-DD' })},// 在组件被销毁之前，// 也销毁这个日期选择器。beforeDestroy: function () { this.picker.destroy()} 这里有两个潜在的问题： 它需要在这个组件实例中保存这个 picker，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。 我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。 你应该通过一个程序化的侦听器解决这两个问题： 12345678910mounted: function () { var picker = new Pikaday({ field: this.$refs.input, format: 'YYYY-MM-DD' }) this.$once('hook:beforeDestroy', function () { picker.destroy() })} 使用了这个策略，我甚至可以让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己： 12345678910111213141516mounted: function () { this.attachDatepicker('startDateInput') this.attachDatepicker('endDateInput')},methods: { attachDatepicker: function (refName) { var picker = new Pikaday({ field: this.$refs[refName], format: 'YYYY-MM-DD' }) this.$once('hook:beforeDestroy', function () { picker.destroy() }) }} 查阅这个 fiddle 可以了解到完整的代码。注意，即便如此，如果你发现自己不得不在单个组件里做很多建立和清理的工作，最好的方式通常还是创建更多的模块化组件。在这个例子中，我们推荐创建一个可复用的 &lt;input-datepicker&gt; 组件。 注意 Vue 的事件系统不同于浏览器的 EventTarget API。尽管它们工作起来是相似的，但是 $emit、$on, 和 $off 并不是 dispatchEvent、addEventListener 和 removeEventListener 的别名。 循环引用递归组件组件是可以在它们自己的模板中调用自身的。不过它们只能通过 name 选项来做这件事： name: 'unique-name-of-my-component'当你使用 Vue.component 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 name 选项。 123Vue.component('unique-name-of-my-component', { // ...}) 稍有不慎，递归组件就可能导致无限循环： 12name: 'stack-overflow',template: '&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;' 类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 false 的 v-if)。 组件之间的循环引用假设你需要构建一个文件目录树，像访达或资源管理器那样的。你可能有一个 &lt;tree-folder&gt; 组件，模板是这样的： 1234&lt;p&gt; &lt;span&gt;{{ folder.name }}&lt;/span&gt; &lt;tree-folder-contents :children=\"folder.children\"/&gt;&lt;/p&gt; 还有一个 &lt;tree-folder-contents&gt; 组件，模板是这样的： 123456&lt;ul&gt; &lt;li v-for=\"child in children\"&gt; &lt;tree-folder v-if=\"child.children\" :folder=\"child\"/&gt; &lt;span v-else&gt;{{ child.name }}&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; 当你仔细观察的时候，你会发现这些组件在渲染树中互为对方的后代和祖先——一个悖论！当通过 Vue.component 全局注册组件的时候，这个悖论会被自动解开。如果你是这样做的，那么你可以跳过这里。 然而，如果你使用一个模块系统依赖/导入组件，例如通过 webpack 或 Browserify，你会遇到一个错误： Failed to mount component: template or render function not defined.为了解释这里发生了什么，我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A 反正是需要 B 的，但是我们不需要先解析 B。” 在我们的例子中，把 &lt;tree-folder&gt; 组件设为了那个点。我们知道那个产生悖论的子组件是 &lt;tree-folder-contents&gt; 组件，所以我们会等到生命周期钩子 beforeCreate 时去注册它： 123beforeCreate: function () { this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default} 或者，在本地注册组件的时候，你可以使用 webpack 的异步 import： 123components: { TreeFolderContents: () =&gt; import('./tree-folder-contents.vue')} 这样问题就解决了！ 模板定义的替代品内联模板当 inline-template 这个特殊的特性出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活。 123456&lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;These are compiled as the component's own template.&lt;/p&gt; &lt;p&gt;Not parent's transclusion content.&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; 不过，inline-template 会让你模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 template 选项或 .vue 文件里的一个 &lt;template&gt; 元素来定义模板。 X-Templates另一个定义模板的方式是在一个 &lt;script&gt; 元素中，并为其带上 text/x-template 的类型，然后通过一个 id 将模板引用过去。例如： 123456&lt;script type=\"text/x-template\" id=\"hello-world-template\"&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;Vue.component('hello-world', { template: '#hello-world-template'}) 这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。 控制更新感谢 Vue 的响应式系统，它始终知道何时进行更新 (如果你用对了的话)。不过还是有一些边界情况，你想要强制更新，尽管表面上看响应式的数据没有发生改变。也有一些情况是你想阻止不必要的更新。 强制更新如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。 你可能还没有留意到数组或对象的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。 然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 $forceUpdate 来做这件事。 通过 v-once 创建低开销的静态组件渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once 特性以确保这些内容只计算一次然后缓存起来，就像这样： 12345678Vue.component('terms-of-service', { template: ` &lt;div v-once&gt; &lt;h1&gt;Terms of Service&lt;/h1&gt; ... a lot of static content ... &lt;/div&gt; `}) 再说一次，试着不要过度使用这个模式。当你需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 v-once 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。","link":"/posts/5d7b7319/"},{"title":"深拷贝与浅拷贝的区别，实现深拷贝的几种方法","text":"深拷贝与浅拷贝的区别，实现深拷贝的几种方法文章转载自 听风是风 的CSDN博客 区分深拷贝与浅拷贝如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。 此篇文章中也会简单阐述到栈堆，基本数据类型与引用数据类型，因为这些概念能更好的让你理解深拷贝与浅拷贝。我们来举个浅拷贝例子： 12345let a=[0,1,2,3,4], b=a;console.log(a===b);a[0]=1;console.log(a,b); 嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。 那么这里，就得引入基本数据类型与引用数据类型的概念了。面试常问，基本数据类型有哪些，number,string,boolean,null,undefined五类。 引用数据类型(Object类)有常规名值对的无序对象 {a:1}，数组 [1,2,3]，以及函数等。 而这两类数据存储分别是这样的：a.基本类型–名值存储在栈内存中，例如 let a=1; 当你 b=a复制时，栈内存会新开辟一个内存，例如这样： 所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。 b.引用数据类型–键存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图： 当 b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。 而当我们 a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。 那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了 实现深拷贝可以使用递归去复制所有层级属性。这么我们封装一个深拷贝的函数 1234567891011121314151617181920212223function deepClone(obj){ // 判断 obj 是对象还是数组 let objClone = Array.isArray(obj)?[]:{}; if(obj &amp;&amp; typeof obj===\"object\"){ for(key in obj){ // 判断遍历的属性是否为 obj 自身的属性 if(obj.hasOwnProperty(key)){ //判断obj子元素是否为对象，如果是，递归复制 if(obj[key]&amp;&amp;typeof obj[key] ===\"object\"){ objClone[key] = deepClone(obj[key]); }else{ //如果不是，简单复制 objClone[key] = obj[key]; } } } } return objClone;}let a=[1,2,3,4], b=deepClone(a);a[0]=2;console.log(a,b); 可以看到 跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。 这里再次强调，深拷贝，是拷贝对象各个层级的属性，可以看个例子。 1234let a=[1,2,3,4], b=a.slice();a[0]=2;console.log(a,b); 那是不是说 slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改 12345let a=[0,1,[2,3],4], b=a.slice();a[0]=1;a[2][0]=1;console.log(a,b); 拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明 slice根本不是真正的深拷贝。 这里引用知乎问答里面的一张图 第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。 同理，concat方法与 slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。 可以借用 JSON对象的 parse和 stringify12345678910function deepClone(obj){ let _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone}let a=[0,1,[2,3],4], b=deepClone(a);a[0]=1;a[2][0]=1;console.log(a,b); 可以看到，这下b是完全不受a的影响了。 附带说下，JSON.stringify与 JSON.parse除了实现深拷贝，还能结合 localStorage实现对象数组存储。有兴趣可以阅读博客这篇文章。 localStorage存储数组，对象，localStorage,sessionStorage存储数组对象 可以借用JQ的extend方法。$.extend( [deep ], target, object1 [, objectN ] )deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。object1 objectN可选。 Object类型 第一个以及第N个被合并的对象。 12345let a=[0,1,[2,3],4], b=$.extend(true,[],a);a[0]=1;a[2][0]=1;console.log(a,b); 可以看到，效果与上面方法一样，只是需要依赖JQ库。 说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。","link":"/posts/2cd522ad/"},{"title":"事件(event)学习","text":"事件事件流一般浏览器都支持事件冒泡。 事件冒泡从事件开始时由最具体的事件(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档)例如：从 div=&gt; body=&gt; html=&gt; document 事件捕获不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件，用意在于在事件到达预定目标之前捕获他，例如：document=&gt; html=&gt; body=&gt; div DOM事件流DOM2级事件流规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 事件捕获阶段(为截获事件提供了机会) =&gt; 处于目标阶段(实际接收到目标阶段) =&gt; 冒泡阶段(在这个阶段对事件做出响应) 事件处理程序HTML事件处理程序某个元素支持的每种事件，都可以使用一个与之相应事件处理程序同名的 HTML特性 指定。如 onclick,onload,onmouseover等，代码如下： 1&lt;input type=\"button\" value=\"Click Me\" onclick=\"alert('Clicked')\"&gt; 事件处理程序可以是一个函数，这个函数中有一个局部变量 event，也就是事件对象本身，，通过该变量，可以直接访问 事件对象 在这个函数内部，this值等于目标元素 HTML事件处理程序确定：跨浏览器兼容性不强；HTML与 JavaScript耦合严重 DOM0级事件处理程序就是将一个函数赋值给一个事件处理程序的属性。每个元素都有自己的事件处理程序属性，这些属性通常全部小写，例如： 12345var btn = document.getElementById('myBtn')btn.onclick = function() { alert('Clicked') //可以通过this访问目标元素的属性，例如： alert(this.id)} 可以删除通过 DOM0方法指定的事件处理程序，例如：btn.onclick = null DOM2级事件处理程序DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener() 和 removeEventListener()。所有的 DOM节点都包含着两个方法，而且都接受三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 flase，表示在冒泡阶段调用事件处理程序。（不建议在事件捕获阶段注册事件处理程序） 通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()方法来一出，一出是传入的参数与添加事件处理程序是使用的参数相同，意味着通过 addEVentListener()添加的匿名函数将无法移除 IE事件处理程序使用 attachEvent()和 detachEvent()，接受两个参数：事件处理程序名称与事件处理程序函数通过该方法添加的时间都会被添加到冒泡阶段。此外，其事件处理程序会在全局作用域中运行，this===window。 事件对象在触发 DOM上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括 导致事件的元素、事件的类型以及其他与特定事件相关的信息。 例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的按键相关的信息。所有浏览器都支持 event对象。","link":"/posts/4a819108/"},{"title":"表单脚本","text":"表单脚本表单基础使用 document.forms可以取得页面中的所有表单，，在这个集合中，可以通过数值索引或者 name值来去的特定的表单，如： 12var firstForm = document.forms[0]var myForm = document.forms['form2'] 提交表单设置 &lt;input&gt;或 &lt;button&gt;的 type属性为’submit‘可以提交表单，如果是图像按钮，则是通过将其 type属性设置为’image‘来提交。只要表单存在上面任何一种按钮，在相应表单控件拥有焦点的情况下，按回车可以直接提交该表单，如果表单没有提交按钮，按回车不会提交。使用这种方式提交表单时，浏览器会再将请求发送给服务器之前触发 submit事件。从而有机会验证表单数据，并据此决定是否允许表单提交，阻止这个事件的默认行为可以取消表单提交。 在 javascript中，也可以直接调用 submit方法来提交表单，无需包含提交按钮，form.submit()。使用这种法师提交表单是，不会触发 submit事件，因此要记得在调用此方法之前先验证表单数据。 重复点击导致重复提交表单解决方案：1 第一次提交以后禁用提交按钮(document.getElementById('submitBtn').disabled = true) 2. 使用 onsubmit事件处理程序取消后续的表单提交操作 重置表单重置按钮：设置 &lt;input&gt;或 &lt;button&gt;的 type特性值为’reset‘，单击重置按钮时，表单被重置，会触发 reset事件。 在 javascript中，也可以直接调用 reset方法，form.reset()，但与 submit方法不同，调用 reset()方法会触发 reset事件 表单字段每个表单都有 elements属性，该属性是表单中所有表单元素(字段)的集合，是一个有序列表，顺序与他们出现在标记中的顺序相同，可以按照位置和 name特性来访问。例如： 123var form = document.getElementById('form1')var filed1 = form.elements[0]var field2 = form.elements['textbox1']//获得name特性值为'textbox1'的元素 如果多个表单控件都在使用同一个 name，那么就会返回该 name命名的一个 NodeList。 共有的表单字段属性除了 &lt;fieldset&gt;元素意外，所有表单字段都拥有相同的一组属性： disabled布尔值，表示当前字段是否被禁用 form指向当前字段所属表单的指针，只读； name当前字段的名称 readOnly布尔值，表示当前字段是否只读 tabIndex表示当前字段的切换(tab)序号 type当前字段的类型，对于 &lt;select&gt;元素来说是只读的 value当前字段将被提交给服务器的值，对于文件字段来说，这个属性是只读的，包含着文件在计算机中的路径 共有的表单字段方法每个表单字段都有两个方法 focus() 用于将浏览器的焦点设置到表单字段，即激活表单字段，使其能响应键盘事件。使用 focus()方法，可以将用户的注意力吸引到页面中的某个部位 blur() 用于从元素中移走焦点 共有的表单字段事件除了支持鼠标、键盘、更改和 HTML事件外，所有的表单字段都支持以下事件： blue当前字段失去焦点时触发 change对于 &lt;input&gt;和&lt;textarea&gt;元素，在他们失去焦点且 blur值改变时触发；对于 &lt;select&gt;元素，在其选项改变时触发 focus当前字段获得焦点时触发 文本框脚本HTML使用 &lt;input&gt;元素的单行文本框和 &lt;textarea&gt;元素的多行文本框来表现文本框,两者有一定的区别： &lt;input&gt;的特性 size，制定文本框中能够显示的字符数；特性 maxlength用于指定文本框可以接受的最大字符数 &lt;textarea&gt;使用特性 cols指定文本框的字符列数；rows指定文本框的字符行数。无法指定最大字符数。该元素的值放在 &lt;textarea&gt;&lt;/textarea&gt;之间 选择文本以上两种文本框都支持 select()方法，用于选择文本框中的所有文本，且焦点将被设置为文本框。该方法可以在任何时候被调用。document.forms[0].elements['textbox1'].select() 选择(select)事件与 select()方法对应，在选择了文本框中的文本时，就会触发 select事件。在调用 select()方法时，也会触发 selcet事件 取的选择的文本通过 select事件可以知道客户什么时候选择了文本，但不知道选择了什么文本。HTML添加了两个属性：selectionStart和 selectionEnd。这两个属性中保存的是基于0的数值，表示所选择的文本范围（文本选区开头和结尾的偏移量）。用法： 123function getSelectedText(textbox) { return textbox.value.substring(textbox.selectionStart, textbos.selectionEnd)} 选择部分文本HTML5也为选择文本框中的部分文本提供了一个 setSelectionRange()方法，接受两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引值 123textbox.value = 'hello world!'textbox.setSelectionRange(0, textbox.value.length) // 'hello world!'textbox.setSelectionRange(0, 3)//'hel'","link":"/posts/7928995a/"},{"title":"Js运算符和基本语句","text":"JS高级程序设计运算符 规则乘性运算符乘(*) 如果结果太大或太小，那么生成的结果是 Infinity或 -Infinity。 如果某个运算数是 NaN，结果为 NaN。 Infinity乘以 0，结果为 NaN。 Infinity乘以 0 以外的任何数字，结果为 Infinity或 -Infinity。 Infinity乘以 Infinity，结果为 Infinity。注释：如果运算数是数字，那么执行常规的乘法运算，即两个正数或两个负数为正数，两个运算数符号不同，结果为负数。 除(/) 如果结果太大或太小，那么生成的结果是 Infinity或 -Infinity。 如果某个运算数是 NaN，结果为 NaN。 Infinity被 Infinity除，结果为 NaN。 Infinity被任何数字除，结果为 Infinity。 0 除一个任何非无穷大的数字，结果为 NaN。 Infinity被 0 以外的任何数字除，结果为 Infinity或 -Infinity。注释：如果运算数是数字，那么执行常规的除法运算，即两个正数或两个负数为正数，两个运算数符号不同，结果为负数。 取余(%) 如果被除数是 Infinity，或除数是 0，结果为 NaN。 Infinity被 Infinity除，结果为 NaN。 如果除数是无穷大的数，结果为被除数。 如果被除数为 0，结果为 0。注释：如果运算数是数字，那么执行常规的算术除法运算，返回除法运算得到的余数。 加性运算符加(+) 某个运算数是 NaN，那么结果为 NaN。 -Infinity加 -Infinity，结果为 -Infinity。 Infinity加 -Infinity，结果为 NaN。 +0 加 +0，结果为 +0。 -0 加 +0，结果为 +0。 -0 加 -0，结果为 -0。不过，如果某个运算数是字符串，那么采用下列规则： 如果两个运算数都是字符串，把第二个字符串连接到第一个上。 如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。 减(-) 某个运算数是 NaN，那么结果为 NaN。 Infinity减 Infinity，结果为 NaN。 -Infinity减 -Infinity，结果为 NaN。 Infinity减 -Infinity，结果为 Infinity。 -Infinity减 Infinity，结果为 -Infinity。 +0 减 +0，结果为 +0。 -0 减 -0，结果为 -0。 +0 减 -0，结果为 +0。 某个运算符不是数字，那么结果为 NaN。注释：如果运算数都是数字，那么执行常规的减法运算，并返回结果。 逻辑运算符逻辑 NOT运算符（！） 如果运算数是对象，返回 false 如果运算数是数字 0，返回 true 如果运算数是 0 以外的任何数字，返回 false 如果运算数是 null，返回 true 如果运算数是 NaN，返回 true 如果运算数是 undefined，发生错误 逻辑 AND运算符（&amp;&amp;） 如果一个运算数是对象，另一个是 Boolean值，返回该对象。 如果两个运算数都是对象，返回第二个对象。 如果某个运算数是 null，返回 null。 如果某个运算数是 NaN，返回 NaN。 如果某个运算数是 undefined，发生错误。 逻辑 OR运算符(||) 如果一个运算数是对象，并且该对象左边的运算数值均为 false，则返回该对象。 如果两个运算数都是对象，返回第一个对象。 如果最后一个运算数是 null，并且其他运算数值均为 false，则返回 null。 如果最后一个运算数是 NaN，并且其他运算数值均为 false，则返回 NaN。 如果某个运算数是 undefined，发生错误。 语句while,do-while与 for语句的区别do-while为后测试循环语句，至少执行一次；其他两种为前测试循环语句，而 for语句与 while语句在一定程度上是相同的，可以互换 for-in语句是一种精准的迭代语句，可以用来枚举对象的属性，语法如下：for(var property in expression) {statement} label语句可以使用 Label语句在代码中添加标签，以便将来由 break或 continue语句引用，加标签的语句一般都要与循环语句配合使用，label语句语法如下：label:statement 1234//示例start: for (var i - 0;i &lt; count; i++) { alert(i) } break和 continue语句break语句会强制退出循环，强制执行循环以外的语句；continue语句会跳过当前循环，进行下一次循环 with语句（不建议使用）with语句的作用是将代码的作用于设置到一个特定的对象中，语法如下with (expression) statement注意：严格模式不允许使用 with语句。大量使用 with语句会导致性能下降，也会对调试造成困难。 switch语句和if语句类似的条件语句，语法如下： 1234567891011switch (expression) { case value: statement; break; case value: statement; break; case value: statement; break; } 变量变量包括两种不同类型的值：基本类型值（简单的数据段（undefined, null, boolean, number, string)可以按值操作，可以操作保存在变量中的实际的值);引用类型值（可能由多个值构成的对象，保存在内存中的对象） 传递参数在向参数传递基本类型的值的时候，被传递的值会被复制给一个局部变量（即命名参数）。传递引用类型的值得时候，会把这个值在内存中的地址赋值给一个局部变量，因此这个局部变量的变化会反映在函数的外部","link":"/posts/1afcff0/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS flex grid","slug":"CSS-flex-grid","link":"/tags/CSS-flex-grid/"},{"name":"ES6 Set Map JS","slug":"ES6-Set-Map-JS","link":"/tags/ES6-Set-Map-JS/"},{"name":"ES6 Symbol JS","slug":"ES6-Symbol-JS","link":"/tags/ES6-Symbol-JS/"},{"name":"ES6 函数 JS","slug":"ES6-函数-JS","link":"/tags/ES6-%E5%87%BD%E6%95%B0-JS/"},{"name":"ES6 JS 块级","slug":"ES6-JS-块级","link":"/tags/ES6-JS-%E5%9D%97%E7%BA%A7/"},{"name":"ES6 对象 JS","slug":"ES6-对象-JS","link":"/tags/ES6-%E5%AF%B9%E8%B1%A1-JS/"},{"name":"ES6 解构 JS","slug":"ES6-解构-JS","link":"/tags/ES6-%E8%A7%A3%E6%9E%84-JS/"},{"name":"ES6 迭代器与生成器 JS","slug":"ES6-迭代器与生成器-JS","link":"/tags/ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8-JS/"},{"name":"HTML5","slug":"HTML5","link":"/tags/HTML5/"},{"name":"JS 对象 函数","slug":"JS-对象-函数","link":"/tags/JS-%E5%AF%B9%E8%B1%A1-%E5%87%BD%E6%95%B0/"},{"name":"JQ js","slug":"JQ-js","link":"/tags/JQ-js/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"CSS MDN","slug":"CSS-MDN","link":"/tags/CSS-MDN/"},{"name":"HTML MDN","slug":"HTML-MDN","link":"/tags/HTML-MDN/"},{"name":"JS MDN","slug":"JS-MDN","link":"/tags/JS-MDN/"},{"name":"JS Class","slug":"JS-Class","link":"/tags/JS-Class/"},{"name":"JS this","slug":"JS-this","link":"/tags/JS-this/"},{"name":"JS 高阶函数","slug":"JS-高阶函数","link":"/tags/JS-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"name":"JS 原型","slug":"JS-原型","link":"/tags/JS-%E5%8E%9F%E5%9E%8B/"},{"name":"JS 函数参数","slug":"JS-函数参数","link":"/tags/JS-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"},{"name":"JS 对象属性","slug":"JS-对象属性","link":"/tags/JS-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7/"},{"name":"JS 数据类型","slug":"JS-数据类型","link":"/tags/JS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"JS 浏览器","slug":"JS-浏览器","link":"/tags/JS-%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JS Dom","slug":"JS-Dom","link":"/tags/JS-Dom/"},{"name":"JS 基本数据类型","slug":"JS-基本数据类型","link":"/tags/JS-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"JS 引用类型","slug":"JS-引用类型","link":"/tags/JS-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"},{"name":"JS 基本包装类型","slug":"JS-基本包装类型","link":"/tags/JS-%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"},{"name":"JS React","slug":"JS-React","link":"/tags/JS-React/"},{"name":"Scss","slug":"Scss","link":"/tags/Scss/"},{"name":"Head-First CSS HTML","slug":"Head-First-CSS-HTML","link":"/tags/Head-First-CSS-HTML/"},{"name":"CSS HTML5","slug":"CSS-HTML5","link":"/tags/CSS-HTML5/"},{"name":"作品","slug":"作品","link":"/tags/%E4%BD%9C%E5%93%81/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"ES6 迭代器与生成器 JS MJT","slug":"ES6-迭代器与生成器-JS-MJT","link":"/tags/ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8-JS-MJT/"},{"name":"JS RegExp","slug":"JS-RegExp","link":"/tags/JS-RegExp/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"JS DOM Event","slug":"JS-DOM-Event","link":"/tags/JS-DOM-Event/"},{"name":"JS 表单","slug":"JS-表单","link":"/tags/JS-%E8%A1%A8%E5%8D%95/"},{"name":"js 运算符","slug":"js-运算符","link":"/tags/js-%E8%BF%90%E7%AE%97%E7%AC%A6/"}],"categories":[{"name":"ES6 JS","slug":"ES6-JS","link":"/categories/ES6-JS/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"JS语言精粹","slug":"JS语言精粹","link":"/categories/JS%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9/"},{"name":"读书小记","slug":"读书小记","link":"/categories/%E8%AF%BB%E4%B9%A6%E5%B0%8F%E8%AE%B0/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"MDN","slug":"MDN","link":"/categories/MDN/"},{"name":"Morden JavaScript Tutorial","slug":"Morden-JavaScript-Tutorial","link":"/categories/Morden-JavaScript-Tutorial/"},{"name":"JS高级程序设计","slug":"JS高级程序设计","link":"/categories/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"ES6, JS, Morden JavaScript Tutorial","slug":"ES6-JS-Morden-JavaScript-Tutorial","link":"/categories/ES6-JS-Morden-JavaScript-Tutorial/"},{"name":"browser","slug":"browser","link":"/categories/browser/"}]}